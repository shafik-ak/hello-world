const dataHandler = require('./dataHandler')
const https = require('https')
const { resolve } = require('../utils/thenable')
const crypto = require('crypto')

const INVALID_SYMBOLS = /\W|_/g

function _on (options) {
  const _onHandler = function (event, entity, handler) {
    if (Array.isArray(event)) {
      for (const _event of event) {
        _onHandler(_event, entity, handler)
      }
    } else if (Array.isArray(entity)) {
      for (const _entity of entity) {
        _onHandler(event, _entity, handler)
      }
    } else {
      const normalized = _normalizeOnArgs(event, entity, handler)

      _onNormalized.call(this, normalized, options)
    }
    return this
  }
  return _onHandler
}

function _deriveSource ({ queueEnd, appName, appID, ownNamespace }) {
  const shrunkAppID = appID.substring(0, 4)
  return ownNamespace
    ? `queue:${ownNamespace}/${appName}/${shrunkAppID}/${queueEnd}`
    : `queue:${appName}/${shrunkAppID}/${queueEnd}`
}

function _shrinkService (service) {
  const separatedServiceName = service.split('.')
  const serviceWithoutNamespace = separatedServiceName.pop().replace(INVALID_SYMBOLS, '')
  const namespaceHash = crypto
    .createHash('md5')
    .update(separatedServiceName.join('.') || '')
    .digest('hex')
    .substring(0, 4)
  return `${serviceWithoutNamespace}/${namespaceHash}`
}

function _pendingOperations (that) {
  that._pendingOperations = that._pendingOperations || resolve()
  return that._pendingOperations
}

function bind (service, model) {
  const msgOptions = this.options.connectionOptions.get('messaging')
  const namespaceOfService =
    process.env.MESSAGING_NAMESPACE ||
    msgOptions.namespace ||
    (msgOptions.credentials && msgOptions.credentials.namespace)
  const vcapApplication = process.env.VCAP_APPLICATION && JSON.parse(process.env.VCAP_APPLICATION)
  const appName = (vcapApplication && vcapApplication.application_name.replace(INVALID_SYMBOLS, '')) || 'unknownApp'
  const appID = (vcapApplication && vcapApplication.application_id) || '0000'
  const shrunkService = _shrinkService(service)
  const prefix = msgOptions.credentials && msgOptions.credentials.prefix
  const queueEnd = (msgOptions.credentials && msgOptions.credentials.prefix) || shrunkService
  const customSource = msgOptions.credentials && msgOptions.credentials.queue && `queue:${msgOptions.credentials.queue}`

  const options = {
    appID,
    appName,
    service,
    model,
    shrunkService,
    customSource,
    queueEnd,
    namespaceOfService,
    prefix,
    onHandlers: [],
    errHandlers: []
  }

  const boundMessagingFunctions = {
    messagingOptions: options,
    emit: _emit(options).bind(this),
    on: _on(options).bind(this)
  }

  boundMessagingFunctions.on.error = _onError(options).bind(this)

  return boundMessagingFunctions
}

bind.service = bind.bind(this)

function _getPrefixForTopic (options, client) {
  return options.prefix || `${options.namespaceOfService || client._options.namespace}/${options.shrunkService}`
}

function _addSubscription (onHandler, options) {
  _pendingOperations(this)
    .then(() => {
      this.acquire({}, 'messaging').then(client => {
        const source = _getSource(client, options)
        const queueName = _getQueueNameFromSource(source)
        const topic = _getTopicFromOnHandler(onHandler, _getPrefixForTopic(options, client))
        if (client._options.kind === 'enterprise-messaging') {
          _pendingOperations(client)
            .then(() => {
              return this.addSubscription(queueName, topic)
            })
            .then(() => {
              client._pendingOperations = null
            })
        } else {
          client._clientEM.addSubscription(topic)
        }
        this.release(client)
      })
    })
    .then(() => {
      this._pendingOperations = null
    })
}

function _getSource (client, options) {
  const ownNamespace = client._options.namespace
  return (
    options.customSource ||
    _deriveSource({ queueEnd: options.queueEnd, appName: options.appName, appID: options.appID, ownNamespace })
  )
}

function _createQueueAndAddSubscription (normalizedHandler, options) {
  return this.acquire({}, 'messaging').then(client => {
    const source = _getSource(client, options)
    const queueName = _getQueueNameFromSource(source)
    const prefixForTopic = _getPrefixForTopic(options, client)
    const topic = _getTopicFromOnHandler(normalizedHandler, prefixForTopic)
    if (client._options.kind === 'enterprise-messaging') {
      client._pendingOperations = _pendingOperations(client)
        .then(() => this.putQueue(queueName))
        .then(() => this.addSubscription(queueName, topic))
        .then(() => {
          client._pendingOperations = null
        })
    } else {
      client._clientEM.addSubscription(topic)
    }
    client.on(dataHandler(options.onHandlers, options.errHandlers, prefixForTopic), null, source)
    this.release(client)
  })
}

function _onNormalized (normalizedHandler, options) {
  if (normalizedHandler.handler) {
    _checkValidEvent(normalizedHandler, options)
    options.onHandlers.push(normalizedHandler)
  }

  // Registration once a handler is registered
  _pendingOperations(this).then(() => {
    if (options.onHandlers && options.onHandlers.length === 1) {
      _createQueueAndAddSubscription.call(this, normalizedHandler, options)
    } else {
      _addSubscription.call(this, normalizedHandler, options)
    }
  })
}

function _checkValidEvent (normalizedHandler, options) {
  if (normalizedHandler.event && options.model && options.service) {
    const childrenOfService = options.model.childrenOf(options.service)
    // TODO: Compiler limitation: Only unbound events are supported
    // TODO: Compiler fallback: Events are of kind 'type'
    if (!normalizedHandler.entity) {
      const csnEvent = childrenOfService && childrenOfService[normalizedHandler.event]
      if (!csnEvent || (csnEvent.kind !== 'type' && csnEvent.kind !== 'event')) {
        throw new Error(`Element '${normalizedHandler.event}' is not in model.`)
      }
    }
  }
}

function _getQueueNameFromSource (source) {
  return source.replace('queue:', '')
}

function _getTopicFromOnHandler (onHandler, prefix) {
  return onHandler.topic
    ? onHandler.topic
    : onHandler.entity
      ? `${prefix}/${onHandler.entity}/${onHandler.event}`
      : `${prefix}/${onHandler.event}`
}

function _normalizeOnArgs (event, entity, handler) {
  if (entity && entity._entityName) {
    const splitted = entity._entityName.split('.')
    entity = splitted[splitted.length - 1]
  }
  let [_event, _entity, _handler, _topic] = handler
    ? [event, entity, handler, undefined]
    : entity
      ? event.startsWith('topic:') || event.includes('/')
        ? [undefined, undefined, entity, event.replace(/^topic:/, '')]
        : [event, undefined, entity, undefined]
      : ['*', '*', event, undefined]

  return { event: _event, entity: _entity, handler: _handler, topic: _topic }
}

function _onError (options) {
  return function (handler) {
    ;(options.errHandlers || (options.this.errHandlers = [])).push(handler)
  }
}

async function removeAllListeners () {
  if (this.messagingOptions) {
    this.messagingOptions.onHandlers.length = 0
    this.messagingOptions.errHandlers.length = 0
  }
  try {
    const client = await this.acquire({}, 'messaging')
    const source = _getSource(client, this.messagingOptions)
    this.release(client)
    await this.deleteQueue(_getQueueNameFromSource(source))
  } catch (err) {}
}

function _emit (options) {
  return function (event, entity, payload, header) {
    if (!payload && entity && typeof event === 'string' && !event.startsWith('topic:') && !event.includes('/')) {
      _checkValidEvent({ event }, options)
    }
    _pendingOperations(this)
      .then(() => {
        this.acquire({}, 'messaging').then(client => {
          const namespace = options.namespaceOfService || client._options.namespace
          const shrunkService = options.shrunkService
          const [target, msg] = _getTargetAndMessage(payload, namespace, shrunkService, entity, event, header)
          client.emit(msg, target)
          this.release(client)
        })
      })
      .then(() => {
        this._pendingOperations = null
      })
    return this
  }
}

function _handleEventAsString (payload, namespace, shrunkService, entity, event) {
  return event.startsWith('topic:')
    ? [event, { data: entity, ...payload }]
    : event.includes('/')
      ? [`topic:${event}`, { data: entity, ...payload }]
      : [`topic:${namespace}/${shrunkService}/${event}`, { data: entity, ...payload }]
}

function _getTargetAndMessage (payload, namespace, shrunkService, entity, event, header) {
  return typeof payload === 'object' && typeof entity !== 'object'
    ? [`topic:${namespace}/${shrunkService}/${entity}/${event}`, { data: payload, ...header }]
    : entity
      ? typeof event === 'string'
        ? _handleEventAsString(payload, namespace, shrunkService, entity, event)
        : [null, { data: event, ...entity }]
      : [null, { data: event, ...payload }]
}

function _requestOAuthToken (management) {
  return new Promise((resolve, reject) => {
    const {
      oa2: { clientid, clientsecret, tokenendpoint }
    } = management

    const options = {
      host: tokenendpoint.replace('/oauth/token', '').replace('https://', ''),
      path: '/oauth/token?grant_type=client_credentials&response_type=token',
      headers: {
        Authorization: 'Basic ' + Buffer.from(clientid + ':' + clientsecret).toString('base64')
      }
    }

    https.get(options, res => {
      res.setEncoding('utf8')
      let result = ''
      res.on('data', chunk => {
        result += chunk
      })
      res.on('end', () => {
        const json = JSON.parse(result)
        if (!json.access_token) {
          return reject(new Error('Authorization failed'))
        }
        resolve(json.access_token)
      })
    })
  })
}

function addSubscription (queueName, topicPattern) {
  return new Promise((resolve, reject) => {
    this.acquire({}, 'messaging').then(client => {
      return _requestOAuthToken(client._options.management)
        .catch(reject)
        .then(token => {
          const options = {
            host: client._options.management.uri.replace('https://', ''),
            path:
              '/hub/rest/api/v1/management/messaging/queues/' +
              encodeURIComponent(queueName) +
              '/subscriptions/' +
              encodeURIComponent(topicPattern),
            headers: {
              Authorization: 'Bearer ' + token,
              'Content-Type': 'application/json',
              'Content-Length': 0
            },
            method: 'PUT'
          }

          this.release(client)

          const req = https.request(options, res => {
            res.setEncoding('utf8')
            if (res.statusCode !== 200 && res.statusCode !== 201) {
              return reject(new Error(`Subscription "${topicPattern}" could not be added to queue "${queueName}".`))
            }

            res.on('data', body => {
              resolve()
            })
          })

          req.write('')
          req.end()
        })
    })
  })
}

function putQueue (queueName) {
  return new Promise((resolve, reject) => {
    this.acquire({}, 'messaging').then(client => {
      return _requestOAuthToken(client._options.management)
        .catch(reject)
        .then(token => {
          const data = JSON.stringify({ maxQueueSizeInBytes: 0 })
          const options = {
            host: client._options.management.uri.replace('https://', ''),
            path: '/hub/rest/api/v1/management/messaging/queues/' + encodeURIComponent(queueName),
            headers: {
              Authorization: 'Bearer ' + token,
              'Content-Type': 'application/json',
              'Content-Length': data.length
            },
            method: 'PUT'
          }

          this.release(client)

          const req = https.request(options, res => {
            res.setEncoding('utf8')
            if (res.statusCode !== 200 && res.statusCode !== 201) {
              return reject(new Error(`Queue "${queueName}" could not be created.`))
            }

            res.on('data', body => {
              resolve()
            })
          })

          req.write(data)
          req.end()
        })
    })
  })
}

function deleteQueue (queueName) {
  return new Promise((resolve, reject) => {
    this.acquire({}, 'messaging').then(client => {
      return _requestOAuthToken(client._options.management)
        .catch(reject)
        .then(token => {
          const options = {
            host: client._options.management.uri.replace('https://', ''),
            path: '/hub/rest/api/v1/management/messaging/queues/' + encodeURIComponent(queueName),
            headers: {
              Authorization: 'Bearer ' + token,
              'Content-Type': 'application/json',
              'Content-Length': 0
            },
            method: 'DELETE'
          }

          const req = https.request(options, res => {
            res.setEncoding('utf8')
            if (res.statusCode !== 204 && res.statusCode !== 200) {
              this.release(client)
              return reject(new Error('Queue could not be deleted'))
            }

            this.release(client)
            resolve()
          })
          req.write('')
          req.end()
        })
    })
  })
}

module.exports = {
  bind,
  removeAllListeners,
  putQueue,
  deleteQueue,
  addSubscription
}
