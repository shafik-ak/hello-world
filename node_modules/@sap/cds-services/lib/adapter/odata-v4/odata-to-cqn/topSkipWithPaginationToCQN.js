const { maxPageSize, skipToken } = require('../utils/request')

const _getOffset = (offset, incomingSkipToken) => {
  return (offset || 0) + incomingSkipToken
}

const _getMaxRows = (rows, maxPageSize, incomingSkipToken) => {
  if (incomingSkipToken > 0) {
    const tooMuch = rows - maxPageSize

    if (tooMuch < 1) {
      return rows
    }

    if (tooMuch > maxPageSize) {
      return maxPageSize
    }

    return tooMuch
  }

  if (rows > maxPageSize) {
    return maxPageSize
  }

  return rows || 0
}

/**
 * Add pagination params to cqn
 * @param {Object} uriInfo - odata-v4 URI request
 * @param {Object} cqn - CQN Object
 */
const topSkipWithPaginationToCQN = (uriInfo, cqn) => {
  //, maxPageSize, incomingSkipToken
  const pageSize = maxPageSize(uriInfo.getPathSegments())

  if (!pageSize) {
    return
  }

  const incomingSkipToken = skipToken(uriInfo)
  const limit = cqn.SELECT.limit

  if (limit) {
    const rows = _getMaxRows(limit.rows ? limit.rows.val : undefined, pageSize, incomingSkipToken)
    const offset = _getOffset(limit.offset ? limit.offset.val : undefined, incomingSkipToken)

    cqn.SELECT.limit = {
      rows: rows === undefined ? undefined : { val: rows },
      offset: offset === undefined ? undefined : { val: offset }
    }

    return
  }

  cqn.SELECT.limit = {
    rows: { val: pageSize },
    offset: incomingSkipToken ? { val: incomingSkipToken } : undefined
  }
}

module.exports = topSkipWithPaginationToCQN
