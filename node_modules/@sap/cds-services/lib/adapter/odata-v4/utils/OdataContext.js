const BaseContext = require('../../utils/BaseContext')

const {
  Components: {
    ACTION_EXECUTE_HANDLER,
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_CREATE_HANDLER,
    DATA_UPDATE_HANDLER
  }
} = require('@sap/odata-server')
const { getOnCond } = require('@sap/cds-sql').onCond
const { isCustomOperation } = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')
const { isViewWithParamSegments } = require('../odata-to-cqn/selectHelper')
const { isStreaming } = require('./stream')

const ALLOWED_INFO_PROPERTIES = ['code', 'message', 'numericSeverity', 'longtextUrl']

const _isFunctionInvocation = req =>
  req.getUriInfo().getLastSegment().getFunction || req.getUriInfo().getLastSegment().getFunctionImport

const _getTypeName = edmRef =>
  edmRef.getProperty
    ? edmRef
      .getProperty()
      .getType()
      .getName()
    : edmRef.getType().getName()

const isDraftEntity = target => target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction']

const _proxifyForDraftsName = target => {
  const draftName = `${target.name}_drafts`
  const entityProxyHandler = {
    // TODO: persistence name could be set via annotations or uppercase
    get: (obj, prop) => (prop === 'name' || prop === '@cds.persistence.name' ? draftName : obj[prop])
  }
  return new Proxy(target, entityProxyHandler)
}

const _cancelOrDelete = (target, data) => {
  return (target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction']) &&
    data.IsActiveEntity !== 'true'
    ? 'CANCEL'
    : 'DELETE'
}

/**
 * The key predicates or function parameters will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param parameters
 * @returns {Object}
 * @private
 */
const _getParamData = parameters => {
  const paramData = {}

  for (const segmentParam of parameters) {
    const edmRef = segmentParam.getEdmRef()
    const typeName = _getTypeName(edmRef)

    // Convert any integer type into numeric values.
    paramData[edmRef.getName()] = typeName.startsWith('Int') ? Number(segmentParam.getText()) : segmentParam.getText()
  }

  return paramData
}

const _addForeignKeys = (service, req, data) => {
  const pathSegments = req.getUriInfo().getPathSegments()
  // retrieve keys/values from the path segment representing the navigation source
  const navSourceSegment = pathSegments[pathSegments.length - 2]
  const navSourceKeyValues = _getParamData(navSourceSegment.getKeyPredicates())

  // retrieve relevant foreign key properties of the target entity, including the corresponding source key properties
  const navProperty = req
    .getUriInfo()
    .getLastSegment()
    .getNavigationProperty()

  if (navProperty.getPartner()) {
    const refConstraints = navProperty.getPartner().getReferentialConstraints()

    // set value of foreign key properties as specified in the navigation source segment
    for (const key of Object.keys(navSourceKeyValues)) {
      const refConstraint = [...refConstraints].find(r => r[1].constraint.referencedProperty === key)
      // exclude source keys if they cannot be matched (e.g. isActiveEntity in draft scenario)
      if (refConstraint) {
        data[refConstraint[0]] = navSourceKeyValues[key]
      }
    }
  } else {
    const entityName = navSourceSegment
      .getEntitySet()
      .getEntityType()
      .getFullQualifiedName()
      .toString()
    const navigationName = navProperty.getName()
    const navigationDefinition = service.model.definitions[entityName].elements[navigationName]
    const onCondition = getOnCond(navigationDefinition, navigationName, service.model, 'target', 'source')

    // works only for custom on condition working on keys with '=' operator
    // and combination of multiple conditions connected with 'and'
    for (const key of Object.keys(navSourceKeyValues)) {
      // find index of source column
      const sourceIndex = onCondition.findIndex(e => e.ref && e.ref[0] === 'source' && e.ref[1] === key)
      // if '=' follows on index, the target columns comes next
      const {
        ref: [, target]
      } = onCondition[sourceIndex + 1] === '=' ? onCondition[sourceIndex + 2] : onCondition[sourceIndex - 2]
      data[target] = navSourceKeyValues[key]
    }
  }
}

const _getFunctionParameters = (lastSegment, keyValues) => {
  const functionParameters = lastSegment.getFunctionParameters()
  const paramValues = _getParamData(functionParameters)

  // Working assumption for the case of name collisions: take the entity's key
  for (const key of Object.keys(keyValues)) {
    paramValues[key] = keyValues[key]
  }
  return paramValues
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  let navSegmentName
  let entityName = `${service.name}.${pathSegments[0].getEntitySet().getName()}`

  // special case of view with parameter, no navigation needed
  if (isViewWithParamSegments(pathSegments)) {
    return entityName
  }

  for (const navSegment of pathSegments.filter(segment => segment.getNavigationProperty() !== null)) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName =
      navSegmentName === 'DraftAdministrativeData'
        ? service.entities[navSegmentName].name
        : service.model.definitions[entityName].elements[navSegmentName].target
  }

  return entityName
}

const _newOrCreate = target => {
  return target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction'] ? 'NEW' : 'CREATE'
}

const _patchOrUpdate = target => {
  return target['@odata.draft.enabled'] || target['@Common.DraftNode.PreparationAction'] ? 'PATCH' : 'UPDATE'
}

const _readOrOperation = (pathSegments, target) => {
  if (isCustomOperation(pathSegments)) {
    const invokedFunction = pathSegments[pathSegments.length - 1].getFunction()
    return target ? invokedFunction.getName() : invokedFunction.getFullQualifiedName().toString()
  }
  return 'READ'
}

const _definedNameOrEdit = (target, pathSegments, service) => {
  const lastSegment = pathSegments[pathSegments.length - 1].getAction().getName()

  if (target) {
    return lastSegment === 'draftEdit' ? 'EDIT' : lastSegment
  }

  return `${service.name}.${lastSegment}`
}

const _getEvent = ({ component, pathSegments, target, data, service }) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return _newOrCreate(target)
    case DATA_UPDATE_HANDLER:
      return _patchOrUpdate(target)
    case DATA_DELETE_HANDLER:
      return _cancelOrDelete(target, data)
    case DATA_READ_HANDLER:
      return _readOrOperation(pathSegments, target)
    case ACTION_EXECUTE_HANDLER:
      return _definedNameOrEdit(target, pathSegments, service)
  }
}

/**
 * Normalization is needed because only certain properties are allowed in an info message.
 * As well js errors cannot be JSON.stringified later on.
 */
const _normalizeInfoMessage = info => {
  if (typeof info === 'string') {
    return { message: info }
  }

  const infoObj = {}

  for (const property of Object.getOwnPropertyNames(info)) {
    if (ALLOWED_INFO_PROPERTIES.includes(property)) {
      infoObj[property] = info[property]
    }
  }

  return infoObj
}

class OdataContext extends BaseContext {
  constructor (component, service, req, res, noProxyTarget = false) {
    super(service, req.getAtomicityGroupId())

    const pathSegments = req.getUriInfo().getPathSegments()
    const definitions = service.model.definitions
    const target = definitions[_getTargetEntityName(service, pathSegments)]
    this._ = this._getUnderscore(req, res)

    this.setHttpMethod(req.getMethod())

    this.setUserAndAttr(service)

    this.data = this._getData(component, service, req, target)

    this.target =
      !noProxyTarget && target && isDraftEntity(target) && this.data.IsActiveEntity !== 'true'
        ? _proxifyForDraftsName(target)
        : target

    this.event = _getEvent({ component, pathSegments, target: this.target, data: this.data, service })

    this.info = info => {
      this._.infos = this._.infos || []
      const infoObj = _normalizeInfoMessage(info)
      this._.infos.push(infoObj)

      return infoObj
    }

    Object.defineProperty(this, 'query', {
      configurable: true,
      get: function () {
        const query = odataToCQN(isCustomOperation(pathSegments) || component, service, this, req)
        Object.defineProperty(this, 'query', { value: query, writable: true })
        return query
      },
      set: function (value) {
        Object.defineProperty(this, 'query', { value: value, writable: true })
      }
    })

    this.postPreparation(req.getIncomingRequest())

    const atomicityGroupId = req.getAtomicityGroupId()
    if (atomicityGroupId) {
      this.setStore(this._.shared.eventEmitterOfAtomicityGroup.get(atomicityGroupId))
    }
  }

  /**
   * Get data from odata-v4.
   * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
   * For function invocations the URL parameters are set as data.
   * For CREATE and UPDATE annotated columns can be mixed in.
   *
   * @param {string} component - odata-v4 component which processes this request.
   * @param req
   * @returns {Object}
   * @private
   */
  _getData (component, service, req, target) {
    const segments = req.getUriInfo().getPathSegments()
    const lastSegment = req.getUriInfo().getLastSegment()
    const streaming = isStreaming(segments)
    const keyPredicates = streaming ? segments[segments.length - 2].getKeyPredicates() : lastSegment.getKeyPredicates()
    const keyValues = _getParamData(keyPredicates)

    if (component === DATA_READ_HANDLER && _isFunctionInvocation(req)) {
      return _getFunctionParameters(lastSegment, keyValues)
    }

    if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
      return keyValues
    }

    // Use identifier from URL instead of body
    let data = req.getBody() || {}

    if (streaming) {
      const dataObj = {}
      dataObj[lastSegment.getProperty().getName()] = data
      data = dataObj
    }

    // Only to be done for post via navigation
    if (component === DATA_CREATE_HANDLER && lastSegment.getKind() === 'NAVIGATION.TO.MANY') {
      _addForeignKeys(service, req, data)
    }

    if (component === DATA_UPDATE_HANDLER || component === DATA_CREATE_HANDLER) {
      this.fillKeyValues(keyValues, data)
    }

    return data
  }

  /**
   * In case of batch request use the applicationData object as base,
   * else create a new object.
   * @param {Object} req - odata-v4 request object.
   * @param {Object} res - odata-v4 response object.
   * @return {Object}
   * @private
   */
  _getUnderscore (req, res) {
    const _ = {}
    _.shared = req.getBatchApplicationData()

    // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
    if (!_.shared) {
      _.shared = {}
    }

    this._temporalValues(_, req.getQueryOptions())

    _.odataReq = req
    _.odataRes = res

    // Give the app developer access to the original (express) request object
    if (!_.req) {
      _.req = req.getIncomingRequest()
    }

    return _
  }
}

module.exports = OdataContext
