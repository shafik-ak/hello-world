const cds = require('../../cds')
const serviceFactory = require('../../services/service_factory')
const OData = require('./OData')

class Dispatcher {
  /**
   * Constructs an Dispatcher for OData service.
   * New OData services will be created in case of extensibility.
   *
   * @param odata
   */
  constructor (odata) {
    this._odata = odata
  }

  _enableMtx () {
    if (!this._extMap) {
      this._extMap = new Map()
      cds.mtx.eventEmitter.on(cds.mtx.events.TENANT_UPDATED, async tenantId => {
        this._extMap.delete(tenantId)
      })
    }
  }

  _addCustomHandlers (service) {
    service.impl(srv => {
      for (const before of this._odata._cdsService._handlers.before._handlers) {
        if (!before.handler.isDefault) {
          srv.before(before.event, before.entity, before.handler)
        } else {
          break
        }
      }
      for (const on of this._odata._cdsService._handlers.on._handlers) {
        if (!on.handler.isDefault) {
          srv.on(on.event, on.entity, on.handler)
        } else {
          break
        }
      }
      for (const after of this._odata._cdsService._handlers.after._handlers) {
        if (!after.handler.isDefault) {
          srv.after(after.event, after.entity, after.handler)
        } else {
          break
        }
      }
    })
  }

  async _getProtocolAndService (tenantId) {
    if (await cds.mtx.isExtended(tenantId)) {
      const csn = await cds.mtx.getCsn(tenantId)
      const service = serviceFactory(csn, this._odata._options)
      this._addCustomHandlers(service)
      service._isExtended = true
      const edm = cds.compile.to.edm(csn, { service: service.options.service, version: 'v4' })
      const odata = new OData(cds, edm, csn, this._odata._options)
      odata.addCDSServiceToChannel(service)

      return odata
    } else {
      return this._odata
    }
  }

  async _processExtTenant (req, res) {
    try {
      if (!this._extMap.has(req.authInfo.identityZone)) {
        this._extMap.set(req.authInfo.identityZone, await this._getProtocolAndService(req.authInfo.identityZone))
      }

      this._extMap.get(req.authInfo.identityZone).process(req, res)
    } catch (err) {
      res.status(500).send({
        error: {
          code: null,
          message: 'Internal Server Error'
        }
      })
    }
  }

  /**
   * Dispatch request in case of extensibility to other odata adapters.
   * @private
   */
  dispatch (req, res) {
    if (cds.mtx && Object.keys(cds.mtx).length !== 0 && req.authInfo && req.authInfo.identityZone) {
      this._enableMtx()
      this._processExtTenant(req, res)
    } else {
      this._odata.process(req, res)
    }
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   * @returns {function}
   */
  getService () {
    return (req, res) => {
      this.dispatch(req, res)
    }
  }
}

module.exports = Dispatcher
