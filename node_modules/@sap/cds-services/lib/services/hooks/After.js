const Base = require('./Base')
const { resolve, reject } = require('../../util/thenable')
const { CONTEXT_ERROR, handleErrorLog } = require('../../util/errors')

/**
 * Class representation of after middleware.
 * @augments Base
 * @alias module:hooks.After
 */
class After extends Base {
  _addHandler (event, entity, handler) {
    const wrappedHandler = this._addConvenienceWrapper(handler)

    if (this._isWithMode) {
      this._withHandlers.push({ event, entity, handler: wrappedHandler })
    } else {
      this._handlers.push({ event, entity, handler: wrappedHandler })
    }
  }

  /**
   * In case the app developer uses the single arguments row or each for his handler, he wants convenience.
   * This means, the framework has to wrap his function in an iterator in case the result is an array.
   * @param {function} handler
   * @return {function}
   * @private
   */
  _addConvenienceWrapper (handler) {
    if (/^\s*?(?:async)?\s*(?:\(\s*)?(?:row|each)\s*\)?\s*=>/.test(handler.toString())) {
      return result => {
        if (Array.isArray(result)) {
          for (const row of result) {
            handler(row)
          }

          return
        }

        handler(result)
      }
    }

    return handler
  }

  /**
   * Check if handlers are registered for event and entity. Execute all handlers that are registered,
   * with result being passed in as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .reply(), .error(), ...
   * @param {Object} context.target - the unreflected entity.
   * @param {Object|Array} result - the result being received from the OnHandler. In case of a COMMIT or ROLLBACK event
   *                                this could also be the error that indicates that the transaction operation failed.
   */
  executeHandlerIfListed (event, context, result) {
    delete context.reply
    return this._execute(event, context, context.event === 'READ' ? this._getResultAsArray(result) : result)
  }

  /**
   * Check if result is array and if not return result as single entry in an array.
   * @param result
   * @return {Array}
   * @private
   */
  _getResultAsArray (result) {
    // Null, 0, false, '', ... should be wrapped
    if (result === undefined) {
      return []
    }

    return Array.isArray(result) ? result : [result]
  }

  _execute (event, context, result) {
    if (this._isTransactionEvent(event)) {
      return this._matchAndRunHandlers(event, context, result)
    }

    return this._matchAndRunHandlers(event, context, result)
  }

  _checkLoggingForRejected (entry, context) {
    if (!entry.handler.isDefault) {
      context.rejected[Symbol.for(CONTEXT_ERROR)] = true
    }
  }

  _matchHandlers (chain, event, context, entry, result) {
    if (this._match(event, context, entry)) {
      this._measureStartTime(context, entry)

      chain = (chain || resolve())
        .then(() => {
          const fnReturn = entry.handler(result, context)

          if (context.rejected) {
            this._checkLoggingForRejected(entry, context)
            return reject(context.rejected)
          }

          if (fnReturn && fnReturn.then) {
            return fnReturn.then(() => {
              this._measureEndTime(context, entry)
            })
          } else {
            this._measureEndTime(context, entry)
            return fnReturn
          }
        })
        .catch(err => {
          handleErrorLog(entry, context, err[Symbol.for(CONTEXT_ERROR)])
          return reject(err)
        })
    }
    return chain
  }

  _matchAndRunHandlers (event, context, result) {
    let chain

    for (const entry of this._handlers) {
      chain = this._matchHandlers(chain, event, context, entry, result)
    }

    if (chain) {
      return chain.then(() => {
        return this._handleErrors(context, result)
      })
    }

    return this._handleErrors(context, result)
  }
}

module.exports = After
