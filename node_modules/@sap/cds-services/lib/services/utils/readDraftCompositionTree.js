const { getDraftCompositionSet, getDraftCompositionTree } = require('./compositionTree')
const { getKeyData } = require('./draftWhereUtils')
const { ensureDraftsSuffix, ensureNoDraftsSuffix } = require('./draftUtils')
const getColumns = require('../utils/columns')
const { DRAFT_COLUMNS } = require('../utils/constants')
const _getEntities = (nameSet, definitions) => {
  const entities = []

  for (const name of nameSet) {
    entities.push(definitions[name])
  }

  return entities
}
const _isAssocOrComp = element => element.type === 'cds.Association' || element.type === 'cds.Composition'

const _getColumns = entity => {
  return Object.values(entity.elements)
    .filter(e => !_isAssocOrComp(e) && !DRAFT_COLUMNS.includes(e.name))
    .map(e => e.name)
}

const _generateSelectCqnsFromRootDraft = (entities, context, draftUUID) => {
  const draftCqns = []
  for (const entity of entities) {
    draftCqns.push(
      context.statements.SELECT.from(`${entity.name}_drafts`)
        .columns(_getColumns(entity))
        .where('DraftAdministrativeData_DraftUUID', draftUUID)
    )
  }

  return draftCqns
}

const _createMapOfResults = (entities, draftResults) => {
  const map = new Map()

  for (let i = 0, length = entities.length; i < length; i++) {
    map.set(entities[i].name, draftResults[i])
  }

  return map
}

const _generateEntitiesOfLevelMap = (map, obj, maxLevel, level = 0) => {
  if (level < maxLevel) {
    for (const compositionElement of obj.compositionElements) {
      const newLevel = level + 1
      if (map.has(newLevel)) {
        map.get(newLevel).push(compositionElement)
      } else {
        const element = map.get(level)[0]
        if (element.source !== compositionElement.source) {
          map.set(newLevel, [compositionElement])
        }
      }
      _generateEntitiesOfLevelMap(map, compositionElement, maxLevel, newLevel)
    }
  }
}

const _currentAndParentMatch = (currentValue, parentValue, backLinks) => {
  let match = true
  for (const backLink of backLinks) {
    if (parentValue[backLink.targetKey] !== currentValue[backLink.entityKey]) {
      match = false
      break
    }
  }
  return match
}

const _linkCurrentDataToParentData = (currentLevelData, currentLevelEntity, parentData, backLinks) => {
  if (currentLevelData.length === 0) {
    for (const parentValue of parentData) {
      parentValue[currentLevelEntity.name] = []
    }
  }

  for (const currentValue of currentLevelData) {
    for (const parentValue of parentData) {
      if (!parentValue[currentLevelEntity.name]) {
        parentValue[currentLevelEntity.name] = []
      }

      if (_currentAndParentMatch(currentValue, parentValue, backLinks)) {
        parentValue[currentLevelEntity.name].push(currentValue)
      }
    }
  }
}

const _linkResultsOfLevelToParent = (entitiesOfLevelMap, level, resultMap) => {
  const currentLevelEntities = entitiesOfLevelMap.get(level)
  const currentData = currentLevelEntities.map(({ source }) => resultMap.get(source))

  if (level === 0) {
    return currentData
  }

  for (let i = 0, length = currentLevelEntities.length; i < length; i++) {
    const backLinks = currentLevelEntities[i].backLinks
    const parentData = resultMap.get(currentLevelEntities[i].target)
    _linkCurrentDataToParentData(currentData[i], currentLevelEntities[i], parentData, backLinks)
  }

  return _linkResultsOfLevelToParent(entitiesOfLevelMap, level - 1, resultMap)
}

const _generateResultObject = (entitiesOfLevelMap, resultMap) => {
  const maxLevel = entitiesOfLevelMap.size - 1
  return _linkResultsOfLevelToParent(entitiesOfLevelMap, maxLevel, resultMap)
}

const _readRoot = (context, requestActiveData) => {
  const keys = Object.keys(context.target.keys).filter(key => key !== 'IsActiveEntity')
  const keyData = getKeyData(keys, context.query.SELECT.where)
  const columns = getColumns(context.target, true)
  return context.run(
    context.statements.SELECT.from(
      requestActiveData ? ensureNoDraftsSuffix(context.target.name) : ensureDraftsSuffix(context.target.name),
      requestActiveData ? columns : [...columns, 'DraftAdministrativeData_DraftUUID']
    ).where(keyData)
  )
}

const _readDraftAdministrativeData = (context, draftEntity, draftUUID) =>
  context.run(
    context.statements.SELECT.from(draftEntity, getColumns(draftEntity, true)).where({ DraftUUID: draftUUID })
  )

const _containsAllBackLinks = (backLinks, subRows, rows) => {
  return backLinks.every(backlink => subRows[backlink.targetKey] === rows[backlink.entityKey])
}

const _modifyResult = (compositionElement, subRows, rows) => {
  if (_containsAllBackLinks(compositionElement.backLinks, subRows, rows)) {
    if (!Array.isArray(subRows[compositionElement.name])) {
      subRows[compositionElement.name] = []
    }

    subRows[compositionElement.name] = [...subRows[compositionElement.name], rows]
  }
}

const _constructDeepResult = (compositionElement, rows) => {
  for (let i = rows.length - 1; i >= 0; i--) {
    for (let j = i - 1; j >= 0; j--) {
      _modifyResult(compositionElement, rows[j], rows[i])
    }
  }
}

const _modifyResultsForSelfReferencingEntities = (resultMap, compositionTree) => {
  for (const res of resultMap) {
    const entityName = res[0]
    const rows = res[1]
    if (compositionTree.source === entityName && rows.length > 1) {
      // self referencing entities?
      // build nested structure

      for (const compositionElement of compositionTree.compositionElements) {
        _constructDeepResult(compositionElement, rows)

        resultMap.set(res[0], [rows[0]])
      }
    }
  }
}

const readDraftCompositionTree = async (service, context) => {
  const root = await _readRoot(context, false)

  if (root.length === 0) {
    context.reject(404)
    return
  }

  const draftAdministrativeData = await _readDraftAdministrativeData(
    context,
    service.model.definitions['DRAFT.DraftAdministrativeData'],
    root[0].DraftAdministrativeData_DraftUUID
  )

  const compSet = getDraftCompositionSet(service.model.definitions, ensureNoDraftsSuffix(context.target.name))
  const entities = _getEntities(compSet, service.model.definitions)

  const compositionTree = getDraftCompositionTree(
    service.model.definitions,
    ensureNoDraftsSuffix(context.target.name),
    false
  )

  const draftCQNs = _generateSelectCqnsFromRootDraft(entities, context, root[0].DraftAdministrativeData_DraftUUID)
  const results = await Promise.all(draftCQNs.map(cqn => context.run(cqn)))

  const resultMap = _createMapOfResults(entities, results)
  _modifyResultsForSelfReferencingEntities(resultMap, compositionTree)

  const entitiesOfLevelMap = new Map([[0, [compositionTree]]])
  _generateEntitiesOfLevelMap(entitiesOfLevelMap, compositionTree, results.length)

  return { data: _generateResultObject(entitiesOfLevelMap, resultMap), administrativeData: draftAdministrativeData[0] }
}

module.exports = {
  readDraftCompositionTree
}
