const { readAndDeleteKeywords } = require('./draftWhereUtils')
const getColumns = require('../utils/columns')
const getServiceNamespace = targetName => targetName.replace(/\.\w+$/i, '')
const getEntityName = source => source.replace(/.+\./, '')
const getDraftName = (serviceNamespace, entityName) => `${serviceNamespace}.${entityName}_drafts`

const ensureDraftsSuffix = name => (name.endsWith('_drafts') ? name : `${name}_drafts`)
const ensureNoDraftsSuffix = name => (name.endsWith('_drafts') ? name.slice(0, -7) : name)

const _getParentCQNWithKeyColumn = (parentCQN, parentKeyName) => {
  const parentCQNWithKeyColumn = Object.assign({}, parentCQN)
  parentCQNWithKeyColumn.SELECT = Object.assign({}, parentCQN.SELECT)
  parentCQNWithKeyColumn.SELECT.columns = [{ ref: [parentKeyName] }]
  return parentCQNWithKeyColumn
}

const getSubCQNs = ({ definitions, context, rootCQN, compositionTree, selectFromDraft = false }) => {
  const subCQNs = []
  const serviceNamespace = getServiceNamespace(ensureNoDraftsSuffix(context.target.name))
  // only one backLink
  const _generateSubCQNs = (parentEntity, parentCQN, compositionElements, level = 1) => {
    for (const element of compositionElements) {
      const backLink = element.backLinks[0] || element.customBackLinks[0]

      const parentKey = Object.keys(parentEntity.elements)
        .map(elementName => parentEntity.elements[elementName])
        .filter(element => element.key)

      const columns = getColumns(definitions[element.source], true)

      if (parentKey[0]) {
        const subCQN = context.statements.SELECT.from(
          selectFromDraft ? getDraftName(serviceNamespace, getEntityName(element.source)) : element.source,
          selectFromDraft ? [...columns, 'DraftAdministrativeData_DraftUUID'] : columns
        ).where({ ref: [backLink.entityKey] }, 'in', _getParentCQNWithKeyColumn(parentCQN, parentKey[0].name))

        subCQNs.push({ cqn: subCQN, level })
        _generateSubCQNs(definitions[element.source], subCQN, element.compositionElements, level + 1)
      }
    }
  }

  _generateSubCQNs(context.target, rootCQN, compositionTree.compositionElements)

  return subCQNs
}

const _isDraftAnnotated = entity => {
  return (
    entity['@Common.DraftRoot.PreparationAction'] === 'draftPrepare' ||
    entity['@Common.DraftNode.PreparationAction'] === 'draftPrepare'
  )
}

const proxifyToNoDraftsName = target => {
  const entityProxyHandler = {
    get: (obj, prop) =>
      prop === 'name' || prop === '@cds.persistence.name' ? ensureNoDraftsSuffix(target.name) : obj[prop]
  }
  return new Proxy(target, entityProxyHandler)
}

const hasDraft = (definitions, cqn) => {
  if (_isDraftAnnotated(definitions[cqn.SELECT.from.ref[cqn.SELECT.from.ref.length - 1]])) {
    return true
  }

  if (cqn.SELECT.where) {
    for (const element of cqn.SELECT.where) {
      if (element.SELECT && hasDraft(definitions, element)) {
        return true
      }
    }
  }

  return false
}

/**
 * Converts db entity names in the composition set to draft entity names
 * e.g. dataModel.Books will be converted to service.namespace.Books_drafts
 *
 * @param {*} compositionSet
 * @param {*} model
 * @param {*} context
 */
const draftNamesForCompositionSet = (compositionSet, model, { target: { name } }) => {
  // remove entity name
  const serviceNamespace = name.match(/.*\./)[0]

  const servicesInNamespace = Object.keys(model)
    .map(key => model[key])
    .filter(entity => entity.name.startsWith(serviceNamespace))
  const result = []

  for (const entity of compositionSet) {
    servicesInNamespace.map(({ source, name }) => {
      if (source === entity) {
        return result.push(`${name}_drafts`)
      }
    })
  }

  return result
}

const getUpdateDraftAdminCQN = ({ statements, user }, draftUUID) => {
  const set = {
    InProcessByUser: user.id,
    LastChangedByUser: user.id,
    LastChangeDateTime: new Date(Date.now()).toISOString()
  }

  return statements
    .UPDATE('DRAFT.DraftAdministrativeData')
    .set(set)
    .where({ DraftUUID: draftUUID })
}

const getEnrichedCQN = (cqn, select, draftWhere, addLimitOrder = true) => {
  if (draftWhere && draftWhere.length !== 0) {
    cqn.where(draftWhere)
  }

  if (select.distinct) {
    cqn.distinct()
  }

  if (select.having) {
    cqn.having(select.having)
  }

  // groupBy, orderBy and limit do not support partial CQNs
  if (select.groupBy) {
    cqn.SELECT.groupBy = select.groupBy
  }

  if (select.orderBy && addLimitOrder) {
    cqn.SELECT.orderBy = select.orderBy
  }

  if (select.limit && addLimitOrder) {
    cqn.SELECT.limit = select.limit
  }

  return cqn
}

// Only works for root entity, otherwise the relative position needs to be adapted
const setStatusCodeAndHeader = (response, keys, entityName, isActiveEntity) => {
  response.setStatusCode(201)

  const keysString = Object.keys(keys)
    .map(key => `${key}=${keys[key]}`)
    .join(',')
  response.setHeader('location', `../${entityName}(${keysString},IsActiveEntity=${isActiveEntity})`)
}

const removeDraftUUID = result => {
  if (Array.isArray(result)) {
    for (const row of result) {
      delete row.DraftAdministrativeData_DraftUUID
    }
  } else {
    delete result.DraftAdministrativeData_DraftUUID
  }

  return result
}

const activeVersionExists = context => {
  const newWhere = [...context.query.SELECT.where]
  readAndDeleteKeywords(['IsActiveEntity'], newWhere)
  return context
    .run(context.statements.SELECT.from(ensureNoDraftsSuffix(context.target.name), [1]).where(newWhere))
    .then(result => result.length > 0)
}

const isDraftActivateAction = context => context._.odataReq.getUrlObject().path.endsWith('draftActivate')

const addColumnAlias = (columns, alias) => {
  if (!alias) {
    return columns
  }

  return columns.map(col => {
    if (typeof col === 'string') {
      return { ref: [alias, col] }
    }

    if (col.ref && !col.expand) {
      const obj = Object.assign({}, col)
      obj.ref = [alias, col.ref[col.ref.length - 1]]
      return obj
    }

    return col
  })
}

module.exports = {
  getServiceNamespace,
  getDraftName,
  getEntityName,
  getSubCQNs,
  draftNamesForCompositionSet,
  getUpdateDraftAdminCQN,
  getEnrichedCQN,
  removeDraftUUID,
  setStatusCodeAndHeader,
  activeVersionExists,
  isDraftActivateAction,
  ensureDraftsSuffix,
  ensureNoDraftsSuffix,
  hasDraft,
  isDraftAnnotated: _isDraftAnnotated,
  proxifyToNoDraftsName,
  addColumnAlias
}
