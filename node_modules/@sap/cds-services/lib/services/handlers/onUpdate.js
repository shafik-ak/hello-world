const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const getColumns = require('../utils/columns')
const { getSelectCQN, checkNotNull } = require('../utils/handlerUtils')
const { resolveCqnIfView, getTargetData } = require('../utils/defaultHandlers')
const { unwrapComplexTypes } = require('../../util/dataProcessUtils')
const cds = require('../../cds')
const generateUUID = require('@sap/cds-foss')('uuid/v4')

const _getInsertCQN = context => {
  const { target, data } = getTargetData(context.target, Object.assign({}, context.data))

  return context.statements.INSERT.into(target).entries([data])
}

const _insertMissingUpsert = async context => {
  if (checkNotNull(context)) {
    return
  }

  await context.run(_getInsertCQN(context))

  return { ...context.data }
}

const _containsChanges = context => {
  return Object.keys(context.data).length > 1
}

const _rejectIfUpsertForbidden = context => {
  if (cds.env && cds.env.runtime && cds.env.runtime.allow_upsert === false) {
    return context.reject(404)
  }
}

const _getETag = context => {
  if (context._.odataReq && context._.odataReq.getConcurrentResource() !== null) {
    return Object.values(context.target.elements).find(element => {
      return element['@odata.etag']
    }).name
  }

  return undefined
}

const _fillETagUpsert = (context, etag) => {
  if (etag) {
    context.data[etag] = generateUUID()
    if (context._.odataReq.isConditional()) {
      context._.odataReq.validateEtag(context.data[etag])
    }
  }
}

const _fillETagUpdate = (context, result, etag) => {
  if (etag) {
    if (context._.odataReq.isConditional()) {
      context._.odataReq.validateEtag(result[etag])
    }
    context.data[etag] = generateUUID()
    context.query.UPDATE.data[etag] = context.data[etag]
  }
}

/**
 * Generic Handler for UPDATE requests.
 * In case of success it returns the updated entry.
 * If the entry to be updated does not exist, a new entry is created.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onUpdate
 */
const onUpdate = () => async context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return context.data
  }

  const partialPersistentState = context && context._ && context._.partialPersistentState
  const neededColumns = getColumns(context.target, true)

  let result

  let etag = _getETag(context)

  if (partialPersistentState) {
    result = partialPersistentState
  } else {
    const checkExistCQN = getSelectCQN(context, neededColumns)
    result = checkExistCQN ? await context.run(checkExistCQN) : []
  }

  // No key information given, or entry is not available -> create a new one
  if (result.length === 0) {
    _rejectIfUpsertForbidden(context)
    _fillETagUpsert(context, etag)
    return _insertMissingUpsert(context)
  }

  _fillETagUpdate(context, result[0], etag)

  // Store for auditing
  context._oldData = result[0]
  // reject with error if query update fails (not authenticated)
  if (_containsChanges(context) && (await context.run(resolveCqnIfView(context))) === 0) {
    context.reject(403)
    return
  }

  const response = Object.assign({}, result[0], unwrapComplexTypes(context.target, context.data))
  for (const key in response) {
    if (!neededColumns.includes(key)) {
      delete response[key]
    }
  }
  return response
}

module.exports = onUpdate
