const generateUUID = require('@sap/cds-foss')('uuid/v4')
const { getDraftCompositionTree } = require('../utils/compositionTree')
const getColumns = require('../utils/columns')
const {
  getServiceNamespace,
  getEntityName,
  getDraftName,
  getSubCQNs,
  setStatusCodeAndHeader,
  ensureNoDraftsSuffix,
  ensureDraftsSuffix
} = require('../utils/draftUtils')
const { isActiveEntityRequested, getKeyData } = require('../utils/draftWhereUtils')

const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')

const _getDraftColumns = draftUUID => ({
  IsActiveEntity: false,
  HasDraftEntity: false,
  HasActiveEntity: true,
  DraftAdministrativeData_DraftUUID: draftUUID
})

const _getAdminData = ({ user }, draftUUID, time) => {
  const currentUser = user.id || null
  return {
    DraftUUID: draftUUID,
    CreationDateTime: time,
    CreatedByUser: currentUser,
    LastChangeDateTime: time,
    LastChangedByUser: currentUser,
    DraftIsCreatedByMe: true,
    DraftIsProcessedByMe: true,
    InProcessByUser: currentUser
  }
}

const _getInsertAdminDataCQN = ({ statements: { INSERT }, user }, draftUUID, time) => {
  return INSERT.into('DRAFT.DraftAdministrativeData').entries(_getAdminData({ user }, draftUUID, time))
}

/**
 * Generic Handler for draftEdit requests.
 * In case of success it returns the root draft entry.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDraftEdit
 */
const onDraftEdit = ({ model: { definitions } = {} } = {}) => context => {
  if (!isActiveEntityRequested(context.query.SELECT.where || [])) {
    context.reject(400)
    return
  }

  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    context.reject(404)
    return
  }

  // TODO replace with generic where filter
  const keys = Object.keys(context.target.keys).filter(key => key !== 'IsActiveEntity')
  const data = getKeyData(keys, context.query.SELECT.where)
  const rootWhere = keys.reduce((res, key) => {
    res[key] = data[key]
    return res
  }, {})

  const rootCQN = context.statements.SELECT.from(context.target, getColumns(context.target, true)).where(rootWhere)

  const subCQNs = getSubCQNs({
    definitions,
    context,
    rootCQN,
    compositionTree: getDraftCompositionTree(definitions, ensureNoDraftsSuffix(context.target.name))
  })

  const selectCQNs = [rootCQN, ...subCQNs.map(obj => obj.cqn)]

  return Promise.all(selectCQNs.map(CQN => context.run(CQN))).then(results => {
    if (!results[0].length) {
      context.reject(404)
      return
    }

    const serviceNamespace = getServiceNamespace(ensureNoDraftsSuffix(context.target.name))
    const entityName = getEntityName(ensureNoDraftsSuffix(context.target.name))
    const rootDraftName = ensureDraftsSuffix(context.target.name)

    return context.run(context.statements.SELECT.from(rootDraftName, [1]).where(rootWhere)).then(drafts => {
      if (drafts.length) {
        context.reject(409)
        return
      }

      const time = new Date(Date.now()).toISOString()
      const draftUUID = generateUUID()
      const insertCQNs = [_getInsertAdminDataCQN(context, draftUUID, time)]

      for (const resultIndex in results) {
        if (results[resultIndex].length === 0) continue
        const draftEntity = getDraftName(serviceNamespace, getEntityName(selectCQNs[resultIndex].SELECT.from.ref[0]))
        const entries = results[resultIndex].map(entityResult =>
          Object.assign({}, entityResult, _getDraftColumns(draftUUID))
        )

        insertCQNs.push(context.statements.INSERT.into(draftEntity).entries(entries))
      }

      return Promise.all(insertCQNs.map(CQN => context.run(CQN))).then(() => {
        setStatusCodeAndHeader(context._.odataRes, rootWhere, entityName, false)

        return Object.assign({}, results[0][0], {
          HasDraftEntity: false,
          HasActiveEntity: true,
          IsActiveEntity: false
        })
      })
    })
  })
}

module.exports = onDraftEdit
