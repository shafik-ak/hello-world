const Service = require('./Service')

let _primary

const sessionInstanceError = () => {
  return new Error('Not connected to a db session')
}

/**
 * Create a singleton session instance to a database.
 * @param {String} [datasource] - name of datasource
 * @param {Object} [options] - Kind, connect and pool options.
 * @param {string|function} [options.kind] - Reference to a client facade or dependency injection of a custom one.
 * @param {string} [options.url] - Connect options in url format.
 * @param {Object} [options.pool] - The min and max pool options.
 * @param {number} [options.pool.min] - The minimum number of db connection clients.
 * @param {number} [options.pool.max] - The maximum number of db connection clients.
 * @param {number} [options.pool.evictionRunIntervalMillisForPools] - The time interval in ms until an idle pool is
 * evicted.
 * Default 60000 ms (1 min).
 * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
 * clients in a pool.
 * Default 10000 ms (10 s).
 * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
 * Defaults to half of options.pool.min, but at least 2.
 * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
 * options.pool.min.
 * Default 30000 ms (30 s).
 * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
 * client and creates a new one to meet options.pool.min.
 * Default 480000 ms (8 min).
 * @param {Object} [options.credentials] - Information how to connect to data source.
 * @param {Boolean} [primary] - If this connection is primary.
 * @returns {PromiseLike} resolves if session creation was successful, rejects if not
 */
const connect = (datasource, options, primary = false) => {
  if (primary && _primary) {
    return _primary.session
  }

  const session = new Service(datasource, options)

  if (primary) {
    _primary = {
      datasource,
      session
    }
  }

  return session
}

/**
 * Acquires a db client from the session.
 * @param {Object} [context] - Context object
 * @param {string} [context.user.id] - The user name for the db connection.
 * @param {string} [context.user.locale] - The language identifier.
 * @param {string} [context.attr.token] - Full JWT from (HTTP) request.
 * @param {string} [context.attr.identityZone] - GUID of a tenant.
 * @returns {Promise} resolves if client was acquired successfully, rejects with error if not
 * @alias module:singleton.acquire
 */
const acquire = context => {
  if (_primary) {
    return _primary.session.acquire(context)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Releases a db client to be reused by the session.
 * @param {Client} client - The client that should be released
 * @returns {Promise} resolves if client was released successfully, rejects with error if not
 * @alias module:singleton.release
 */
const release = client => {
  if (_primary) {
    return _primary.session.release(client)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Destroy a db client to be recreated by the session.
 * @param {Client} client - The client that should be destroyed
 * @returns {Promise} resolves if client was destroyed successfully, rejects with error if not
 * @alias module:singleton.release
 */
const destroy = client => {
  if (_primary) {
    return _primary.session.destroy(client)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Disconnects and deletes the session instance.
 * @param {string} [tenantId] - GUID of a tenant.
 * @returns {Promise} resolves without a parameter if disconnected successfully, rejects with error if not.
 * @alias module:singleton.disconnect
 */
const disconnect = tenantId => {
  if (_primary) {
    return _primary.session.disconnect(tenantId).then(() => {
      if (!tenantId) {
        _primary = null
      }
    })
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Checks if a session instance is available
 * @returns {boolean} true if session is available
 */
const hasSession = () => {
  return Boolean(_primary)
}

/**
 * Execute CQN or SQL outside of the odata package.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
 *
 */
const run = (query, values) => {
  if (_primary) {
    return _primary.session.run(query, values)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Executes the statement and processes the result set one by one.
 * Should be used if huge result sets are expected to process it in a streaming-like fashion
 * instead of materializing the full set in memory before.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @param {function} cb - synchronous function to process each row of the result set.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const foreach = (query, values, cb) => {
  if (_primary) {
    return _primary.session.foreach(query, values, cb)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * Drops all tables/views and creates them again
 * @param {object} csn the unreflected CSN.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const deploy = csn => {
  if (_primary) {
    return _primary.session.deploy(csn)
  }

  return Promise.reject(sessionInstanceError())
}

/**
 * @module singleton
 */
module.exports = {
  acquire,
  connect,
  destroy,
  disconnect,
  hasSession,
  release,
  run,
  foreach,
  deploy
}
