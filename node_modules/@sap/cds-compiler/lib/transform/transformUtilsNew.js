'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.
// The sibling of model/tranform/TransformUtil.js whixh works with compacted new CSN.

const alerts = require('../base/alerts');
const { hasErrors } = require('../base/messages');
const { setProp } = require('../base/model');
// eslint-disable-next-line no-unused-vars
const { copyAnnotations, printableName, hasBoolAnnotation, forEachDefinition } = require('../model/modelUtils');
const { dfilter } = require('./udict');
const { cloneCsn, forEachRef, getUtils } = require('../model/csnUtils');

// Return the public functions of this module, with 'model' captured in a closure (for definitions, options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
// 'model' is compacted new style CSN
// TODO: Error and warnings handling with compacted CSN? - currently just throw new Error for everything
// TODO: check the situation with assocs with values. In compacted CSN such elements have only "@Core.Computed": true
function getTransformers(model, pathDelimiter = '_') {
  const { error, warning, signal } = alerts(model);
  const {
    getCsnDef,
    getFinalBaseType,
    hasBoolAnnotation,
    inspectRef,
    isStructured,
    isBuiltinType
  } = getUtils(model);

  return {
    addDefaultTypeFacets,
    flattenForeignKeys,
    createForeignKeyElement,
    checkForeignKeys,
    flattenStructuredElement,
    flattenOnCond,
    flattenStructStepsInRef,
    checkExposedAssoc,
    toFinalBaseType,
    copyTypeProperties,
    isAssociationOperand,
    isDollarSelfOperand,
    getFinalBaseType,
    createExposingProjection,
    createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    createForeignKey,
    addForeignKey,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
    extractValidFromToKeyElement,
    checkMultipleAssignments,
    checkAssignment,
    recurseElements,
  };

  // Try to apply length, precision, scale from options if no type facet is set on the primitive types 'cds.String' or 'cds.Decimal'.
  // If 'obj' has primitive type 'cds.String' and no length try to apply length from options if available or set to default 5000.
  // if 'obj' has primitive type 'cds.Decimal' try to apply precision, scale from options if available.
  function addDefaultTypeFacets(element) {
    if (!element || !element.type)
      return;

    if (element.type === 'cds.String' && element.length === undefined) {
      element.length = model.options && model.options.length ? model.options.length : 5000;
      if (!(model.options && model.options.length))
        setProp(element, "$default", true);
    }
    if (element.type === 'cds.Decimal' && element.precision === undefined && model.options.precision) {
      element.precision = model.options.precision;
    }
    if (element.type === 'cds.Decimal' && element.scale === undefined && model.options.scale) {
      element.scale = model.options.scale;
    }
  }


  // For an array `keys` of foreign key infos, return an array in flattened form
  // in one of the two cases:
  // (1) replace all foreign keys that are managed associations themselves by
  // their respective foreign keys, recursively, with names flattened using 
  // pathDelimiter between path components.
  // (2) replace all foreign keys that are structured with their respective flattened form.
  //
  // Note: must be done after struct flattening(flattenStructuredElement method),
  // otherwise we might encounter already generated foreign key fields in types
  // we have already processed.
  function flattenForeignKeys(assoc, flattenedKeyArts, callbackForUnflattenedArts) {
    let fkSeparator = pathDelimiter;

    let targetArt = getCsnDef(assoc.target);
    if (callbackForUnflattenedArts && !(assoc.target in flattenedKeyArts)) {
      callbackForUnflattenedArts(targetArt, assoc.target, flattenedKeyArts);
    }

    // get all the elements from the target that have 'key' identifier
    let targetKeys = dfilter(targetArt.elements, elem => elem.key === true);
    // in case we have explicitly defined FKs
    Object.assign(targetKeys, dfilter(targetArt.elements, (elem, elemName) => {
      if (elem._flatElementNameWithDots) {
        // this is flattened elem -> keys still not flattened, have to check if starts with key ref
        // FIXME: review why join('.')? what about join(fkSeparator)?
        return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => elemName.startsWith(`${keyDotName}${fkSeparator}`));
      } else {
        // exact match of the name
        return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => keyDotName === elemName);
      }
    }));

    let result = [];

    // this iteration assumes the elements in the tartgetArtifact are flattened
    for (let key of assoc.keys) {

      let fKeyName = key.ref.join(fkSeparator);

      // The key is an association - (1)
      if (Object.keys(targetKeys).includes(fKeyName) && targetKeys[fKeyName].type
        && targetKeys[fKeyName].type === 'cds.Association' && targetKeys[fKeyName].target
      ) {
        // as there is no assurance that the target of the target has flattened keys already
        // has to go through both of the associations
        getCsnDef(targetKeys[fKeyName].target); // sanity check if the definition exists
        targetKeys[fKeyName].keys.forEach(k => result.push({ ref: [`${fKeyName}${fkSeparator}${k.ref.join(fkSeparator)}`] }));
        continue;
      }

      // collect potential flattened keys, which are the counterpart of the current key
      let flattenedKeys = [];
      for (let keyName in targetKeys) {
        if (targetKeys[keyName].viaTransform && keyName.startsWith(`${fKeyName}${fkSeparator}`))
          flattenedKeys.push(keyName);
      }

      // The keys is structured element (2)
      if (flattenedKeys.length) {
        flattenedKeys.forEach(k => result.push({ ref: [k], as: k }));
      } else {
        // Otherwise simply take as it is
        result.push(key);
      }
    }

    assoc.keys = result;
  }

  // (1) Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots) in 'artifact', using foreign key info
  // from 'foreignKey'.
  // (2) Inserting it into 'elements' of 'artifact'.
  // (3) Add a property '$generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  //
  // Note that this must happen after struct flattening(flattenStructuredElement) - both fot elements and foreign keys.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, assocName, foreignKey, artifact, artifactName, path) {
    let fkSeparator = pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    // let foreignKeyElementName = assocName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.ref.join(pathDelimiter);
    let foreignKeyElementName = `${assocName.replace(/\./g, pathDelimiter)}${fkSeparator}${foreignKey.as || foreignKey.ref.join(pathDelimiter)}`;

    // Assemble artificial foreign key element
    let assocTargetDef = getCsnDef(assoc.target);

    let fkArtifact;

    if (!path) {
      fkArtifact = assocTargetDef.elements[foreignKey.ref.join(pathDelimiter)]; // foreignKey.as ???
    } else {
      const { art } = inspectRef(path);
      fkArtifact = art;
    }

    // In case of compiler errors the foreign key might be missing
    if (!fkArtifact && hasErrors((model.options && model.options.messages) || model.messages)) {
      return null;
    }

    let foreignKeyElement = Object.create(null);

    // Transfer selected type properties from target key element
    // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
    for (let prop of ['type', 'length', 'scale', 'precision', 'srid', 'default', '@odata.Type']) {
      if (fkArtifact[prop] != undefined) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }

    if (model.options && !model.options.forHana)
      copyAnnotations(assoc, foreignKeyElement, true);

    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop] != undefined) {
        foreignKeyElement[prop] = assoc[prop];
      }
    }

    // TODO: check with values. In CSN such elements have only "@Core.Computed": true
    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    // if (assoc.value) {
    //   // TODO: previously, the code directly accessed assoc.value.element, probably set by forHana
    //   let elemName = assoc.value.element || (assoc.value._artifact ? assoc.value._artifact.name.element : '');
    //   let valueForeignKeyElementName = elemName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
    //   // For the foreign key element, take the same path as for the assoc, just without the last step
    //   let valueForeignKeyElementPath = [];
    //   if (assoc.value.path) {
    //     valueForeignKeyElementPath = cloneWithTransformations(assoc.value.path, {}, true).slice(0, -1);
    //   }
    //   valueForeignKeyElementPath.push({ id: valueForeignKeyElementName });
    //   foreignKeyElement.value = {
    //     path: valueForeignKeyElementPath,
    //     // TODO: keep the following, needed by toSql ?
    //     absolute: assoc.value.absolute || assoc.value._artifact && assoc.value._artifact.name.absolute,
    //     element: valueForeignKeyElementName,
    //     viaTransform: true, // FIXME: Do we still need this?
    //   }
    //   // FIXME: Remove once the compactor no longer renders 'origin'
    //   if (assoc.origin) {
    //     foreignKeyElement.origin = foreignKeyElement.value;
    //   }
    //   // The foreign key element name is calculated if the assoc hasn't been renamed
    //   if (assoc.name.element == assoc.value.element) {
    //     foreignKeyElement.name.calculated = true;
    //   }
    // }

    // Insert artificial element into artifact, with all cross-links (must not exist already)
    if (artifact.elements[foreignKeyElementName]) {
      signal(error`Generated foreign key element "${foreignKeyElementName}" for association "${assocName}" conflicts with existing element`, ['definitions', artifactName, 'elements', foreignKeyElementName]);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;

    // Establish the relationship between generated field and association:
    // - generated field has annotation '@odata.foreignKey4'.
    // - foreign key info has 'generatedFieldName'
    foreignKeyElement['@odata.foreignKey4'] = assocName;
    foreignKey.$generatedFieldName = foreignKeyElementName;
    return { [foreignKeyElementName]: foreignKeyElement };
  }

  // For an association 'assoc', check that all foreign keys (if any) actually exist in the
  // target. Must only be applied after flattening structured foreign keys.
  // Note that this may also be called for unmanaged associations with artificially created
  // ON-conditions, because these still retain their foreign key info.
  // FIXME: For all cases except implicit redirection, this should actually be done by the compiler
  function checkForeignKeys(assoc, assocName, artifactName, options) {
    // FIXME: Because this assumes flattening, it does not work with 'hdbcds' naming mode. Because
    // it will become obsolete soon anyway (compiler checking and rewriting ON-conditions), we
    // don't bother to adapt it.
    if (options && options.forHana && options.forHana.keepStructsAssocs) {
      return;
    }

    for (let name in assoc.keys) {
      let foreignKey = assoc.keys[name];
      let target = model.definitions[assoc.target];
      // Sanity checks
      if (foreignKey.ref.length > 1) {
        throw Error('Expecting foreign key ' + foreignKey.$generatedFieldName + ' to be flattened');
      }
      if (!target) {
        throw Error('Expecting target of association ' + assocName + ' to be resolved');
      }
      if (!target.elements || Object.keys(target.elements).length == 0) {
        throw Error('Expecting target of association ' + assocName + ' to have elements');
      }
      // Try to "resolve" the corresponding element
      let targetElementName = foreignKey.ref[0];
      if (target.elements[targetElementName] == undefined) {
        signal(error`Foreign key "${targetElementName}" not found in target "${assoc.target}" of association "${artifactName}.${assocName}"`, ['definitions', artifactName, 'elements', assocName]);
      }
    }
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with pathDelimiter's value and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  // example input:
  //  { elem: {
  //          key: true,
  //          @foo: true,
  //          elements: 
  //            { a: { type: 'cds.Integer' } },
  //            { b: { 
  //                 elements:
  //                   { b1: type: 'cds.String', length: 42 } } },
  //  } }
  //
  // result:
  //  { elem_a: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.Integer' },
  //    elem_b_b1: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.String',
  //          length: 42 }, 
  // }
  function flattenStructuredElement(elem, elemName, ipath=[]) {
    let path=ipath.concat(elemName)
    // in case the element is of user defined type => take the definition of the type
    // for type of 'x' -> elem.type is an object, not a string -> use directly
    let elemType;
    if(!elem.elements) // structures does not have final base type
      elemType = getFinalBaseType(elem.type);

    // if no elements => check if the element is of user defined structured type
    if (!elem.elements && elem.type && !isBuiltinType(elem.type)) {
      if (!elemType)
        signal(error`Nonexisting type definition: '${elem.type}'`);
      if (!elemType.elements)
        signal(error`Expecting element '${elemName}' to be a structured element`);
    }

    let struct = elemType ? elemType.elements : elem.elements;

    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in struct) {
      let childElem = struct[childName];
      if (isStructured(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem, childName, path);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elemName + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // TODO: check with values. In CSN such elements have only "@Core.Computed": true
          // If the original element had a value, construct one for the flattened element
          // if (elem.value) {
          //   createFlattenedValue(flatElem, flatElemName, grandChildName);
          // }
          // Preserve the generated element name as it would have been with 'hdbcds' names
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elemName + pathDelimiter + childName;
        let flatElem = cloneCsn(childElem);
        flatElem.viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        setProp(flatElem, '_flatElementNameWithDots', path.concat(childName).join("."));
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      let flatElem = result[name];
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;
  }

  // Return a copy of 'ref' where all path steps resulting from struct traversal are
  // fused together into one step, using '_' (so that the path fits again for flattened
  // structs), e.g.
  //   [ (Entity), (struct1), (struct2), (assoc), (elem) ] should result in
  //   [ (Entity), (struct1_struct2_assoc), (elem) ]
  // 'path' is the csn path to the ref
  function flattenStructStepsInRef(ref, path) {
    // Refs of length 1 cannot contain steps - no need to check
    if (ref.length < 2) {
      return ref;
    }

    try {
      return flatten(ref, path);
    } catch (e) {
      if (e.message && e.message == "Scope 'ref-where' but no entity was provided.") {
        const main = path.slice(0, path.lastIndexOf("ref"));

        const { links } = inspectRef(main);
        const whereEntity = links[path[path.lastIndexOf("ref") + 1]].art;

        return flatten(ref, path, whereEntity.target ? getCsnDef(whereEntity.target) : whereEntity);
      } else {
        throw e;
      }
    }

    function flatten(ref, path, whereEntity) {
      let result = [];
      //let stack = []; // IDs of path steps not yet processed or part of a struct traversal
      const { links, scope } = inspectRef(path, whereEntity);
      if (scope === "$magic")
        return ref;
      let flattenStep = false;
      links.forEach((value, idx) => {
        if (flattenStep)
          result[result.length - 1] += pathDelimiter + ref[idx];
        else {
          result.push(ref[idx]);
        }
        flattenStep = value.art && !(value.art.kind === 'entity') && !value.art.SELECT && (value.art._effectiveType && value.art._effectiveType.elements || value.art.elements);
      });
      // If the path starts with '$self', this is now redundant (because of flattening) and can be omitted,
      // making life easier for consumers
      if (result[0] == '$self' && result.length > 1) {
        result = result.slice(1);
      }
      return result;
    }
  }

  // Flatten on conditions of unmanaged associations. This method assumes that 
  // other flattening of the elements was already performed and there are 
  // no left over structure elements marked with some ignore flag. Also, uses
  // the non-enumerable property '_flatElementNameWithDots'.
  function flattenOnCond(assoc, assocName, defElements, defName) {

    if (!assoc.on) return; // nothing to do

    forEachRef(assoc, (ref, node, path) => {
      // assoc itself is inside a struct -> all the first refs need to be flattened;
      if (assoc.viaTransform) {
        // when the first ref id is the same association
        if (assoc._flatElementNameWithDots.endsWith(`.${ref[0]}`))
          ref.splice(0, 1, assocName);
        // elem from the curr name resolution scope
        // but not a $self, will deal with this one later
        else if (ref[0] !== '$self') {
          // .splice(-1, 1, ref[0]) does not work here, why???
          let currStructFlatName = `${assoc._flatElementNameWithDots.split('.').slice(0, -1).join('_')}`
          node.ref.splice(0, 1, `${currStructFlatName}_${ref[0]}`);
        }
      }

      let flatRef = [];
      let needToFlat = false;
      
      // $user.locale must not be flatten and they are not understand by inspectRef
      if (ref.join('.') === '$user.locale')
        return;

      ref.slice().forEach(refId => {
        if (needToFlat) {
          let flatLastElem = `${flatRef[flatRef.length - 1]}${pathDelimiter}${refId}`;
          flatRef.splice(-1, 1, flatLastElem);
          needToFlat = false;
        } else
          flatRef.push(refId);

        node.ref = flatRef;
        let { art } = inspectRef(path);

        // if not resolved to an art, then this element was flattened
        if (!art)
          needToFlat = true;
      });

      // remove leading $self when at the begining of a ref
      if (ref.length > 1 && ref[0] === '$self')
        node.ref.splice(0, 1);
    }, ['definitions', defName, 'elements', assocName]);
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artName, assocDef, assocName, service) {
    let assocTargetDef = getCsnDef(assocDef.target);
    if (!assocDef._ignore && assocDef.target && assocTargetDef && !assocDef.target.startsWith(service)) {
      // If we have a 'preserved dotted name' ->  a result of flattening -> This scenario is not supported yet
      if (assocDef._flatElementNameWithDots)
        signal(error`Redirection for sub elements not supported yet - association "${artName}.${assocName}"`);
    }
  }

  /**
   * Copy properties of the referenced type, but don't resolve to the final base type.
   * 
   * @param {any} node Node to copy to
   * @returns {undefined}
   */
  function copyTypeProperties(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // ..  or if it is a ref
    if (node.type && node.type.ref) return;
    // ..  or builtin already
    if (node.type && typeof node.type === 'string' && node.type.startsWith('cds.') && !node.type.startsWith('cds.foundation.')) return;

    // The type might already be a full fledged type def (array of)
    const typeDef = typeof node.type === 'string' ? getCsnDef(node.type) : node.type;
    // Nothing to do if type is an array or a struct type
    if (typeDef.items || typeDef.elements) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    if (!node.length && typeDef.length && !typeDef.$default)
      Object.assign(node, { length: typeDef.length });
    if (!node.precision && typeDef.precision)
      Object.assign(node, { precision: typeDef.precision });
    if (!node.scale && typeDef.scale)
      Object.assign(node, { scale: typeDef.scale });
    if (!node.srid && typeDef.srid)
      Object.assign(node, { srid: typeDef.srid });
  }

  // Replace the type of 'node' with its final base type (in contrast to the compiler,
  // also unravel derived enum types, i.e. take the final base type of the enum's base type.
  // Similar with associations and compositions (we probably need a _baseType link)
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // In case of a ref -> Follow the ref
    if (node.type && node.type.ref) {
      node.type = getFinalBaseType(node.type);
      return;
    }
    // ..  or builtin already
    if (node.type && typeof node.type === 'string' && node.type.startsWith('cds.') && !node.type.startsWith('cds.foundation.')) return;

    // The type might already be a full fledged type def (array of)
    let typeDef = typeof node.type === 'string' ? getCsnDef(node.type) : node.type;
    // Nothing to do if type is an array or a struct type
    if (typeDef.items || typeDef.elements) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    if (!node.length && typeDef.length)
      Object.assign(node, { length: typeDef.length });
    if (!node.precision && typeDef.precision)
      Object.assign(node, { precision: typeDef.precision });
    if (!node.scale && typeDef.scale)
      Object.assign(node, { scale: typeDef.scale });
    if (!node.srid && typeDef.srid)
      Object.assign(node, { srid: typeDef.srid });
    node.type = typeDef.type;
    toFinalBaseType(node);
  }

  // Return a full projection 'projectionId' of artifact 'art' for exposure in 'service'.
  // Add the created projection to the model and complain if artifact already exists.
  // Used by Draft generation
  function createExposingProjection(art, artName, projectionId, service) {
    let projectionAbsoluteName = `${service}.${projectionId}`;
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = model.definitions[projectionAbsoluteName];
    if (existingProjection) {
      signal(error`Cannot generate projection "${projectionAbsoluteName}" because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`);
      return null;
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      // Transfer xrefs, that are redirected to the projection
      // TODO: shall we remove the transfered elements from the original?
      // if (artElem._xref) {
      //   setProp(elem, '_xref', artElem._xref.filter(xref => xref.user && xref.user._main && xref.user._main._service == service));
      // }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elements[elemName] = elem;
    }
    let query = {
      'SELECT': {
        'from': {
          'ref': [
            artName
          ]
        }
      }
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      'kind': 'entity',
      query,
      elements,
      //'$syntax': 'projection'
    };
    // copy annotations from art to projection
    for (let a of Object.keys(art).filter(x => x.startsWith('@'))) {
      projection[a] = art[a];
    }
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    return projection;
  }

  // Create a 'DraftAdministrativeData' projection on entity 'DRAFT.DraftAdministrativeData'
  // in service 'service' and add it to the model.
  function createAndAddDraftAdminDataProjection(service) {
    // Make sure we have a DRAFT.DraftAdministrativeData entity
    let draftAdminDataEntity = model.definitions['DRAFT.DraftAdministrativeData'];
    if (!draftAdminDataEntity) {
      draftAdminDataEntity = createAndAddDraftAdminDataEntity();
      model.definitions['DRAFT.DraftAdministrativeData'] = draftAdminDataEntity;
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataEntity.kind != 'entity' || !draftAdminDataEntity.elements['DraftUUID']) {
      signal(error`Generated entity "DRAFT.DraftAdministrativeData" conflicts with existing artifact`, ['definitions', 'DRAFT.DraftAdministrativeData']);
    }

    // Create a projection within this service
    return createExposingProjection(draftAdminDataEntity, 'DRAFT.DraftAdministrativeData', 'DraftAdministrativeData', service);

    // Create the 'DRAFT.DraftAdministrativeData' entity (unless it already exist)
    // Return the 'DRAFT.DraftAdministrativeData' entity.
    function createAndAddDraftAdminDataEntity() {
      // Create the 'DRAFT.DraftAdministrativeData' entity
      let artifact = {
        kind: 'entity',
        elements: Object.create(null),
      }

      // key DraftUUID : UUID
      let draftUuid = createScalarElement('DraftUUID', 'cds.UUID', true);
      addElement(draftUuid, artifact);

      // CreationDateTime : Timestamp;
      let creationDateTime = createScalarElement('CreationDateTime', 'cds.Timestamp');
      addElement(creationDateTime, artifact);

      // CreatedByUser : String(256);
      let createdByUser = createScalarElement('CreatedByUser', 'cds.String');
      createdByUser['CreatedByUser'].length = 256;
      addElement(createdByUser, artifact);

      // DraftIsCreatedByMe : Boolean;
      let draftIsCreatedByMe = createScalarElement('DraftIsCreatedByMe', 'cds.Boolean');
      addElement(draftIsCreatedByMe, artifact);

      // LastChangeDateTime : Timestamp;
      let lastChangeDateTime = createScalarElement('LastChangeDateTime', 'cds.Timestamp');
      addElement(lastChangeDateTime, artifact);

      // LastChangedByUser : String(256);
      let lastChangedByUser = createScalarElement('LastChangedByUser', 'cds.String');
      lastChangedByUser['LastChangedByUser'].length = 256;
      addElement(lastChangedByUser, artifact);

      // InProcessByUser : String(256);
      let inProcessByUser = createScalarElement('InProcessByUser', 'cds.String');
      inProcessByUser['InProcessByUser'].length = 256;
      addElement(inProcessByUser, artifact);

      // DraftIsProcessedByMe : Boolean;
      let draftIsProcessedByMe = createScalarElement('DraftIsProcessedByMe', 'cds.Boolean');
      addElement(draftIsProcessedByMe, artifact);

      return artifact;
    }
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  // example result: { foo: { type: 'cds.Integer', key: true, default: { val: 6 } } }
  //                   ^^^            ^^^^^^^^^       ^^^^                   ^^
  //                 elemName         typeName        isKey               defaultVal   
  function createScalarElement(elemName, typeName, isKey = false, defaultVal = undefined) {
    if (!isBuiltinType(typeName) && !model.definitions[typeName]) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let result = {
      [elemName]: {
        type: typeName
      }
    };
    if (isKey) {
      result[elemName].key = true
    }
    if (defaultVal !== undefined) {
      result[elemName].default = {
        val: defaultVal,
      }
    }
    return result;
  }

  // Return true if 'arg' is an expression argument denoting "$self"
  function isDollarSelfOperand(arg) {
    return arg.ref && arg.ref.length == 1 && (arg.ref[0] == '$self');
  }

  // Return true if 'arg' is an expression argument of type association or composition
  function isAssociationOperand(arg, path) {
    if (!arg.ref) {
      // Not a path, hence not an association (literal, expression, function, whatever ...)
      return false;
    }
    const { art } = inspectRef(path);
    // If it has a target, it is an association or composition
    return art.target !== undefined;
  }

  // Create an artificial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  // e.g. result:
  // { toFoo: {
  //     type: 'cds.Association', target: 'Foo',
  //     keys: [{ ref: ['id'] }]
  // } }
  function createAssociationElement(elemName, target, isManaged = false) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    let assoc = elem[elemName];
    assoc.target = target;

    if (isManaged) {
      assoc.keys = [];
      let targetArt = getCsnDef(target);
      for (let keyElemName in targetArt.elements) {
        let keyElem = targetArt.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = createForeignKey(keyElemName, keyElem);
        addForeignKey(foreignKey, assoc);
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  // return an array to be spread in an on-condition
  // e.g. [ { ref: ['SiblingEntity','ID'] }, '=', { ref: ['ID'] } ]
  //                 ^^^^^          ^^^      ^^           ^^^
  //                 assoc      foreignElem  op           elem
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    return [
      { ref: [assoc, foreignElem] }, op, { ref: [elem] }
    ]
  }

  // Create an artificial foreign key 'keyElemName' for key element 'keyElem'. Note that this
  // only creates a foreign key, not the generated foreign key element.
  // TODO: check the usage of this function's param 'keyElem' ?
  function createForeignKey(keyElemName/*,  keyElem */) {
    return {
      ref: [keyElemName]
      // TODO: do we need these two?
      // calculated: true,
      // $inferred: 'keys',
    }
  }

  // Add foreign key 'foreignKey' to association element 'elem'.
  function addForeignKey(foreignKey, elem) {
    // Sanity checks
    if (!elem.target || !elem.keys) {
      throw new Error('Expecting managed association element with foreign keys');
    }

    // Foreign key must not exist
    if (elem.keys.some(key => JSON.stringify(foreignKey) === JSON.stringify(key))) {
      signal(error`Key already exists: ${JSON.stringify(foreignKey)}`);
      return;
    }

    // Add the foreign key
    elem.keys.push(foreignKey);
  }


  /**
   * Add element 'elem' to 'artifact'
   * 
   * @param {any} elem is in form: { b: { type: 'cds.String' } }
   * @param {any} artifact is: { kind: 'entity', elements: { a: { type: 'cds.Integer' } ... } } 
   * @returns {undefined}
   */
  function addElement(elem, artifact) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    let elemName = Object.keys(elem)[0];
    // Element must not exist
    if (artifact.elements[elemName]) {
      signal(error`"${elemName}": Element name conflicts with existing element`);
      return;
    }

    // Add the element
    Object.assign(artifact.elements, elem);
  }

  // Make a copy of element 'elem' (e.g. { elem: { type: 'cds.Integer' } })
  // and add it to 'artifact' under the new name 'elemName'.
  // ( e.g. { artifact: { elements: { elemName: { type: 'cds.Integer' } } })
  // Return the newly created element
  // (e.g. { elemName: { type: 'cds.Integer' } })
  function copyAndAddElement(elem, artifact, elemName) {
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elemName]) {
      signal(error`"${elemName}": Element name conflicts with existing element`);
    }

    let result = { [elemName]: {} };
    for (let prop in elem)
      result[elemName][prop] = elem[prop];
    Object.assign(artifact.elements, result);
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  function createAction(actionName, returnTypeName = undefined, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let result = {
      [actionName]: {
        kind: 'action'
      }
    };

    let action = result[actionName];

    if (returnTypeName) {
      if (!isBuiltinType(returnTypeName) && !model.definitions[returnTypeName])
        throw new Error('Expecting valid return type name: ' + returnTypeName);
      action.returns = { type: returnTypeName };
    }

    // Add parameter if provided
    if (paramName && paramTypeName) {
      if (!isBuiltinType(paramTypeName) && !model.definitions[paramTypeName])
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);

      action.params = Object.create(null);
      action.params[paramName] = {
        type: paramTypeName
      }
    }

    return result;
  }

  // Add action 'action' to 'artifact'
  // 'action' is in the form of:
  //  { myAction: { kind: 'action', returns ... } }
  //
  //  'artifact' is:
  //  { kind: 'entity', elements: ... }
  function addAction(action, artifact) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }

    let actionName = Object.keys(action)[0];
    // Element must not exist
    if (artifact.actions[actionName]) {
      signal(error`"${actionName}": Generated action name conflicts with existing action`);
      return;
    }

    // Add the action
    Object.assign(artifact.actions, action);
  }

  /**
   * If the element has annotation @cds.valid.from or @cds.valid.to, return it.
   * 
   * @param {any} element Element to check
   * @param {Array} path path in CSN for error messages
   * @returns {Array[]} Array of arrays, first filed has an array with the element if it has @cds.valid.from, second field if it has @cds.valid.to. Default value is [] for each field.
   */
  function extractValidFromToKeyElement(element, path) {
    let validFroms = [], validTos = [], validKeys = [];
    if (hasBoolAnnotation(element, '@cds.valid.from')) {
      validFroms.push({ element, path: [...path] });
    }
    if (hasBoolAnnotation(element, '@cds.valid.to')) {
      validTos.push({ element, path: [...path] });
    }
    if (hasBoolAnnotation(element, '@cds.valid.key')) {
      validKeys.push({ element, path: [...path] });
    }
    return [validFroms, validTos, validKeys];
  }

  /**
   * Check if the element can be annotated with the given annotation.
   * Only runs the check if:
   * - The artifact is not a type
   * - The artifact is not a view
   * 
   * Signals an error, if:
   * - The element is structured
   * - Has a target
   * - Has an element as _parent.kind
   * 
   * @param {any} annoName Annotation name
   * @param {any} elementName Name of the element to be checked
   * @param {any} artifact Artifact
   * @returns {Boolean} True if no errors
   */
  function checkAssignment(annoName, element, path, artifact) {
    if (artifact.kind !== 'type' && !artifact.query) {
      // path.length > 4 to check for structured elements
      if (element.elements || element.target || path.length > 4) {
        signal(error`Element cannot be annotated with "${annoName}"`, path);
        return false;
      }
    }
    return true;
  }

  /**
   * Signals an error/warning if an annotation has been assigned more than once
   * 
   * @param {any} array Array of elements that have the annotation
   * @param {any} annoName Name of the annotation
   * @param {any} artifact Root artifact containing the elements
   * @param {string} artifactName Name of the root artifact
   * @param {boolean} [err=true] Down-grade to a warning if set to false
   */
  function checkMultipleAssignments(array, annoName, artifact, artifactName, err = true) {
    if (array.length > 1) {
      if (err == true) {
        signal(error`"${annoName}" must be assigned only once`, ['definitions', artifactName]);
      } else {
        signal(warning`"${annoName}" must be assigned only once`, ['definitions', artifactName]);
      }
    }
  }

  /**
   * Calls `callback` for each element in `elements` property of `artifact` recursively.
   * 
   * @param artifact the artifact
   * @param path path to get to `artifact` (mainly used for error messages)
   * @param callback the callback to be called
   */
  function recurseElements(artifact, path, callback) {
    callback(artifact, path);
    let elements = artifact.elements;
    if (elements) {
      path.push('elements', null);
      for (let name in elements) {
        let obj = elements[name];
        path[path.length - 1] = name;
        recurseElements(obj, path, callback);
      }
      // reset path for subsequent usages
      path.length -= 2; // equivalent to 2x pop()
    }
  }
}


// A generic function that applies a number of (simple) transformations to a csn model
// by visiting each node. The transformer object has properties that are looked for in
// the node(s) and the corresponding functions are applied. The functions are called
// with the oldValue, the node and the property name as parameters
// E.g. { type: fctToMapType() } as a transformer would change each type node in the model
// by replacing the oldValue of type by fctToMapType(oldValue, node, 'type')
// The function is aware of dictionaries and would not call the transformer on an
// entity called 'type'
function transformModel(model, transformers) {

  return transformNode(model);

  // This general transformation function will be applied to each node recursively
  function transformNode(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
    if (node === null || typeof node !== 'object') {
      return;
    }
    // Simply return if node is to be ignored
    if (node == undefined || node._ignore)
      return;
    // Transform arrays element-wise
    if (node instanceof Array) {
      node.forEach(transformNode);
      return;
    }
    // Things not having 'proto' are dictionaries
    let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
    for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
      let transformer = (proto == undefined) ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
      (transformer || transformNode)(node[key], node, key);
    }
  }
}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
  transformModel
};
