// contains query relevant augmentor functions
let W = require("./walker");
let udict = require("../transform/udict");

// creates a new instance which export all functions
// U - utils instance
// P - parent instance - passes external functions for reuse

function createInstance(U,parent) {
  return {
    augmentQuery,
    augmentMixin,
    augmentExcluding,
    augmentLimit,
    augmentOrderBy,
    augmentQueryColumns,
    augmentXPR,
    augmentExpressionValue,
    augmentExpression,
    augmentExpressionItem,
    refAsPath,
    augmentLiteralValue,
    newValue,
    augmentNumber,
    augmentJoin,
    augmentQueryOptionalProps,
    augmentQuerySourceFrom
  }

  function augmentQuery(Q, path) {
    let location = U.newLocation(path, U.WILO_FULL)
    if(typeof Q !== "object" || Q===null)
      throw Error("Expects object as query");
    if(Q.SET !== undefined) {
      let SET = Q.SET;
      let setPath= path.concat("SET")
      if(SET.args.length>1) {
        let args = SET.args.map( (X,I) => {
          let R = augmentQuery(X, setPath.concat(["args",I]))
          return [R];
        })
        let val = SET.op;
        if(SET.all && val==="union")
          val = "unionAll";
        let R = {
          op: {val, location: U.newLocation(setPath.concat("op"), U.WILO_FULL)},
          location: U.newLocation(setPath, U.WILO_FULL),
          args
        };
        augmentQueryOptionalProps(SET, setPath, R);
        U.setAugmented(R)
        return [R];
      }
      Q=SET.args[0];
      path = path.concat(["SET","args","0"])
      let args = [augmentQuery(Q,path)]
      let R = {
        op: { val: "subquery", location},
        args,
        location
      }
      augmentQueryOptionalProps(SET, setPath, R);
      return [R]
    } // if SET
    if(Q.SELECT === undefined)
      throw Error("Missing SELECT in query")
    let selectPath = path.concat("SELECT");
    let fromPath = selectPath.concat("from");

    let newFrom = augmentQuerySourceFrom(Q, selectPath);
    let newColumns = augmentQueryColumns(Q.SELECT.columns, selectPath.concat("columns"));

    let from = Q.SELECT.from;

    let R = {
      op: {val:"query", location: U.newLocation(selectPath, U.WILO_FIRST)},
      location,
      from: newFrom
    };
    setOpt(R, "columns", newColumns)
    if(Q.as) { // query alias
      let location = U.newLocation(path.concat("as"), U.WILO_FULL)
      R.name = {id:Q.as, location}
    }
    if (from.as) {
      if(!Array.isArray(R.from)) {
        throw Error("Expected from to be an array")
      } else {
        R.from[0].name = {
          id:from.as,
          location: U.newLocation(fromPath.concat("as"), U.WILO_FULL)
        }
      }
    }

    // set optional properties
    augmentQueryOptionalProps(Q.SELECT, selectPath, R);

    let where = augmentXPR(Q.SELECT.where, selectPath.concat("where"))
    let groupBy = augmentGroupBy(Q.SELECT.groupBy, selectPath.concat("groupBy"))
    let having = augmentXPR(Q.SELECT.having, selectPath.concat("having"))
    let mixin = augmentMixin(Q.SELECT.mixin, selectPath);

    setOpt(R,"where", where)
    setOpt(R,"groupBy", groupBy)
    setOpt(R,"having", having)
    setOpt(R,"mixin", mixin)

    U.setAugmented(R)
    return R;
  } // function augmentQuery

  function setOpt(o,n,v) {
    if(v!==undefined)
      o[n] = v;
  }

  function augmentDistinct(distinct, path) {
    if(distinct) {
      return {
        val: "distinct",
        location: U.newLocation(path.concat("distinct"), U.WILO_FULL)
      }
    }
    return undefined;
  }

  function augmentAll(all, path) {
    if(all) {
      return {
        val: "all",
        location: U.newLocation(path.concat("all"), U.WILO_FULL)
      }
    }
    return undefined;
  }

  function augmentQueryOptionalProps(query,path,result) {
    let orderBy = augmentOrderBy(query.orderBy,path.concat("orderBy"))
    let {limit,offset} = augmentLimit(query.limit, path.concat("limit"));
    let excluding = augmentExcluding(query.excluding, path);
    let distinct = augmentDistinct(query.distinct, path);
    let all = augmentAll(query.all, path);
    if(distinct !== undefined && all !== undefined)
      throw Error("Expected either DISTINCT or ALL, but not both")

    setOpt(result, "orderBy", orderBy)
    setOpt(result, "limit", limit)
    setOpt(result, "offset", offset)
    setOpt(result, "exclude", excluding)
    setOpt(result, "quantifier", distinct)
    setOpt(result, "quantifier", all)
  }

  function augmentMixin(mixin, selectPath) {
    if(mixin===undefined)
      return undefined;
    Object.setPrototypeOf(mixin,null)
    parent.walkAndAugment(mixin, selectPath.concat("mixin"))
    return mixin;
  }

  function augmentGroupBy(groupBy, path) {
    if(groupBy===undefined)
      return undefined;
    return augmentExpression(groupBy, path);
  }

  function augmentExcluding(excluding, selectPath) {
    if(excluding === undefined)
      return undefined;
    let r = Object.create(null);
    excluding.forEach((X,iX) => {
      let location = U.newLocation(selectPath.concat("excluding",iX));
      r[X] = {
        name: {id:X,location},
        location
      }
    })
    return r;
  }

  function augmentLimit(limitOffset, limitPath) {
    let limit,offset;
    if(limitOffset !== undefined) {
      if(limitOffset.rows)
        limit = augmentNumber(limitOffset.rows.val, limitPath.concat("rows","val"), U.WILO_LAST);
      if(limitOffset.offset)
        offset = augmentNumber(limitOffset.offset.val, limitPath.concat("offset","val"), U.WILO_LAST);
    }
    let R={};
    setOpt(R,"limit",limit)
    setOpt(R,"offset",offset)
    return R;
  }

  function augmentOrderBy(orderBy, orderByPath) {
    if(orderBy === undefined)
      return undefined;
    orderBy = orderBy.map((X,iX) => {
      let sort;
      let nulls;
      if(X.sort) {
        sort = {
          val: X.sort,
          location: U.newLocation(orderByPath.concat(iX,"sort"), U.WILO_FULL)
        }
      }
      if(X.nulls) {
        nulls = {
          val: X.nulls,
          location: U.newLocation(orderByPath.concat(iX,"nulls"), U.WILO_FULL)
        }
      }
      let value;
      if(X.xpr) {
        value = augmentXPR(X.xpr, orderByPath.concat(iX,"xpr"));
      } else if(X.ref) {
        let ipath = orderByPath.concat(iX,"ref");
        value = {
          path: refAsPath(X.ref, ipath),
          location: U.newLocation(ipath, U.WILO_FULL)
        }
      } else if(X.val) {
        value = newValue(X.val, orderByPath.concat(iX,"val"));
      } else if(X.func) {
        value = augmentExpressionItem(X, iX, orderByPath);
      } else {
        throw Error("Unknown orderBy structure: " + JSON.stringify(X))
      }
      let r = {value};
      if(sort)
        r.sort = sort;
      if(nulls)
        r.nulls = nulls;
      return r;
    }) // orderBy map
    return orderBy;
  }

  function augmentViewArgs(args,path) {
    return udict.dmap(args, (obj,arg) => {
      if(obj.param === true)
        return {
          name: { id: arg, location: U.newLocation(path.concat(arg), U.WILO_FULL) },
          path: refAsPath(obj.ref, path.concat(arg,"ref")),
          scope: "param",
          location: U.newLocation(path.concat(arg), U.WILO_FULL)
        }
      return newValue(obj.val, path.concat(arg), arg);
    });
  }

  function augmentQueryColumns(columns, columnsPath) {
    if(columns===undefined)
      return undefined;
    let newColumns = []
    columns.forEach((C,iC) => {
      let ipath = columnsPath.concat(iC);
      let E = {
        location:U.newLocation(ipath, U.WILO_FULL)
      }
      if(C.key!==undefined) {
        E.key = { val: C.key, location:U.newLocation(ipath.concat("key"), U.WILO_FULL)};
      }
      U.setAugmented(E)
      if(C==="*") { // select all
        E.val = C;
      } else if(C.val!==undefined) { // value
        E.value = newValue(C.val, ipath, undefined, undefined, C.literal);
      } else if(C.xpr!==undefined) { // expression
        let xpr = augmentXPR(C.xpr, ipath.concat("xpr"));
        E.value = xpr;
      } else if(C.func!==undefined) { // function call
        E.value = augmentExpressionItem(C, iC, columnsPath);
      } else if(C.SET!==undefined) { // query
        E.value = augmentQuery(C,ipath)[0]
      } else if(C.SELECT!==undefined) { // query
        E.value = augmentQuery(C,ipath)
      } else if(C.ref!==undefined) { // reference
        let refPath = ipath.concat("ref")
        let path = C.ref.map((E,iE) => {
          let ipath = refPath.concat(iE);
          if(E.id) {
            let R = {
              id:E.id,
              location:U.newLocation(ipath, U.WILO_FULL)
            };
            let where=augmentXPR(E.where,ipath.concat("where"))
            setOpt(R,"where", where)
            if(E.cardinality!==undefined) {
              R.cardinality = E.cardinality;
              parent.transformers.cardinality(R,"cardinality",ipath);
              U.setAugmented(R.cardinality)
            }
            if(E.args!==undefined) {
              R.namedArgs = augmentViewArgs(E.args,ipath.concat("args"));
            }
            return R;
          }
          if(typeof E === "string") {
            return {
              id:E,
              location:U.newLocation(ipath, U.WILO_FULL)
            };
          }
          throw Error("query.columns - unsupported type "+(typeof E)+"," + JSON.stringify(E))
        })
        E.value = {path, location: U.newLocation(refPath, U.WILO_FULL)};
        if(C.param)
          E.value.scope="param";
        if(C.global)
          E.value.scope="global";
      }
      if(C.as!==undefined) {
        E.name={
          id: C.as,
          location: U.newLocation(ipath.concat("as"), U.WILO_FULL)}
      }
      let cast = C.cast;
      if(cast!==undefined) {
        let castpath = ipath.concat("cast");
        // walk all properties of "cast" and call the appropriate generic transformer
        for(let prop in cast) {
          if(prop == '$extra') continue;
          let T = parent.transformers[prop]
          T(cast,prop,castpath)
          E[prop]=cast[prop]
        }
        E._typeIsExplicit=true;//TODO remove
      }
      newColumns.push(E)
    })
    return newColumns;
  }

  function augmentXPR(xpr, path) {
    if(xpr===undefined)
      return undefined;
    let location = U.newLocation(path, U.WILO_FULL)
    let args =  augmentExpression(xpr, path);
    let R = {
      op: { val:"xpr", location },
      args,
      location
    }
    U.setAugmented(R)
    return R;
  }

  function augmentExpressionValue(value, path) {
    return newValue(value,path)
  }

  function augmentExpression(X,path) {
    if(!Array.isArray(X))
      return augmentExpressionValue(X, path)
    let R = X.map((Y,I) => augmentExpressionItem(Y, I, path))
    return R;
  }

  function augmentExpressionItem(val, name, Path) {
    let path = Path.concat(name)
    let location = U.newLocation(path)
    if(val === null)
      return {val:null,location}
    let t = typeof val;
    if(t === "string") {
      return val;
    } else if(t === "boolean")
      return {val, literal: 'boolean', location};
    if(val.hasOwnProperty("ref")) {
      let R = {
        path: refAsPath(val.ref, path.concat("ref")), // TODO remove this later - here 'ref' is renamed to 'path'
        location};
      if(val.param===true) {
        R.scope="param";
      }
      return R;
    } else if(val.hasOwnProperty("literal")) {
      if(!val.hasOwnProperty("val"))
        throw Error("Literal without val property")
      val.location = U.newLocation(path);
      return val;
    } else if(val.hasOwnProperty("val")) {
      return augmentLiteralValue(val.val, path)
    } else if(val.hasOwnProperty("func")) {
      let r = {
        op:{val: "call", location},
        func: {path:[{id:val.func, location:U.newLocation(path.concat("func"))}]}, // to-csn.js has TODO XSN: remove op: 'call', func is no path
        location
      };
      if (val.args) {
        let aPath = path.concat("args")
        if(typeof val.args == "object" && Array.isArray(val.args)==false) {
          r.namedArgs=udict.dmap(val.args, (O,N) => {
            return newValue(O.val,aPath.concat(N), N, U.WILO_FULL, undefined, U.WILO_FIRST);
          })
        } else if(val.args[0] && val.args[0]==="*") { // count(*)
          r.args = [{
            val:"*",
            literal: "token",
            location: U.newLocation(aPath)
          }]
        } else {
          r.args = augmentExpression(val.args,aPath);
        }
      }
      return r;
    } else if(val.hasOwnProperty("#")) {
      return {
        literal:"enum", symbol:{id:val["#"],location},location
      }
    } else if(val.hasOwnProperty("SET")) {
      throw Error("SET not supported in expression items")
    } else if(val.hasOwnProperty("SELECT")) {
      return augmentQuery(val,path)
    } else if(val.hasOwnProperty("xpr")) {
      return augmentXPR(val.xpr, path.concat("xpr"));
    }
    throw Error("augmentExpressionItem failed: "+JSON.stringify(val)+path.join("/"))
  }

  function refAsPath(ref, path) {
    let R = ref.map((X,I) => {
      let ipath=path.concat(""+I);
      let location = U.newLocation(ipath)
      if(typeof X === "string") {
        return {id:X,location}
      }
      if(typeof X === "object" && X.id!==undefined) {
        let R = {id:X.id,location}
        if(X.where)
          R.where=augmentXPR(X.where,ipath.concat("where"))
        if(X.cardinality) {
          R.cardinality = X.cardinality;
          parent.transformers.cardinality(R,"cardinality",ipath);
          U.setAugmented(R.cardinality)
        }
        if(X.args) {
          R.namedArgs = augmentViewArgs(X.args, ipath.concat("args"));
        }
        return R;
      }
      throw Error("Unexpected path ref at "+ipath.join("/")+":"+JSON.stringify(ref)) ;
    })
    return R;
  }

  function augmentLiteralValue(val, path) {
    let location = U.newLocation(path)
    let literal = (val === null) ? 'null' : typeof val;
    return {val, literal, location};
  }

  function newValue(val, path, name=undefined, which=undefined, literal=undefined, nameWhich=undefined) {
    if(which===undefined)
      which=U.WILO_FULL;
    if(nameWhich===undefined)
      nameWhich=U.WILO_FULL;
    if(val===undefined)
      return undefined;
    if(U.isAugmented(val))
      return undefined;
    let ret;
    if(literal===undefined)
      literal = typeof val; // TODO
    if(val===null) {
      ret = { literal: 'null', val };
    }
    else if(Array.isArray(val)) { // process array
      ret = { literal: 'array',
        val: val.map((V,I) => newValue( V, path.concat(''+I) ) )
      };
    }
    else if(literal !== "object") {  // number, string
      ret = { literal, val };
    }
    else if ('#' in val) {      // TODO: length / other property test?
      ret = { literal: 'enum', symbol: { id: val['#']} };
    }
    else if ('=' in val) {    // TODO: length / other property test?
      let location = U.newLocation(path);
      ret = { path: val['='].split('.').map( id => ({ id, location }) ) };
    }
    else {
      let struct = Object.create(null);
      ret = { literal: 'struct', struct };
      W.forEach(val, (K,V) => {
        struct[K] = newValue(V, path.concat(K), K);
      })
    }
    if(name) {
      ret.name = {id:name};
      U.setLocation(ret.name, path, nameWhich);
    }
    U.setLocation(ret, path, which);
    if(ret.symbol)
      U.setLocation(ret.symbol, path);
    U.setAugmented(ret)
    return ret;
  }

  function augmentNumber(val,path, which=U.WILO_FULL) {
    return {
      val,
      literal: "number",
      location: U.newLocation(path, which)
    }
  }

  function augmentJoin(qoFrom,Path) {
    let args=qoFrom.args.map((A,IA) => {
      let ipath = Path.concat("args",IA);
      if(A.SELECT!==undefined) {
        return augmentQuery(A,ipath);
      }
      if(A.join) {
        return augmentJoin(A, ipath);
      }
      let refPath = ipath.concat("ref")
      let path = A.ref.map((X,I) => {
        let iRefPath = refPath.concat(I);
        let R = { id:X, location:U.newLocation(iRefPath, U.WILO_FULL) }
        if(X.id) R.id=X.id; //for filter select from E[a=2] -> ref:[{id:E,where...}]
        if(X.where) {
          R.where=augmentXPR(X.where,iRefPath.concat("where"))
        }
        if(X.args) {
          R.namedArgs = augmentViewArgs(X.args,iRefPath.concat("args"))
        }
        U.setAugmented(R)
        return R;
      }) // ref map
      let R = { path, location: U.newLocation(ipath, U.WILO_FULL) };
      if(A.as!==undefined)
        R.name = {id:A.as, location: U.newLocation(ipath.concat("as"), U.WILO_FULL) };
      U.setAugmented(R)
      return R;
    }) // args map
    let location = U.newLocation(Path, U.WILO_FULL);
    let join = qoFrom.join;
    let R = {
      op: { val:"join", location },
      join,
      args,
      location
    }
    if(qoFrom.on!==undefined) {
      let onPath = Path.concat(["on"]);
      R.on = augmentXPR(qoFrom.on, onPath)
    }
    U.setAugmented(R)
    return [R];
  } // function augmentJoin

  function augmentQuerySourceFrom(query, selectPath) {
    let fromPath = selectPath.concat("from");
    let qo = query.SELECT;
    if(!qo)
      throw Error("Missing SELECT in query"+JSON.stringify(query)) //TODO move to validator
    if(!qo.from)
      throw Error("Missing FROM in SELECT") //TODO move to validator
    U.setAugmented(qo)
    if(qo.from.SELECT) {
      let R = augmentQuery(qo.from,fromPath);
      if(Array.isArray(R))
        return R;
      return [R]
    }
    if(qo.from.join) {
      return augmentJoin(qo.from, fromPath)
    }
    if(qo.from.ref) {
      let R = {
        path: refAsPath(qo.from.ref, fromPath.concat("ref")),
        location: U.newLocation(fromPath, U.WILO_FULL)
      }
      U.setAugmented(R)
      return [R];
    }
    if(qo.from.SET) {
      return augmentQuery(qo.from, fromPath);
    }
    throw Error("Unknown query: "+JSON.stringify(query))
  } // function augmentQuerySourceFrom

} // createInstance

module.exports = createInstance
