let W = require("./walker");

function createInstance(model) {
  let U = require("./augmentor3utils.js")(model)
  return getTransformers(model,U);
}

function getTransformers(model,U) {

  // augment query instance
  let AQ;
  let newValue;

  function modifyCondition(node, name, path) {
    let xpr = AQ.augmentXPR(node.on, path.concat(name));
    node.onCond = xpr;
    delete node["on"]
  }

  function modifyIncludes(node, name, path) {
    let value = node[name];
    let r = value.map( (X,iX) => {
      let location = U.newLocation(path.concat(name, iX), U.WILO_FULL)
      return asPlainPath(X,location);
    })
    node[name] = r;
  }

  function asPlainPath(id, location) {
    return {
      path: [ { id, location } ],
      location
    }
  }

  function modifyValue(node, name, path) {
    let value = newValue(node[name], path.concat(name))
    if(value!==undefined)
      node[name] = value;
  }

  function modifyBoolean(node, name, path) {
    let value = node[name];
    if(value !== undefined) {
      node[name]={val: value};
      U.setLocation(node[name], path.concat(name));
    }
  }

  function ignore(/*node, name, path*/) {
  }

  function arrayAsDict(node, name, path, xsnName=name) {
    let A = node[name]
    let R = Object.create(null);
    A.forEach((X,I) => {
      let ipath = path.concat([name,I]);
      let location = U.newLocation(ipath, U.WILO_FULL);
      let locationRef = U.newLocation(ipath.concat("ref"), U.WILO_FULL);
      let elementName = U.getLastElement(X.ref);
      let O = {
        kind:"key",
        targetElement: {
          path: X.ref.map((Y,J) => {
            let location = U.newLocation(ipath.concat(["ref",J]), U.WILO_FULL);
            return {id:Y,location};
          }),
          location:locationRef
        },
        location
      }
      //if "as" is present set it as "name" property
      if(X.as !== undefined) {
        elementName = X.as;
        O.name = {
          id:  X.as,
          location: U.newLocation(ipath.concat("as"), U.WILO_LAST)
        }
      }
      R[elementName] = O;
    })
    node[xsnName] = R;
    if (xsnName !== name)
      delete node[name];
  }

  function modifyKind(node) {
    if(node.kind === "view")
      node.kind = "entity";
  }

  function modifyNumber(node, name, path, newName = undefined) {
    if(U.isAugmented(node[name]))
      return;
    let value=node[name];
    let lpath = path.concat(name);
    if(newName!==undefined) {
      delete node[name]
      name = newName;
    }
    if(value !== undefined) {
      node[name]=AQ.augmentNumber(value, lpath, U.WILO_LAST);
      U.setAugmented(node[name]);
    }
  }

  function cardinality(node, name, path) {
    let lpath = path.concat([name]);
    let cardinality= node.cardinality;
    if(cardinality) {
      U.setLocation(cardinality, lpath);
      if(cardinality.src !== undefined) {
        if(cardinality.src === "*")
          cardinality.sourceMax = newValue(cardinality.src, lpath.concat("src"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "src", lpath, "sourceMax");
        delete cardinality["src"]
      }
      if(cardinality.min !== undefined) {
        if(cardinality.min === "*")
          cardinality.targetMin = newValue(cardinality.min, lpath.concat("min"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "min", lpath, "targetMin");
        delete cardinality["min"]
      }
      if(cardinality.max !== undefined) {
        if(cardinality.max === "*")
          cardinality.targetMax = newValue(cardinality.max, lpath.concat("max"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "max", lpath, "targetMax");
        delete cardinality["max"]
      }
    }
  }

  function standard(/*node, name, path*/) {
  }

  function augmentTypeRef(val,path) {
    let location = U.newLocation(path, U.WILO_FULL)
    let newPath;
    if(typeof val == 'string') {
      newPath = [{id:val, location}]
    } else if(val.ref) {
      newPath = AQ.refAsPath(val.ref, path.concat("ref"))
    } else {
      throw Error ("Unexpected type reference '"+(typeof val)+"' under "+path.join("/"));
    }
    return {
      path:newPath,
      location
    };
  }

  function artifactRef(node, name, path) {
    node[name] = augmentTypeRef(node[name],path.concat(name));
  }

  function fromOld(/*node, name, path*/) {
  }

  function modifyExpression(node, name, path) {
    let X = node[name];
    if(!Array.isArray(X))
      node[name] = AQ.augmentExpressionItem(X,name,path)
    else
      throw Error("Array expressions are not supported")
  }

  function modifyAnnotation(node, key, path) {
    node[key] = newAnnotation(key, node[key], path);

    function newAnnotation(anAnno, aValue, path) {
      if (aValue instanceof Object && 'literal' in aValue)
        throw new Error('strange re-run')
      let ret = {};
      if(aValue!==true && aValue!==undefined)
        ret = newValue(aValue, path.concat(anAnno));
      ret.name = { location: U.newLocation(path.concat(anAnno), U.WILO_FIRST) };
      return ret;
    }

  }

  function modifyQuery(node, key, path) {
    let R = AQ.augmentQuery(node[key], path.concat(key));
    node[key] = R
  }

  function modifyPayload(node) {
    node["elements"]=node["payload"]
    delete node["payload"]
  }

  ////////////////////////////////////

  function augmentElement(name, node, Path) {
    let path = Path.concat(name)
    U.setLocation(node, path);
    elementName(name, node, path);
    elementKind(node, path);
  
    if(node.items)
      augmentItems(path.concat("items"),node.items)
  
    function elementName(name, node, path) {
      node.name = {
        id: name
      };
      U.setLocation(node.name, path.concat(name), U.WILO_FIRST)
    }
  
    function elementKind(node, path) {
      let kind = "element";
      // special handling for annotate extensions - the element.kind is annotate
      if( isExtensionAnnotate(path) ) {
        kind="annotate";
      }
      node.kind = kind;
    }
  
  }

  function augmentAction(name, node, Path) {
    let path = Path.concat(name)
    U.setLocation(node, path);
    if(node.returns!==undefined) {
      U.setLocation(node.returns, path.concat("returns"));
      if(node.returns.items!==undefined) {
        augmentItems(path.concat(["returns","items"]), node.returns.items)
      }
    }
    // special handling for annotate extensions - the element.kind is annotate
    if( isExtensionAnnotate(path) ) {
      node.kind = "annotate";
    }
  }

  function augmentEnumItem(name, node, path) {
    U.setLocation(node, path.concat(name));
    elementName(name, node, path); // reuse function !
    enumKind(node);

    if(node.val !== undefined) {
      node.value = AQ.augmentExpression(node.val, path);
      delete node["val"];
    }

    function elementName(name, node, path) {
      node.name = {
        id: name,
        location: U.newLocation(path.concat(name), U.WILO_FIRST)
      }
    }

    function enumKind(node) {
      node.kind = "enum";
    }
  }

  function augmentParam(name, node, Path) {
    let path = Path.concat(name);
    node.location=U.newLocation(path);
    let kind = "param";
    // special handling for annotate extensions - the element.kind is annotate
    if( isExtensionAnnotate(path) ) {
      kind="annotate";
    }
    node.kind = kind;
    node.name = {
      id:name, // TODO check this
      location: U.newLocation(path, U.WILO_FIRST),
      param:name // remove? just for testAugmentor3.js?
    }
    if(node.items)
      augmentItems(path.concat("items"),node.items)
  }

  function isExtensionAnnotate(path) {
    if( path.length>2
      && path[0] === "extensions"
      && model[path[0]][path[1]].kind==="annotate")
      return true;
    return false;
  }

  function augmentItems(path, items) {
    transformers.modifyNumber(items, "length", path);
    U.setLocation(items, path);
  }

  function augmentDefinition(name, def, path) {
    U.setLocation(def, path);
    definitionName(name, def);

    if(def.items !== undefined)
      augmentItems(path.concat("items"),def.items)

    if(def.returns !== undefined) {
      U.setLocation(def.returns, path.concat("returns"));
      if(def.returns.items !== undefined) {
        augmentItems(path.concat("returns","items"), def.returns.items);
      }
    }

    function definitionName(name, def) {
      let sp = name.split(".");
      let last = sp[sp.length-1];
      let sp1 = last.split("::"); //TODO check this split
      last = sp1[sp1.length-1];

      let location = U.newLocation(path, U.WILO_FIRST)
      def.name = {
        id: last, // TODO only for semanticChecks.js/checkGenericConstruct ?
        absolute: name, // TODO only for semanticChecks.js/checkGenericArtifact ?

        // the path is used in transformUtils.createExposingProjection
        // this one can be removed once the auto exposure is done by the compiler instead of the transformer
        path: [ { id: name, location } ],
        location
      }
    } // definitionName
  } // augmentDefinition

  function augmentExtension(key,E,path) {
    let locationObj = U.newLocation(path, U.WILO_FULL)
    if(E.annotate) {
      let location = U.newLocation(path.concat("annotate"), U.WILO_LAST)
      E.kind="annotate",
      E.name={path:[{id:E.annotate,location}],location};
      E.location = locationObj;
      delete E["annotate"]
    }
  }

  function walkAndAugment(root, rootPath) {
    W.walkWithPath(root, (isNode,subPATH,NODE) => {
      if(!isNode)
        return;
      if (NODE === null)
        return;
      let PATH = rootPath.concat(subPATH)
      let PROTO = Object.getPrototypeOf(NODE);
      W.forEach(NODE, (key,node) => {
        if(PROTO) {
          let isAnnotation = key.charAt(0)==='@';
          let T = transformers[isAnnotation ? '@' : key];
          if(T) {
            T(NODE, key, PATH);
          }
        } else { // dict
          let lastElement = getLastElement(PATH);
          if(lastElement === "elements") {
            augmentElement(key, node, PATH);
          } else if(lastElement === "mixin") {
            augmentElement(key, node, PATH);
          } else if(lastElement === "enum") {
            augmentEnumItem(key, node, PATH);
          } else if(lastElement === "params") {
            augmentParam(key, node, PATH);
          } else if(lastElement === "actions") {
            augmentAction(key, node, PATH);
          }
        }
      }) // forEach
    }, (path,obj) => { // check function
      let lastElement = U.getLastElement(path)
      if(lastElement[0]==="@")
        return false; // do not walk annotations
      if(U.isAugmented(obj)) {
        return false;
      }
      return true;
    }) // walkWithPath
  }

  //returns the last element of an array
  function getLastElement(a) {
    return a[a.length-1];
  }
  
  let transformers = {
    newValue,
    ///////
    '@': modifyAnnotation,
    annotationAssignments: ignore, // TODO: make it $annotations
    artifacts: ignore,             // almost just $artifacts
    blocks: ignore,                // TODO: make it $blocks
    indexNo: ignore,               // TODO XSN: remove
    queries: ignore,               // TODO: make it $queries
    location: ignore,
    // future ------------------------------------------------------------------
    extensions: ignore,           // TODO: list non-applied
    quoted: ignore,               // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
    // members -----------------------------------------------------------------
    actions: ignore,
    elements: ignore,
    payload:modifyPayload,
    enum: ignore,
    keys: (node, name, path) => arrayAsDict(node, name, path, 'foreignKeys'),
    mixin: ignore,       // only in queries with special handling
    params: ignore,
    // different XSN later -----------------------------------------------------
    calculated: ignore,            // later in name: $inferred: 'as'
    implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
    origin: ignore,                // remove (introduce non-enum _origin link)
    projection: ignore,            // later in entity: $syntax: 'projection'
    source: ignore,                // remove
    viaAll: ignore,                // later in elem: $inferred: '*'
    // general properties of constructs ----------------------------------------
    abstract: modifyBoolean,
    localized: modifyBoolean,
    dbType: modifyValue,                // TODO: currently with --hana-flavor only
    default: modifyExpression,
    impl: ignore,               // obsolete - remove
    key: modifyBoolean,
    kind: modifyKind,
    name: ignore,
    virtual: modifyValue,
    notNull: modifyValue,
    masked: modifyValue,
    returns: ignore,            // storing the return type of actions
    // type properties ---------------------------------------------------------
    cardinality,
    includes: modifyIncludes, // also entities
    length: modifyValue,
    on: modifyCondition,
    onCond : ignore,
    precision: modifyValue,
    redirected: ignore,           // TODO: no need for this
    scale: modifyValue,
    srid: modifyValue,
    target: artifactRef,
    type: artifactRef,
    items: standard,
    // inner properties which should not occur anymore -------------------------
    path: ignore,
    sourceMax: ignore,
    targetMin: ignore,//modifyValue,
    targetMax: ignore,//modifyValue,
    targetElement: ignore,        // special display of foreign key
    // queries -----------------------------------------------------------------
    from: fromOld,
    all: ignore,                  // should not occur
    exclude: ignore,
    groupBy: ignore,
    having: ignore,
    limit: ignore,                // TODO XSN: include offset
    offset: ignore,             // TODO XSN: move into `limit`
    orderBy: ignore, // TODO XSN: make `sort` and `nulls` sibling properties
    query: modifyQuery,
    value: ignore,             // do not list for select items as elements
    where: ignore,
    // special HANA CDS featues ------------------------------------------------
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    // direct exports
    modifyNumber,
    //
    augmentElement,
    augmentAction,
    augmentEnumItem,
    augmentParam,
    augmentDefinition,
    augmentExtension,
    augmentTypeRef,
    walkAndAugment
  }

  // augment query instance
  AQ = require("./augmentor3query")(U,{walkAndAugment,transformers});
  newValue=AQ.newValue; // newValue shortcut

  return transformers;
}

module.exports = createInstance;

