const { CompileMessage } = require('../base/messages');

function buildMessage(model, msg, location, severity, message_id, context){
  let semanticLocation = undefined;
  if(Array.isArray(location)){
    semanticLocation = location;
    validateSemanticLocation(semanticLocation);
    location = searchForLocation(semanticLocation);
    
  }
  return new CompileMessage(location, msg, severity ? severity : msg._severity, message_id, beautifySemanticLocation(semanticLocation), context);

  function searchForLocation(semanticLocation){
    let last_location = null; // Don't display a location if we cannot find one!
    let currentThing = model;
    for(const step of semanticLocation){
      if(!currentThing){
        return last_location;
      }
      currentThing = currentThing[step];
  
      if(currentThing && currentThing.$location){
        last_location = currentThing.$location;
      }
    }
  
    return last_location;
  }

  function validateSemanticLocation(semanticLocation){

    if(semanticLocation.length == 0){
      throw new Error('An empty semantic location was supplied, this should not happen!');
    }
  
    if(semanticLocation[0] !== 'definitions'){
      throw new Error('Semantic locations must start with "definitions", found: ' + semanticLocation[0]);
    }
  
    if(semanticLocation.length == 1){
      throw new Error('Semantic locations must at least point to an artifact!');
    }

    return true;
  }

  function beautifySemanticLocation(semanticLocation){
    if(!semanticLocation){
      return semanticLocation;
    }
    const copy = [...semanticLocation];

    const art = model.definitions[copy[1]];

    copy[1] = ((art && art.kind) ? art.kind : 'artifact') + ':' + quoted(copy[1])

    return copy.slice(1).join('/');
  }
}
  
function quoted( name ) {
  return (name) ? '"' + name.replace( /"/g, '""' ) + '"' : '<?>'; // sync ";
}


module.exports = buildMessage;

