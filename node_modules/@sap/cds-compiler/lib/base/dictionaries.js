// Functions for dictionaries (Objects without prototype)

'use strict';

// Add entry `entry` with key `name` to the dictionary `dict`.  If an entry
// (called `found`) with the same name is already defined, call
// `messagerCallback` with arguments `name` and `loc` assigned to
// `entry.name.location`.  If this is the first duplicate entry and if the
// `filename`s are different, call the callback again on `found.name.location`.
function addToDict( dict, name, entry, messageCallback ) {
  var found = dict[name];
  if (!found || found.builtin) { // do not replace a builtin definition
    // XSN TODO: store duplicate definitions in prop $duplicates, do not use array (except $combined?)
    dict[name] = entry;         // also ok if array (redefined)
    return entry;
  }
  if (entry instanceof Array) {
    if (found instanceof Array) {
      dict[name] = [ ...found, ...entry ];
    }
    else {
      dict[name] = [ found, ...entry ];
      // Redefinitions from second source -> also complain in first source
      if (messageCallback && name)
        messageCallback( name, found.name.location, found );
      if (messageCallback !== null)
        found.$duplicate = true;
    }
  }
  else {
    if (found instanceof Array) {
      dict[name] = [ ...found, entry ];
    }
    else {
      dict[name] = [ found, entry ];
      // Definitions from second source -> also complain for definition in first source
      // TODO: with packages, we could also use the package hierarchy
      if (messageCallback && name)
        messageCallback( name, found.name.location, found );
      if (messageCallback !== null)
        found.$duplicate = true;
    }
    if (messageCallback && name)
      messageCallback( name, entry.name.location, entry );
    if (messageCallback !== null)
      entry.$duplicate = true;
  }
  return entry;
}

// TODO: either use dict[lengthSymbol] to store length or just use (after perf
// test) Object.keys(dict).length
// var lengthSymbol = typeof Symbol !== 'undefined' && Symbol.for && Symbol.for('dictLength')
const orderedDictionaries = {
  elements: '_elementsIndexNo',
  foreignKeys: '_foreignKeysIndexNo',
  params: '_paramsIndexNo'
};

function addToDictWithIndexNo( parent, env, name, entry, messageCallback ) {
  addToDict( parent[env], name, entry, messageCallback );
  let ordered = orderedDictionaries[env];
  if (!ordered)
    return;
  if (!(ordered in parent))
    Object.defineProperty( parent, ordered, { value: 0, configurable: true, writable: true } );
  entry.indexNo = ++parent[ordered];
}

function clearDict( parent, env, inPlace ) {
  if (!inPlace || !parent[env])
    parent[env] = Object.create(null);
  else {
    let dict = parent[env];
    let keys = Object.keys( dict );
    for (let k of keys)
      delete dict[k];
  }
  let ordered = orderedDictionaries[env];
  if (ordered)
    delete parent[ordered];
  return ordered;
}

// Return the source location of the complete dictionary `dict`.  If
// `extraLocation` is truthy, also consider this location.
// ASSUMPTION: all entries in the dictionary have a property `location` and
// `location.filename` has always the same value.
function dictLocation( dict, extraLocation ) {
  if (!dict)
    return extraLocation;

  if (!(dict instanceof Array))
    dict = Object.getOwnPropertyNames( dict ).map( name => dict[name] );
  let locations = [].concat( ...dict.map( objLocations ) );
  if (extraLocation)
    locations.push( extraLocation );
  let min = locations.reduce( (a,b) => a.start.offset < b.start.offset ? a : b );
  let max = locations.reduce( (a,b) => (a.end||a.start).offset > (b.end||b.start).offset ? a : b );
  return { filename: min.filename, start: min.start, end: max.end };
}

function objLocations( obj ) {
  return (obj instanceof Array) ? obj.map( o => o.location ) : [ obj.location ];
}

// Create a location with location properties `filename` and `start` from
// argument `start`, and location property `end` from argument `end`.
function combinedLocation( start, end ) {
  return {
    filename: start.location.filename,
    start: start.location.start,
    end: end.location.end
  };
}

// Push `entry` to the array value with key `name` in the dictionary `dict`.
function pushToDict( dict, name, entry ) {
  if (dict[name])
    dict[name].push(entry);
  else
    dict[name] = [entry];
}

function forEachInDict( dict, callback ) {
  let r = Object.create(null);
  for (let name of Object.keys(dict))
    r[name] = callback( dict[name], name, dict );
  return r;
}

module.exports = {
  addToDict,
  addToDictWithIndexNo,
  clearDict,
  dictLocation,
  combinedLocation,
  pushToDict,
  forEachInDict,
}

