const BaseBuilder = require('./BaseBuilder')
const getAnnotatedColumns = require('../utils/annotations')

/**
 * UpdateBuilder is used to take a CQN object as an input and to build an object representing an update operation
 * with SQL string and values to be used with a prepared statement.
 * The SQL object can only be built if properties 'entity' and 'with' are available.
 * The property 'where' is optional.
 * @example <caption>Example of CQN </caption>
 * {
 *  UPDATE = {UPDATE:{
 *  entity: entity | string,
 *  data: { ...column:any },
 *  where: _xpr,
 *  }}
 * }
 */
class UpdateBuilder extends BaseBuilder {
  constructor (obj, options, csn) {
    super(obj, options)
    this._options.typeConversion = this._options.typeConversion || new Map()
    this._csn = csn
  }

  get ExpressionBuilder () {
    const ExpressionBuilder = require('./ExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', { value: ExpressionBuilder })
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./ReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', { value: ReferenceBuilder })
    return ReferenceBuilder
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *    sql: 'UPDATE "T" SET "a" = ?, "b" = ?, "c" = ? WHERE "x" < ? ',
   *    values: [1, 2, "'asd'", 9]
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   */
  build () {
    this._outputObj = {
      sql: ['UPDATE'],
      values: []
    }

    const entityName = this._entity()

    this._data(getAnnotatedColumns(entityName, this._csn))
    if (Array.isArray(this._obj.UPDATE.where) && this._obj.UPDATE.where.length > 0) {
      this._where()
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _entity () {
    if (typeof this._obj.UPDATE.entity === 'string') {
      this._outputObj.sql.push(this._quoteElement(this._obj.UPDATE.entity))
      return this._obj.UPDATE.entity
    } else {
      this._outputObj.sql.push(this._quoteElement(this._obj.UPDATE.entity.name))
      return this._obj.UPDATE.entity.name
    }
  }

  _data (annotatedColumns) {
    const sql = []
    const annotatedInsertColumnNames = this._getAnnotatedInsertColumnNames(annotatedColumns)
    const resMap = this._getFlattenColumnValues(this._obj.UPDATE.data, annotatedInsertColumnNames)
    this._removeAlreadyExistingUpdateAnnotatedColumnsFromMap(annotatedColumns, resMap)

    this._addAnnotatedUpdateColumns(resMap, annotatedColumns)

    resMap.forEach((value, key, map) => {
      if (value && value.sql) {
        sql.push(`${this._quoteElement(key)} = ${value.sql}`)
        this._outputObj.values.push(...value.values)
      } else {
        sql.push(`${this._quoteElement(key)} = ?`)
        this._outputObj.values.push(value)
      }
    })

    this._outputObj.sql.push(`SET ${sql.join(', ')}`)
  }

  _removeAlreadyExistingUpdateAnnotatedColumnsFromMap (annotatedColumns, resMap) {
    if (!annotatedColumns) {
      return
    }

    for (const columnName of annotatedColumns.updateAnnotatedColumns.keys()) {
      if (resMap.get(columnName)) {
        // only if value is !null && !undefined it should be kept
        annotatedColumns.updateAnnotatedColumns.delete(columnName)
      }
    }
  }

  _getFlattenColumnValues (data, annotatedInsertColumnNames, prefix) {
    const res = new Map()
    Object.keys(data).forEach(key => {
      const prefixKey = prefix ? `${prefix}_${key}` : key
      if (annotatedInsertColumnNames && annotatedInsertColumnNames.includes(prefixKey)) {
        return
      }
      const value = data[key]
      if (typeof value === 'object' && value !== null && typeof value.pipe !== 'function') {
        if (value.hasOwnProperty('xpr')) {
          const xpr = new this.ExpressionBuilder(value.xpr, this._options, this._csn).build()
          res.set(key, xpr)
        } else if (value.hasOwnProperty('ref')) {
          const ref = new this.ReferenceBuilder(value, this._options, this._csn).build()
          res.set(key, ref)
        } else if (value.hasOwnProperty('val')) {
          res.set(key, value.val)
        } else {
          const resInternal = this._getFlattenColumnValues(value, annotatedInsertColumnNames, prefixKey)
          Array.from(resInternal.keys()).forEach(keyInternal => {
            res.set(`${key}_${keyInternal}`, resInternal.get(keyInternal))
          })
        }
      } else {
        res.set(key, value)
      }
    })

    return res
  }

  _addAnnotatedUpdateColumns (resMap, annotatedColumns) {
    if (!annotatedColumns) {
      return
    }
    for (const col of annotatedColumns.updateAnnotatedColumns.keys()) {
      const annotatedValue = this._options[annotatedColumns.updateAnnotatedColumns.get(col).symbol]
      if (typeof annotatedValue === 'object') {
        annotatedValue.values = []
      }
      resMap.set(col, annotatedValue)
    }
  }

  _getAnnotatedInsertColumnNames (annotatedColumns) {
    if (!annotatedColumns) {
      return []
    }
    return [...annotatedColumns.insertAnnotatedColumns.keys()]
  }

  _where () {
    const where = new this.ExpressionBuilder(this._obj.UPDATE.where, this._options, this._csn).build()
    this._outputObj.sql.push('WHERE', where.sql)
    this._outputObj.values = this._outputObj.values.concat(where.values)
  }
}

module.exports = UpdateBuilder
