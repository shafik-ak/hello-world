const Query = require('./Query')
const cds = require('../cds'), {extend} = cds

class UPDATE extends Query {

    static in (_context) {
        return extend (function (entity,_key) {
            const q = (new UPDATE) .in (_context)
            q._cqn.entity = q.target (entity)
            if (_key) q.byKey (_key)
            return q
        }) .with ({ entity(e){ return this(e) }})
    }

    set(...args) {  return this.with(...args) }
    with (...args) { // NOSONAR
        if (typeof args[0] === 'object') {
            this._cqn.data = args[0]
        } else {
            const cqn = this._cqn.data = {}
            if (args.length === 1) for (let each of _data(args[0])) {
                const {xpr:[lhs,op,...rhs]} = cds.parse.expr (each)
                cqn[lhs.ref.join('.')] = _expr (lhs, op, ...rhs)
            } else for (let i=0; i<args.length; ++i) {
                const [,col,op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec (args[i])
                cqn[col] = _expr (col, op, {val:args[++i]})
            }
        }
        return this
    }

    valueOf(){ return super.valueOf('UPDATE') }
}


function _expr (lhs, op, ...rhs) {
    if (op === '=')  return rhs.length === 1 ? rhs[0] : {xpr:rhs}
    if (op.length === 2 && op[1] === '=')  return {xpr:[ lhs.ref ? lhs : {ref:[lhs]}, op[0], ...rhs ]}
    else throw new Error ('Invalid operator in UPDATE(...).set() expression: '+ op)
}

function _data(s) {  // NOSONAR
    let all=[], start=0, scope=0, close=0, stack=[ close ]
    for (let i=0; i<s.length; ++i) {
        const c = s[i]
        if (c === ',' && !scope) {
            all.push(s.slice(start,i))
            start = i+1
        } else if (c === "'") {
            while (i<s.length) {
                if (s[++i] === "'") {
                    if (s[i+1] === "'")  ++i  // NOSONAR
                    else break
                }
            }
        }
        else if (c === '(') { scope++; stack.unshift(close=')') }
        else if (c === '[') { scope++; stack.unshift(close=']') }
        else if (c === '{') { scope++; stack.unshift(close='}') }
        else if (c === close) { scope--; stack.shift(); close = stack[0] }
    }
    all.push (s.slice(start))
    return all
}

module.exports = UPDATE
