const Query = require('./Query')
const {extend} = require('../cds')
const noop = ()=>{}

class SELECT extends Query {

    static in (_context) {
        const SELECT_ = extend (function (_cols) {
            const q = (new SELECT) .in (_context)
            if (_cols)  q.columns (_cols)
            return q
        }) .with ({
            get distinct(){ return this._d || Object.assign (
                this._d = (...args) => (new SELECT_)._from ('distinct',...args),
                { from: (...args) => (new SELECT_)._from ('distinct',...args) }
            )},
            get one(){ return this._o || Object.assign (
                this._o = (...args) => (new SELECT_)._from ('one',...args),
                { from: (...args) => (new SELECT_)._from ('one',...args) }
            )},
            from: (...args) => (new SELECT_) .from (...args),
        })
        return SELECT_
    }

    byKey(ID) {
        this._cqn.one = true
        return super.byKey(ID)
    }

    // used by SELECT_.one/distinct
    _from (doo, first, ...more) { const [second] = more
        this._cqn[doo] = true
        if (isProjection(second)) return this.from (first) .columns (second)
        if (isProjection(first)) return this.columns (first)
        if (second)  return this.columns (first, ...more)
        else return {__proto__: this.from (first),
            from: (entity) => this.from (entity) .columns (first, ...more)
        }
    }

    from (entity, _keys, _projection) {
        this._cqn.from = this.target (entity)
        if (isProjection(_keys))  [_projection,_keys] = [_keys]
        if (_keys) this.byKey (_keys)
        if (_projection) this.columns (_projection)
        return this
    }

    columns (...cols) {
        const p = this._projection4 (isProjection(cols[0]) ? cols[0] : cols)
        if (p)  this._cqn.columns = p
        return this
    }

    expand (ref, cols, exp='expand') {
        const { _cqn } = this
        ;(_cqn.columns || (_cqn.columns=[])) .push ({
            ref: ref.split('.'),
            [exp]: cols ? this._projection4(cols) : ['*']
        })
        return this
    }

    inline (ref,cols) {
        return this.expand (ref,cols,'inline')
    }

    groupBy(){}
    having(){}
    orderBy(){}
    limit(){}

    foreach (callback) {
        return this.then (rows => rows.map (callback))
    }

    _projection4 (columns, entity) { /* eslint no-unused-vars: off */ // NOSONAR

        if (Array.isArray(columns)) {
            return columns[0] && columns.map ((col,index) => (
                typeof col === 'object' && Array.isArray(col.ref) ? col :
                typeof col === 'string' ? {ref:col.split('.')} :
                this._invalid ({ columns, index, expected: 'a string or {ref:[...]}' })
            ))
        }

        if (typeof columns === 'function') {
            const cols=[]
            columns (new Proxy ({},{
                get: (_,p) => {
                    let col = {ref:[p]};  cols.push(col)
                    return new Proxy (noop,{
                        // handle getters like (foo)=>{ foo.bar.car }
                        get: (_,p,me) => {
                            if (p === 'where')  return pred => { col.where = this._predicate4(pred); return me }
                            if (p === 'as')  return alias => { col.as = alias; return me }
                            else { col.ref.push(p); return me }
                        },
                        // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
                        apply: (_,__,[fn,{levels=1}={}]) => {
                            if (/^_\b/.test(fn)) {
                                // inline
                                col.inline = this._projection4(fn)
                                // REVISIT: following is a flattening implementation, in case cds.ql does not support .inline
                                // columns.pop() // remove the expanded col
                                // for (let each of _projection4(fn)) { // replace by n inlined ones
                                //     columns.push (col = {...each, ref:[...col.ref,...each.ref]})
                                // }
                            } else {
                                // expand
                                col.expand = this._projection4(fn)
                                while (--levels) { // add n-level deep hierarchy expands
                                    col.expand.push (col = {...col, expand: [...col.expand] })
                                }
                            }
                        },
                    })
                }
            }))
            return cols
        }

        else this._invalid ({ columns, expected: 'function or array' })
    }

    valueOf(){ return super.valueOf('SELECT from') }
}

const isProjection = (x) => typeof x === 'function' || Array.isArray(x)
module.exports = SELECT