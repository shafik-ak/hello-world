/* eslint-disable no-empty */
const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const BuildTaskFactory = require('../buildTaskFactory')
const { getProperty, setProperty } = require('../util')
const { BUILD_TASK_HANA, BUILD_TASK_MTX, FOLDER_GEN } = require('../constants')
const DEBUG = process.env.DEBUG

const FOLDER_SDC = "sdc"
const FOLDER_NODE_MODULES = "node_modules"
const FOLDER_TEMPLATES = "tpl"

class MtxModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Multitenant Application Builder", task, buildOptions)
    }

    init() {
        if (this.env.build.target === ".") {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN, FOLDER_SDC)
        } else {
            this.task.dest = path.join(this.task.dest, FOLDER_SDC)
        }
    }

    async build() {
        this.logger.log(`\n[cds] - building multitenant application`)

        // custom build tasks for srv and db modules might be defined
        let tasks = this.buildOptions.tasks || []
        tasks = tasks.filter(task => task.for !== BUILD_TASK_MTX)

        if (tasks.length === 0 || !tasks.find(task => task.for === BUILD_TASK_HANA)) {
            const dbKind = getProperty(this.env, ["requires", "db", "kind"])
            const buildTaskFactory = new BuildTaskFactory(this.logger, this.cds)
            let derivedTasks = []

            if (dbKind !== "hana") {
                // temporarily switch db.kind to 'hana' to make sure a hana build task is created as mtx is only supporting hana
                setProperty(this.env, ["requires", "db", "kind"], "hana")
            }
            try {
                derivedTasks = await buildTaskFactory._createTasksFromCdsConfig(this.buildOptions.root)
            } finally {
                if (dbKind !== "hana") {
                    setProperty(this.env, ["requires", "db", "kind"], dbKind)
                }
            }
            if (tasks.length === 0) {
                // no custom tasks, use derived tasks
                tasks = derivedTasks
            } else {
                // merge hana task into custom tasks
                // assuming that custom tasks have been defined for service modulesgit
                tasks = tasks.concat(derivedTasks.find(task => task.for === BUILD_TASK_HANA))
            }
        }

        if (tasks.length === 0) {
            this.logger.log("[cds] - no modules containing cds model files found, skipping build")
            return
        }
        const models = tasks.reduce((acc, task) => {
            if (Array.isArray(task.options.model)) {
                task.options.model.forEach(model => acc.add(model))
            }
            return acc
        }, new Set())

        const modelPaths = this.cds.resolve(Array.from(models), this.buildOptions)
        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skipping build")
            return
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        const csn = await this._compileCsn(modelPaths)
        const bundles = this._collectBundles(csn._sources)
        const {
            folders = ['i18n'], file = 'i18n'
        } = this.env.i18n

        const promises = csn._sources.map(src => {
            if (src.includes(FOLDER_NODE_MODULES)) {
                return this.copy(src).to(path.join(this.task.dest, src.substr(src.indexOf(FOLDER_NODE_MODULES))))
            } else {
                return this.copy(src).to(path.join(this.task.dest, path.relative(this.buildOptions.root, src)))
            }
        })

        if (Object.keys(bundles).length > 0) {
            promises.push(this.write(bundles).to(path.join(this.task.dest, folders[0], file + '.json')))
        }

        const hanaTask = tasks.find(task => task.for === BUILD_TASK_HANA)

        if (!hanaTask) {
            this.logger.warn('[cds] - no db module found, skip copying corresponding artefacts')
        }

        promises.push(this._copyNativeContent(this.task.src, this.task.dest, hanaTask))

        return Promise.all(promises)
    }

    async clean() {
        // staging build content has already been deleted
        if (this.env.build.target === ".") {
            // delete entire folder 'gen'
            let buildTargetDir = path.dirname(this.task.dest)
            if (DEBUG) {
                this.logger.log(`Deleting build target folder ${buildTargetDir}`)
            }
            await fs.remove(buildTargetDir)
        }
    }

    async _copyNativeContent(src, dest, hanaTask) {
        // copying tmplates
        const tplSrc = path.join(src, FOLDER_TEMPLATES)
        if (fs.existsSync(tplSrc)) {
            const tplDest = path.join(path.dirname(dest), FOLDER_TEMPLATES)
            await this._copyTemplates(tplSrc, tplDest)
        }

        if (hanaTask) {
            // copy hana related content from db module
            const dbSrc = path.resolve(src, hanaTask.src)
            const dbDest = path.resolve(dest, path.relative(this.buildOptions.root, dbSrc))
            await this._copyNativeHanaContent(dbSrc, dbDest)
        } else {
            this.logger.warn('[cds] - no db module found, skip copying corresponding artefacts')
        }
    }

    async _copyNativeHanaContent(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_NODE_MODULES
            }
            return /\.csv$|\.cds$|\.hdb.*$|^\.hdi.*|^undeploy\.json/.test(path.basename(entry))
        })
    }

    async _copyTemplates(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isFile()) {
                return /\.cds$/.test(path.basename(entry))
            }
            return true
        })
    }

    async _compileCsn(modelPaths) {
        return require('../../models/cdsv').compile(modelPaths, path.relative(process.cwd(), this.buildOptions.root))
    }

    _collectBundles(sources) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = this.cds.localize.bundles4({
            _sources: sources
        })

        if (typeof bundleGenerator === "object" && bundleGenerator.next) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }
        return bundles
    }
}
module.exports = MtxModuleBuilder
