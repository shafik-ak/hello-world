const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandlerOData = require('../buildTaskHandlerOData')
const { impl4 } = require("../../runtime/service")
const {format} = require('../../../bin/utils/term')
const { getApplicationName, getHdiService, getDefaultHdiServiceName } = require('../../utils/mtaUtil')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY, ODATA_VERSION, ODATA_VERSION_V2,
    BUILD_NODEJS_EDMX_GENERAION, BUILD_TASK_HANA, FOLDER_GEN, FILE_EXT_CDS } = require('../constants')

const DEBUG = process.env.DEBUG
const FILE_NAME_PACKAGE_JSON = "package.json"
const FILE_NAME_MANIFEST_YAML = "manifest.yaml"

class NodeCfModuleBuilder extends BuildTaskHandlerOData {
    constructor(task, buildOptions) {
        super("Node CF Module Builder", task, buildOptions)

        if (this._isStagingBuild()) {
            const srcDir = path.relative(this.buildOptions.root, this.task.src)
            // fallback if src has been defined as '.'
            this.task.dest = path.resolve(this.task.dest, srcDir || "srv")
        }
    }

    async build() {
            // resolve specified models, using all models by default, e.g.
            // { use:'...', src:'srv', options:{model:['app','srv']} }
        // { use:'...', src:'srv' }
        const {src, dest} = this.task
        const modelPaths = this._resolveModel()
        const destGen = this._isStagingBuild() ? dest : path.join(dest, FOLDER_GEN)

        this.logger.log(`\n[cds] - building module [${this._stripProjectPaths(src)}] using [${this.name}]`)

        if (this.hasCdsEnvOption(ODATA_VERSION, ODATA_VERSION_V2)) {
            // log warning as nodejs is only supporting odata version V4
            // investigate whether the build should fail in order to enforce correct configuration data
            this.logger.log(format.warn("odata.version = 'v2' not supported by node runtime, define odata.version = 'v4' in package.json instead"))
        }

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return this._result
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        const promises = []
        const model = await this.cds.load(modelPaths)
        const csn = await this._compileCsn(modelPaths, destGen)
        this._validateCustomServiceHandlers(csn)

        const bundles = this._collectBundles(csn._sources)
        const {
            folders = ['i18n'], file = 'i18n'
        } = this.env.i18n

        if (this.hasCdsEnvOption(BUILD_NODEJS_EDMX_GENERAION, true) || this.hasBuildOption('edmxGeneration', true)) {
            promises.push(this._compileEdmx(model, destGen))
        }

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            promises.push(this._copyNativeContent(src, dest))

            if (!this.task.options.skipManifestGeneration) {
                promises.push(this._writeManifestYaml(), this._writeCfIgnore())
            }

            if (Object.keys(bundles).length > 0) {
                promises.push(this.write(bundles).to(path.join(destGen, folders[0], file + '.json')))
            }
            await Promise.all(promises)
        }
        return this._result
    }

    async clean() {
        // staging build content has already been deleted
        if (this.env.build.target === ".") {
            let buildTargetDir = path.join(this.task.dest, FOLDER_GEN)
            if (DEBUG) {
                this.logger.log(`Deleting build target folder ${buildTargetDir}`)
            }
            await fs.remove(buildTargetDir)
        }
    }

    async _compileCsn(modelPaths, csnDest) {
        const cdsv = require('../../models/cdsv')
        const csn = await cdsv.compile(modelPaths, this.buildOptions.root)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this.write(csn).to(path.join(csnDest, "csn.json"))
        }
        this._result.csn = csn

        return csn
    }

    async _copyNativeContent(src, dest) {
        await super._copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            } else {
                const extname = path.extname(entry)
                const basename = path.basename(entry)
                return (extname !== FILE_EXT_CDS && basename !== FILE_NAME_PACKAGE_JSON)
            }
        })

        // copy relevant content located at project root, e.g. *.js, package.json -> gen/srv
        await super._copyNativeContent(this.buildOptions.root, path.dirname(dest), (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return path.basename(entry) === "handlers"
            }
            const baseName = path.basename(entry)
            if (/\.js$|^package\.json/.test(baseName)) {
                return baseName !== "package.json" || !this.task.options.skipPackageJsonGeneration
            }
        })
    }

    // this is to have a dev fast-turnaround
    async _writeCfIgnore() {
        if (this._isStagingBuild()) {
            const content = `node_modules/\n`
            await this.write(content).to(path.join(path.dirname(this.task.dest), '.cfignore'))
        }
    }

    async _writeManifestYaml() {
        if (!this._isStagingBuild()) {
            return
        }
        // check whether a custom manifest.yaml is already existing
        const existsManifestYaml = await this._existsManifestYaml()
        if (existsManifestYaml) {
            if (DEBUG) {
                this.logger.log('[cds] - skip [manifest.yaml] generation, already existing')
            }
            return
        }

        // check whether we a hdi service binding is required
        const hanaBuildTask = this.buildOptions.tasks.find(task => task.for === BUILD_TASK_HANA)
        if (!hanaBuildTask) {
            if (DEBUG) {
                this.logger.log("[cds] - skip creating [manifest.yaml] - no [hana] build task existing")
            }
            return
        }

        try {
            const [hdiService, applicationName] = await Promise.all([
                getHdiService(this.buildOptions.root, hanaBuildTask.src, this.logger),
                getApplicationName(this.buildOptions.root, this.task.src, "nodejs", this.logger)
            ])

            const hdiServiceName = hdiService ? hdiService.name : getDefaultHdiServiceName(this.buildOptions.root, hanaBuildTask.src);
            const MANIFEST_YAML_CONTENT = `---
applications:
- name: ${applicationName}
  path: .
  memory: 128M
  services:
  - ${hdiServiceName}`

            await this.write(MANIFEST_YAML_CONTENT).to(path.join(path.dirname(this.task.dest), FILE_NAME_MANIFEST_YAML))
        } catch (e) {
            if (e.name === 'YAMLSyntaxError') {
                this.logger.error("Failed to parse [mta.yaml]")
            }
            this.logger.error(e)
        }
    }

    async _existsManifestYaml() {
        return await fs.pathExists(path.join(this.buildOptions.root, FILE_NAME_MANIFEST_YAML)) || await fs.pathExists(path.join(this.task.src, FILE_NAME_MANIFEST_YAML))
    }

    _collectBundles(sources) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = this.cds.localize.bundles4({
            _sources: sources
        })

        if (typeof bundleGenerator === "object" && bundleGenerator.next) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }

        return bundles
    }

    /**
     * Validate custom service handler defined using @impl annotation.
     * Issue warning in case the handler function cannot be resolved.
     * @param {object} csn
     */
    _validateCustomServiceHandlers(csn) {
        const _exclude = (def) => def['@cds.serve.ignore'] || def['@cds.ignore'] || def.kind !== "service" || !def['@impl']
        this.cds.reflect(csn).foreach((def) => {
            if (!_exclude(def)) {
                try {
                    impl4(def, def['@impl'], this.task.src)
                } catch (e) {
                    this.logger.log(format.warn(`Failed to resolve custom service handler. ${e.message}`))
                }
            }
        })
    }
}

module.exports = NodeCfModuleBuilder
