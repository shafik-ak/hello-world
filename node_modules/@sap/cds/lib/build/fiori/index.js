// const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const URL = require('url')
const { getProperty } = require('../util')

const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY, BUILD_TASK_FIORI, CDS_CONFIG_PATH_SEP } = require('../constants')

class FioriAppModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Fiori UI Module Builder", task, buildOptions)
    }

    async prepare() {
        // cache for later use across multiple FioriAppModuleBuilder instances
        const fioriBuildOptions = this.buildOptions.for[BUILD_TASK_FIORI]
        fioriBuildOptions.appModel = new Map()
        fioriBuildOptions.appEdmx = new Map()

        // group tasks that have a common application root folder
        const appTaskGroups = new Map()
        this.buildOptions.tasks.forEach(task => {
            if (task.for === BUILD_TASK_FIORI) {
                const appFolder = path.relative(this.buildOptions.root, task.src).split(CDS_CONFIG_PATH_SEP)[0]
                appTaskGroups.has(appFolder) ? appTaskGroups.get(appFolder).push(task) : appTaskGroups.set(appFolder, [task])
            }
        })

        // merge all model references to resolve the model later on
        const appModelGroups = new Map()
        for (let [appFolder, appTaskGroup] of appTaskGroups.entries()) {
            const appModels = new Set()
            appTaskGroup.forEach(task => {
                if (Array.isArray(task.options.model)) {
                    task.options.model.forEach(model => appModels.add(model))
                }
            })
            appModelGroups.set(appFolder, appModels)
        }

        for (let [appFolder, appModelGroup] of appModelGroups.entries()) {
            this.logger.log(`\n[cds] - building module [${appFolder}] using [${this.name}]`)
            const modelPaths = this.cds.resolve(Array.from(appModelGroup.values()), this.buildOptions)
            if (!modelPaths || modelPaths.length === 0) {
                this.logger.log(`[cds] - no model found`)
                continue
            }
            this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

            //cache model per fiori app root folder
            const model = await this.cds.load(modelPaths)
            fioriBuildOptions.appModel.set(appFolder, model)

            // cache edmx per fiori app root folder
            const edmxIterator = await this.cds.compile.to.edmx(model, { service: "all" })
            const edmxModels = new Map()

            if (edmxIterator) {
                for (let [edmx, { name }] of edmxIterator) {
                    edmxModels.set(name, edmx)
                }
            }
            fioriBuildOptions.appEdmx.set(appFolder, edmxModels)
        }

        return false
    }

    /**
     * This version only creates a odata representation for the 'mainService' data source
     * as defined by the fiori wizard - everything else is currently not supported.
     * Therefore errors are only logged, the build does not fail in case a the service
     * cannot be resolved based on the defined service URI
     */
    async build() {
        const { src, dest } = this.task

        const modelPaths = this._resolveModel()

        this.logger.log(`\n[cds] - building module [${this._stripProjectPaths(src)}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log(`[cds] - no model found`)
            return
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        await this._compileEdmx(src, dest)
        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this._copyNativeContent(src, dest)
        }
    }

    async _compileEdmx(src, dest) {
        const manifestPath = path.join(src, 'webapp', 'manifest.json')
        let manifest

        try {
            manifest = require(manifestPath)
        } catch (error) {
            this.logger.log(`[cds] - UI module does not contain a manifest.json [${this._stripProjectPaths(manifestPath)}], skipping build`)
            return
        }

        const mainService = getProperty(manifest, ['sap.app', 'dataSources', 'mainService'])
        if (!mainService) {
            // no mainService defined - not supported
            this.logger.log(`[cds] - UI module does not have a datasource [mainService], [${this._stripProjectPaths(manifestPath)}], skipping build`)
            return
        }

        const localUri = getProperty(mainService, ['settings', 'localUri'])
        const uri = mainService.uri

        if (!localUri || !uri) {
            this.logger.error(`[cds] - local uri setting missing for data source [mainService], [${this._stripProjectPaths(manifestPath)}]`)
            return
        }

        const appFolder = path.relative(this.buildOptions.root, src).split(CDS_CONFIG_PATH_SEP)[0]
        const model = this.buildOption("appModel").get(appFolder)
        if (!model) {
            this.logger.error(`[cds] - failed to load model for service uri ${uri}, data source [mainService]`)
            return
        }

        const edmx = this._getEdmxForUri(model, appFolder, uri)
        if (!edmx) {
            this.logger.error(`[cds] - failed to resolve service definition for service uri ${uri}, data source [mainService]`)
            return
        }

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            const edmxPath = path.resolve(path.join(dest, 'webapp'), this._strippedUrlPath(localUri))
            return this.write(edmx).to(edmxPath)
        }
    }

    _getEdmxForUri(model, appFolder, uri) {
        const uriSegments = this._strippedUrlPath(uri).split('/')

        // one segment of the URI has to match a service name
        // NOTE: assumption is that the service definition can be resolved - either by
        // - defining corresponding using statement in annotations model or
        // - adding the service module folder to the model option
        let service = this.cds.reflect(model).find(service => uriSegments.find(segment => service.name === segment))

        if (service) {
            const allServices = this.buildOption("appEdmx").get(appFolder)
            if (allServices) {
                return allServices.get(service.name)
            }
        }
        return null
    }

    _strippedUrlPath(urlString) {
        const url = URL.parse(urlString)
        return url.pathname.replace(/^(\/|\\)/, '').replace(/(\/|\\)$/, '') // strip leading and trailing slash or backslash)
    }
}

module.exports = FioriAppModuleBuilder
