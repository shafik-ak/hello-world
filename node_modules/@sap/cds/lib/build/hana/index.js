const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const term = require('../../../bin/utils/term')
const { getApplicationName, getHdiService, getDefaultHdiServiceName } = require('../../utils/mtaUtil')
const { OUTPUT_MODE_RESULT_ONLY, BUILD_OPTION_OUTPUT_MODE, FOLDER_GEN, FILE_EXT_CDS } = require('../constants')

const DEBUG = process.env.DEBUG
const GENERATED_SOURCES_FOLDER = path.join("src", FOLDER_GEN)

const FILE_EXT_CSV = ".csv"
const FILE_EXT_HDBCDS = ".hdbcds"
const FILE_EXT_HDBTABLEDATA = ".hdbtabledata"

const FILE_NAME_HDICONFIG = ".hdiconfig"
const FILE_NAME_HDINAMESPACE = ".hdinamespace"
const FILE_NAME_PACKAGE_JSON = "package.json"
const FILE_NAME_MANIFEST_YAML = "manifest.yaml"

class HanaModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Hana DB Module Builder", task, buildOptions)
        this._result = {
            dest: this.task.dest,
            hdbcds: []
        }
    }

    async build() {
        const { src, dest } = this.task

        const modelPaths = this._resolveModel()

        this.logger.log(`\n[cds] - building module [${this._stripProjectPaths(src)}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return this._result
        }

        this.logger.log(`[cds] - model: ${this._stripProjectPaths(modelPaths).join(", ")}`)

        const model = await this.cds.load(modelPaths)
        await this._compileToHana(model, dest)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            // TODO: option 'mtxOriginalSrc' is only a workaround as native hana content part of reuse modules is still an open issue!
            // The option is set by mtx build_helper - the path refers to the base model: 'node_modules/_base/<dbDir>'
            // All files except *.cds files will be copied from base model folder to '#this.task.dest/src/**'.
            // Note:
            // Native hana artefacts are currently not supported by extensions - thus content copied from the base model cannot overwrite
            // content defined by the extension.
            if (this.task.options.build && this.task.options.build.mtxOriginalSrc) {
                const baseModelDbSrcPath = path.join(this._buildOptions.root, this.task.options.build.mtxOriginalSrc)
                if (await fs.pathExists(baseModelDbSrcPath)) {
                    await this._copyNativeContent(baseModelDbSrcPath, dest)
                }
            }

            await this._copyNativeContent(src, dest)
            await this._writeHdiConfig(dest)
            await this._writeHdiNamespace(dest)

            if (!this.hasBuildOption("skipHdbtabledataGeneration", true)) {
                await this._compileToHdbtabledata(model, dest)
            }
            if (!this.hasBuildOption("skipPackageJsonGeneration", true)) {
                await this._writePackageJson(src, dest)
            }
            if (!this.hasBuildOption("skipManifestGeneration", true)) {
                await this._writeManifestYaml()
                await this._writeCfIgnore()
            }
        }
        return this._result
    }

    /**
     * Deletes any content that has been created in folder '#this.task.dest/src/gen' by some inplace mode.
     * <br>
     * Note: Content created in staging build will be deleted by the #BuildTaskEngine itself.
     */
    async clean() {
        if (this.env.build.target === ".") {
            const srcGenDir = path.join(this.task.dest, GENERATED_SOURCES_FOLDER)
            await fs.remove(srcGenDir)
        }
    }

    /**
     * Copies the entire content of the db module located in the given <src> folder to the folder <dest>.
     * '*.csv' and '*.hdbtabledata' files NOT located in a subfolder 'src' will be copied to '<dest>/src/gen**'
     *
     * @param {string} src
     * @param {string} dest
     */
    async _copyNativeContent(src, dest) {
        const dbSrcDir = path.join(src, "src")
        await super._copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            }
            const extname = path.extname(entry)
            return (extname !== FILE_EXT_CSV && extname !== FILE_EXT_HDBTABLEDATA && extname !== FILE_EXT_CDS && entry !== this.env.build.outputfile) ||
                ((extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && entry.startsWith(dbSrcDir))
        }) || []

        // handle *.csv and *.hdbtabledata NOT located in '<dbSrc>/src/**' folder
        const files = BuildTaskHandler._find(src, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_GEN && entry !== dest
            }
            const extname = path.extname(entry)
            return (extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && !entry.startsWith(dbSrcDir)
        })
        return Promise.all(files.map((file) => {
            return this.copy(file).to(path.join(dest, GENERATED_SOURCES_FOLDER, path.relative(src, file)))
        }))
    }

    /**
     * Generates *.hdbtabledata files in folder '#this.task.dest/src/gen' from *.csv files located in '#this.task.dest/src/**' folder.
     * The generated *.hdbtabledata files will link to their *.csv counterparts using relative links. The *.csv files have either
     * already been defined in the 'src' folder or they have been copied to '#this.task.dest/src/gen/**' folder if they have been
     * created outside 'src' folder. If custom *.hdbtabledata files are found nothing is generated for this particular folder.
     * <br>
     * Note: *.csv and *.hdbtabledata need to be copied to '#this.task.dest/src/gen**' if required before this method is called.
     * In inplace mode dest folder is refering to src folder.
     *
     * @param {object} model compiled csn
     */
    async _compileToHdbtabledata(model, dest) {
        const tabledataDirs = new Set()
        const destSrcDir = path.join(dest, "src")
        const csvFiles = BuildTaskHandler._find(destSrcDir, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true
            }
            const extname = path.extname(entry)
            if (extname === FILE_EXT_HDBTABLEDATA) {
                tabledataDirs.add(path.dirname(entry))
            }
            return extname === FILE_EXT_CSV
        })
        if (csvFiles.length > 0) {
            const targetDir = path.join(dest, GENERATED_SOURCES_FOLDER)
            const csvDirs = csvFiles.map(path.dirname).reduce((dirs, dir) => {
                if (!tabledataDirs.has(dir) && !dirs.includes(dir)) { // exclude any dir where a tabledata is present
                    dirs.push(dir)
                }
                return dirs
            }, [])

            const promises = []
            let tableDatas = await this.cds.compile.to.hdbtabledata(model, { dirs: csvDirs, baseDir: targetDir })
            for (let [tableData, { file, csvFolder }] of tableDatas) {
                // create .hdbtabledata side-by-side if .csv is contained in 'src/gen/**' subfolder
                // otherwise create in 'src/gen'
                let tableDataPath = csvFolder.startsWith(targetDir) ? csvFolder : targetDir
                tableDataPath = path.join(tableDataPath, file)
                this.logger.log(`[cds] - Creating ${this._stripProjectPaths(tableDataPath)}`)
                promises.push(this.write(tableData).to(tableDataPath))
            }
            await Promise.all(promises)
        }
    }

    /**
     * Creates the hana artefacts from the given csn model and writes the files to the folder '<dest>/src/gen'.
     *
     * @param {object} model The compiled csn model
     * @param {string} dest The root destination directory.
     */
    async _compileToHana(model, dest) {
        const promises = []

        // .hdbcds files
        for (let [each, {
            name
        }] of this.cds.compile.to.hana(model)) {
            const relativeDestinationPath = path.join(GENERATED_SOURCES_FOLDER, name + FILE_EXT_HDBCDS)
            this._result.hdbcds.push(relativeDestinationPath)
            const destinationPath = path.join(dest, relativeDestinationPath)
            if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                promises.push(this.write(each).to(destinationPath))
            }
        }

        await Promise.all(promises)
    }

    async _writePackageJson(src, dest) {
        const packageJson = path.join(src, "package.json")
        const exists = await fs.pathExists(packageJson)

        if (DEBUG && exists) {
            this.logger.log(`[cds] - skip create [${this._stripProjectPaths(packageJson)}], already existing`)
        }
        if (this._isStagingBuild() && !exists) {
            const content = await this._readTemplateAsJson(FILE_NAME_PACKAGE_JSON)
            await this.write(content).to(path.join(dest, FILE_NAME_PACKAGE_JSON))
        }
    }

    async _writeHdiConfig(dest) {
        const hdiConfig = path.join(dest, GENERATED_SOURCES_FOLDER, FILE_NAME_HDICONFIG)
        const exists = await fs.pathExists(hdiConfig)

        if (exists) {
            if (DEBUG) {
                this.logger.log(`[cds] - skip create [${this._stripProjectPaths(hdiConfig)}], already existing`)
            }
            return
        }
        const content = await this._readTemplateAsJson(FILE_NAME_HDICONFIG)
        return await this.write(content).to(hdiConfig)
    }

    async _writeHdiNamespace(dest) {
        // see issue #64 - add .hdinamespace file to prevent HDI from adding gen/ folder to the namespace.
        const hdiNamespace = path.join(dest, GENERATED_SOURCES_FOLDER, FILE_NAME_HDINAMESPACE)
        const content = await this._readTemplateAsJson(FILE_NAME_HDINAMESPACE)
        return await this.write(content).to(hdiNamespace)
    }

    // this is to have a dev fast-turnaround
    async _writeCfIgnore() {
        if (this._isStagingBuild()) {
            const content = `node_modules/\n`
            await this.write(content).to(path.join(this.task.dest, '.cfignore'))
        }
    }

    async _writeManifestYaml() {
        if (!this._isStagingBuild()) {
            return
        }
        // check whether a custom manifest.yaml is already existing
        const existsManifestYaml = await this._existsManifestYaml()
        if (existsManifestYaml) {
            if (DEBUG) {
                this.logger.log('[cds] - skip creating [manifest.yaml], already existing')
            }
            return
        }

        try {
            const [hdiService, applicationName] = await Promise.all([
                getHdiService(this.buildOptions.root, this.task.src, this.logger),
                getApplicationName(this.buildOptions.root, this.task.src, "hdb", this.logger)
            ])

            const hdiServiceName = hdiService ? hdiService.name : getDefaultHdiServiceName(this.buildOptions.root, this.task.src);
            const MANIFEST_YAML_CONTENT = `---
applications:
- name: ${applicationName}
  path: .
  no-route: true
  health-check-type: process
  memory: 128M
  services:
  - ${hdiServiceName}`

            this.logger.log("Cloud Foundry service binding required for HDI container.")
            this.logger.log("To create a service use CF command")
            this.logger.log("")
            this.logger.log(term.info(`  cf cs hana hdi-shared ${hdiServiceName}`))
            this.logger.log("")

            await this.write(MANIFEST_YAML_CONTENT).to(path.join(this.task.dest, FILE_NAME_MANIFEST_YAML))
        } catch (e) {
            if (e.name === 'YAMLSyntaxError') {
                this.logger.error("Failed to parse [mta.yaml] - skip manifest.yaml generation")
            }
            this.logger.error(e)
        }
    }

    async _existsManifestYaml() {
        return await fs.pathExists(path.join(this.buildOptions.root, FILE_NAME_MANIFEST_YAML)) || await fs.pathExists(path.join(this.task.src, FILE_NAME_MANIFEST_YAML))
    }

    async _readTemplateAsJson(template) {
        const templatePath = path.join(__dirname, 'template', template)
        return fs.readJSON(templatePath).catch((error) => {
            this.logger.error(`Failed to read template [${templatePath}]`)
            return Promise.reject(error)
        })
    }
}
module.exports = HanaModuleBuilder
