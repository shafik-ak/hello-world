const cds = require ('../cds')
const mockable = {local:1, odata:1, rest:1, messaging:1}

exports.serve = function cds_serve_mocks_in (app) { // NOSONAR

    const autoDeploy = cds.db
    && cds.db.options
    && cds.db.options.kind === 'sqlite'
    && cds.db.options.credentials
    && cds.db.options.credentials.database === ':memory:'

    // FIXME: Needs cleanup
    const mocked=[], once={}, names={}
    for (let {service,csn} of cds.services.skipped || []) {
        const model = csn._sources[0]
        const key = model+':'+service
        if (key in once || (service in cds.services) || (cds.env.requires[service] && cds.env.requires[service].credentials))  continue // skip
        mocked.push (
            cds.serve (service,{mocked:true,skipped:true}) .from (csn) .in (app)
        )
        names[service] = true
        once[key] = true
    }
    for (let [name,each] of Object.entries (cds.env.requires)) {
        const {kind,model,service='all',credentials} = each
        const key = model+':'+service
        if (!model || credentials || (key in once) || (service in names) || (name in names) || !(kind in mockable) || (name in cds.services) || (service in cds.services))  continue // skip
        mocked.push (
            cds.load(model) .then (async (csn) => {
                if (autoDeploy)  await cds.deploy (exports.ignore_persistence_skip(csn)) .to (cds.db,{silent:true})
                return cds.serve (service,{mocked:true}) .from (csn) .in (app)
            })
        )
        once[key] = true
    }
    return Promise.all (mocked)
}

exports.ignore_persistence_skip = (csn) => cds.reflect(csn).foreach('entity', def => {
    delete def['@cds.persistence.skip']
    def['@cds.persistence.table'] == true
        if (csn._xsn) {
        const dx = csn._xsn.definitions[def.name]
            delete dx['@cds.persistence.skip']
    }
})

exports.then = (r,e) => exports.serve (cds.serve.app) .then (r,e)