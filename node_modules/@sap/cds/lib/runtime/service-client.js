const cds = require('../cds'), lib = require('@sap/cds-ql'); lib.inject(cds)

// FIXME: we currently cannot use standard subclassing due to  singleton.js
// and weird and test setups in cds-ql/services
exports.Service = function (ds,o, ___primary) {
    const srv = lib.connect.connect (ds,o, ___primary || o.primary || ds === 'db')
    if (ds) srv.name = ds //> should be done in new Session
    return srv
}
const {disconnect} = lib.Service.prototype
cds.extend (lib.Service.prototype) .with (class {

    tx(...args){ return this.transaction(...args) }

    // interims workarounds --> should be covered in lib.Service
    get entities() { return _model_get (this, 'entities', d => d.kind === 'entity') }
    get types() { return _model_get (this, 'types', d => d.kind === 'type') }
    // only for compat to cds-ql impl --> add console.trace() to find the parts to fix
    set entities(_ignored) {}
    set types(_ignored) {}

    disconnect() {
        cds.emit('disconnect', this)
        return disconnect.call(this)
    }

    on(){} // interims workaround
    emit(){} // interims workaround

})


function _model_get (srv,property,filter) {
    const m = srv.model
    if (!m) throw new Error (`Invalid attempt to access '.${property}' for service '${srv.name}' with no model loaded.`)
    // FIXME: Ugly hack to revert messaging's kind:{...} side effects and to distinguish db services from rest/odata services
    if (srv.options && srv.options.kind && ( srv.options.kind in {rest:1,odata:2} || srv.options.kind.rest || srv.options.kind.odata)) {
        // IMPORTANT: srv.entities uses srv.name as namespace
        return m.childrenOf (srv,filter,property) // this will override srv[property]
    } else {
        // IMPORTANT: db.entities uses model namespace as there is no srv.definition
        return Object.defineProperty (srv, property, {value:m[property]}) [property]
    }
}




exports.Promised = function (srv, promise) {
    if (!promise) {
        // let promise = Promise.resolve(srv)
        // return {__proto__:srv,
        //     then:(r,e) => promise = promise.then(r,e),
        //     catch:(e) => promise = promise.catch(e),
        // }
        return _ready (srv, {__proto__:srv,
            then:(r) => r(srv),
            catch:() => {},
        })
    } else {
        return _ready (srv, {__proto__:srv,
            // then:(r,e) => promise = promise.then(()=>{ if (srv.name) cds.services[srv.name] = srv; return r(srv) },e),
            then:(r,e) => promise = promise.then(()=>r(srv),e),
            catch:(e) => promise = promise.catch(e),
            on: Object.assign ((..._) => promise.then (()=>srv.on(..._)), {
                succeeded: (..._) => promise.then (()=>srv.on.succeeded(..._)),
                failed: (..._) => promise.then (()=>srv.on.failed(..._)),
                resultsOf: (..._) => promise.then (()=>srv.on.resultsOf(..._)),
            }),
            before: (..._) => promise.then (()=>srv.before(..._)),
            after: (..._) => promise.then (()=>srv.after(..._)),
            run: (..._) => promise.then (()=>srv.run(..._)),
            stream: (..._) => promise.then (()=>srv.stream(..._)),
            foreach: (..._) => promise.then (()=>srv.foreach(..._)),
        })
    }
}

function _ready (srv, promised) {
    Object.defineProperty (srv, '_ready', {value:promised,
        configurable:true  	// FIXME: this should not be neccessary --> is likely due to ql.connect.connect singleton!
    })
    return promised
}
