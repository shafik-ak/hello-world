const DEBUG = /\b(y|all|deploy)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
const cds = require('../../lib/cds')
const cwd = process.cwd()

module.exports = function cds_deploy (model) { return {
    async to (db, options) {

      if (!model)  model = cds.env.deploy.models
      if (typeof db === 'string')  db = await cds.connect.to (db,options)
      if (typeof model === 'string')  model = await cds.load (model)
      else if (Array.isArray(model))  model = await cds.load (model)

      await db.deploy (model)

      if (!cds.db)  cds.db = cds.services.db = db
      if (!db.model) {
        db.options.model = model._sources || '<dynamic model>'
        // db.model = cds.linked (model)
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // FIXME: This is horribly ugly, but required to avoid even more ugly hacks in the runtime lib's model handling to kick in
          // db.model['@sql_mapping'] = true //cds.compile.for.odata (model)
          // FIXME: even worse, we need this because of drafts
          db.model = cds.linked (cds.compile.for.odata (model))
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        require('../alpha/_localized') .connect (db.model)
      }

      // fill in initial data...
      const SILENT = options && options.silent || process.env.NODE_ENV === 'test'
      await init_from_js (db,model,SILENT)
      await init_from_csv (db,model,SILENT)
      await init_from_json (db,model,SILENT)

      const {credentials} = db.options, file = credentials && credentials.database
      if (!SILENT) {
        if (file !== ':memory:')  console.log (`/> successfully deployed to ./${file}`)
        else console.log (`/> successfully deployed to sqlite in-memory db`)
      }

      return db
    },
    // continue to support cds.deploy() as well...
    then(n,e) { return this.to (cds.db) .then (n,e) },
    catch(e) { return this.to (cds.db) .catch (e) },
}}


const { path, isdir, isfile, readdir, readFile } = cds.utils

function init_from_js (db, csn, SILENT) {

  if (!csn._sources)  return
  const folders = new Set([ path.resolve('db'), ...csn._sources.map (path.dirname)])
  const inits = []

  for (let each of folders) {
    const file = isfile (path.resolve(each,'init.js'));  if (!file)  continue
    SILENT || console.log (` > initializing database from ${path.relative(cwd,file)}`)  // eslint-disable-line
    let init = require(file);  if (!init)  continue
    if (!init.then && typeof init === 'function')  inits.push (db.run(()=> init(db)))
    else  inits.push (init)
  }

  return Promise.all (inits)
}

function init_from_csv (db, csn, SILENT) {
  return init_from_file (db, csn, SILENT, '/csv', _csvs, (src, entity) => {
      let [ cols, ...rows ] = cds.parse.csv (src)
      return INSERT.into (entity) .columns (cols) .rows (rows) /* global INSERT */
  });

  function _csvs (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.csv'))  return false
    if (/_texts\.csv$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function init_from_json (db, csn, SILENT) {
  return init_from_file (db, csn, SILENT, '/json', _jsons, (src, entity) => {
      let json = JSON.parse (src)
      return INSERT.into (entity) .entries (json)
  });

  function _jsons (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.json'))  return false
    if (/_texts\.json$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function check_lang_file(filename, allFiles) {
  // ignores 'Books_texts.csv/json' if there is any 'Books_texts_LANG.csv/json'
  const basename = path.basename(filename)
  const monoLangFiles = allFiles.filter (file => new RegExp('^'+basename+'_').test (file))
  if (monoLangFiles.length > 0) {
    DEBUG && DEBUG (` - ignoring '${filename}' in favor of [${monoLangFiles}]`)  // eslint-disable-line
    return true
  }
  return false
}

function init_from_file (db, csn, SILENT, folder, filter, insert) { // NOSONAR

  if (!csn._sources)  return
  const folders = new Set
  for (let model of csn._sources) {
    for (let each of [ model+'/../init.js', 'db/init.js' ]) {
        if (isfile (path.resolve(each))) continue
    }
    for (let data of [ '/data', folder ]) {
      for (let each of [ model+data, model+'/..'+data ]) {
        let folder = path.resolve (each)
        if (isdir (folder))  folders.add(folder)
      }
    }
  }

  if (folders.size > 0)  return db.acquire() .then (tx => tx.begin()
    .then (()=> Promise.all ([...folders].map (folder => _init (folder,tx))))
    .then (()=> tx.commit())
    .then (()=> db.release (tx))
  )

  function _init (folder, tx) {
    return new Promise ((_done, _reject) => readdir (folder, (e,files) => { _error(e)
      let n=0
      for (let each of files.filter (filter)) {
        let entity = _entity4 (each.replace(/-/g,'.').slice(0, -path.extname(each).length));  if (!entity) {
          DEBUG && DEBUG (` - warning: ${each} not in model`)  // eslint-disable-line
          continue
        }
        let file = path.join(folder,each)
        ++n; readFile (file, 'utf8', (e,src)=>{ _error(e)
          SILENT || console.log (` > filling ${entity.name} from ${path.relative(cwd,file)}`)  // eslint-disable-line

          tx.run (insert(src, entity)) .then (()=> --n || _done()) .catch (_reject)
        })
      }
      if (!n) _done() //> there were no matching csv files -> fulfill Promise
    }))
  }

  function _entity4 (name) {
    const entity = csn.definitions [name]
    if (!entity) {
      if (/(.+)_texts_?/.test (name)) { // 'Books_texts', 'Books_texts_de'
        const base = csn.definitions [RegExp.$1]
        if (base)  return _entity4 (base.elements.texts.target)
      }
      return
    }
    if (entity.query) {
      let {SELECT} = entity.query
      if (SELECT && !SELECT.columns && SELECT.from.ref && SELECT.from.ref.length === 1) {
        return csn.definitions [SELECT.from.ref[0]]
      }
    }
    return entity
  }

  function _error(e) {
    if (e)  throw e
  }

}
/* eslint no-console: off */
