const DEBUG = /\b(y|all|alpha|_compositions)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
const cds = require('../cds')
const _parent = '_parent'

///////////////////////////////////////////////////////////
//   cds-compiler part
//

// Rewrites DDL output of 2sql
const unfold = function _unfold_compositions (csn) { // NOSONAR

    const xsn = csn._xsn
	cds.linked(csn) .forall ('Composition', (c) => {
        if (c.name === 'texts' || c.is2many && !c.on) {
            _assign (c, '@odata.contained', true)
            if (!c.on)  ; //_add_parent_to_target_of (c)
            else _avoid_not_null_error_by_compiler (c)
        }
	})
    return csn

    function _assign (def, p, val) {
        def[p] = val
        if (xsn)  _xsd4(def)[p] = {val}
    }

    function _xsd4 (d) {
        if (d.parent) return _xsd4 (d.parent) .elements [d.name]
        else return xsn.definitions [d.name]
    }

    // eslint-disable-next-line no-unused-vars
    function _add_parent_to_target_of (c) {
        if (c.parent.name.match(/service/i))  return
        if (_parent in c._target.elements)  return
        const p = c._target.elements[_parent] = { name:_parent, type:'cds.Association', target:c.parent.name, _target:c.parent, notNull:true}
        c.on = [{ref:[ c.name, p.name ]}, '=', {ref:['$self']}]
        if (xsn) {
            // console.warn (c.parent.name, c.name)
            _xsd4(c._target).elements [_parent] = cds.parse(`
                entity ${c._target.name} { ${_parent} : Association to ${c.parent.name} not null; }
                entity ${c.parent.name} { key ID : UUID; }
            `)._xsn.definitions[c._target.name].elements[_parent]
            _xsd4(c).on = cds.parse (`
                entity Foo { ${c.name} : Composition of many Bar on ${c.name}.${_parent} = $self; key ID:UUID; }
                entity Bar { ${_parent} : Association to Foo; }
            `)._xsn.definitions.Foo.elements[c.name].on

            // const x = _xsd4(c._target).elements[_parent] = {
            //     kind: 'element', type: Association,
            //     name: { id: p.name, absolute: c.target, element: p.name },
            //     target: { path: [ { id: c.parent.name} ], scope: 0, _artifact: _xsd4(c.parent) },
            //     notNull: { val:true },
            //     // foreignKeys: { ID: {
            //     //     kind: 'key',
            //     //     name: { id:'ID', $inferred: 'keys', absolute: c.target, element: p.name+'.ID' },
            //     //     targetElement: { path: [{ id:'ID' }]},
            //     //     calculated: true, $inferred: 'keys', indexNo: 1
            //     // }},
            //     // implicitForeignKeys: true
            // }
            // x._finalType = x
            // x.target._artifact = _xsd4(c.parent)._artifact
            // x.type._artifact = _xsd4(c).type._artifact
        }
    }

    function _avoid_not_null_error_by_compiler (c) {
        if (c.on && c.on[1] === '=') {
            const [x, , y] = c.on;
            const reverse = c._target.elements[x.ref[0] === c.name ? x.ref[1] : y.ref[1]];
            _assign (reverse, 'notNull', true);
        }
    }
}


// feature-toggled exports
module.exports = !cds.env.features.compositions ? { unfold: x=>x } : { unfold }
