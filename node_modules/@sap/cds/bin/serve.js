module.exports = Object.assign ( serve, {
    options: [ '--from', '--to', '--at', '--with' ],
    flags: [ '--projects', '--watch', '--in-memory', '--in-memory?', '--mock', '--with-mocks' ],
    shortcuts: [ undefined, '-2', '-a', '-w', '-p' ],
    help: `
# SYNOPSIS

    *cds serve* [all] [<options>]
    *cds serve* --projects <projects> [<options>] [--watch]
    *cds serve* <services> --from <model> [<options>]
    *cds serve* <models> [<options>]

    Starts http servers which load service definitions from cds models to
    automatically construct respective service providers and bind them
    to endpoints to serve incomming requests.

    The first variant starts the server in the current working directory and
    fetches for models in these locations,  given order:
    _app/*_, _srv/*_, _services.cds|csn_.

    The second variant runs _cds serve all_ for the specified projects, each
    by spawning a worker process with _cwd = each_.

    The third and fourth variants load the specified models only, with the
    third variant allowing to restrict the server to a _single service_ in
    case the model(s) contain more than one service definition.


# OPTIONS

    *-p | --projects* <projects> [--watch]

        Runs _cds serve all_ for the specified projects, each by spawning a
        worker process with _cwd = each_. Add option *--watch* to restart
        the server upon changes in code or models.
        You can use these shortcuts:

        *cds run*    =  cds serve --projects
        *cds watch*  =  cds serve --projects --watch --with-mocks --in-memory?

    *-f | --from* <model>
    *-w | --with* <impl>
    *-a | --at* <endpoint>
    *-2 | --to* <protocol>

        Use these options when serving _single services_ to name the model(s)
        to load service definitions from, the endpoint to bind the service
        to, the protocol (i.e. _fiori_, _odata_, or _rest_) to serve and optionally
        which implementation to use (i.e. a _.js_ file).

    *--mock*

        Use this option to launch a _single service_ for a model you imported
        from an external source, e.g. from an S/4 system, in a mock server.
        In addition to constructing the service provider, this will bootstrap
        a transient _in-memory_ database, filled with tables corresponding
        to the signatures of the service's exposed entities.

    *--with-mocks*

        Use this in combination with the variants serving _multiple services_
        to start in-process mock services for all required services configured
        in _package.json#cds.requires_ which don't have external bindings
        in the current process environmemt.

    *--in-memory[?]*

        Automatically adds a transient in-memory database bootstrapped on
        each (re-)start in the same way *cds deploy* would do based on defaults
        or configuration in _package.json#cds.requires.db_. Add a question
        mark to apply a more defensive variant which respects the configured
        database, if any, and only adds an in-memory db if no persistent one is
        configured.

        Requires a sqlite driver to be installed, e.g. _npm i sqlite3_.

# EXAMPLES

    *cds serve*
    *cds serve* all
    *cds serve* CatalogService *--from* app/
    *cds serve* CatalogService *--from* srv/ *--at* /cats *--to* rest
    *cds run* --in-memory?
    *cds watch*

`})

// the original one, before a chdir
const process_cwd = process.cwd(), path = require('path')


/**
 * The main function which dispatches into the respective usage variants.
 */
function serve (targets, options={}) { // NOSONAR

    const projects = (options.projects || options.watch) && targets
    if (projects) {
        if (projects.length > 1) { // running multiple projects
            const cluster = require ('cluster')
            if (cluster.isMaster) { // fork workers...
                return projects.map ((p,i)=>{
                    console.log (`[cds] - forking worker for '${p}' ...`)
                    return cluster.fork ({ PROJECT:p, PORT: 'PORT' in process.env ? process.env.PORT : i+4004 })
                })
             } else { // ... that's in a worker
                process.chdir (process.env.PROJECT)
            }
        }
        else if (projects[0]) { // running a single project
            process.chdir (projects[0])
        }
        targets = ['all']
    }

    // cds run --watch?
    if (options.watch)  return _watch (undefined/*pwd was set above */, options)

    // a single local run
    return _serve (targets, options)
}


/**
 * The's the core function to serve services for a single project run from cwd
 */
async function _serve (models, options={}) { // NOSONAR

    // IMPORTANT: never load any @sap/cds modules before the chdir happened!
    const cds = require('../lib/cds')
    _prepare_trace (cds)

    // import service bindings, and export bindings for provided services when loaded
    await cds.service.bindings.import()
    cds.once ('listening', ({url})=> {
        cds.service.bindings.export (cds.service.providers, url)
    })

    // bootstrap in-memory db if applicable
    await _in_memory_db (cds, models, options)

    // start server.js, which cds.serve's own services
    const server = await require('../server.js') .launch (models,options)

    // optionally start mocks for required services
    if (options['with-mocks'])  await require('../lib/runtime/mocks')

    // activate custom service implementations after all services are set up
    if (options['with-mocks'])  cds.serve.activate (cds.service.providers)

    // quit if, after all, there are no services to be served
    if (cds.service.providers.length === 0)  return console.error (`No service models found in '${models}'`)

    // we are finally done -> signal that to everybody
    const url = ()=> `http://localhost:${server.address().port}`
    if (server.listening) cds.emit('listening',{ server, url: url() })
    else server.on('listening', ()=>cds.emit('listening', { server, url: url() }))

    // add fiori preview links to default index.html
    require('../lib/utils/app/fiori-preview').fiorify (cds.serve.app)
}


function _prepare_trace (cds) { // NOSONAR

    const _local = file => path.relative (process_cwd,file)
    const _timer = '[cds] - launched in'
    console.time (_timer)
    console.log()

    // print information about each connected service
    cds.on ('connect', ({name,options:{kind,model,credentials}})=>{
        const spec = credentials && credentials.database || model || name
        // FIXME: Ugly hack to revert messaging's kind:{...} side effects
        if (typeof kind === 'object') for (let first in kind) { kind = first; break }
        console.log (`[cds] - connect to datasource - ${kind}:${spec}`)
    })

    // print information about each provided service
    cds.on ('serve', ({name,path,options:o,$impl}) => {
        const _impl = !$impl ? '' : ' - with impl: ' + _local($impl._source)
        const serving = o.mocked ? 'mocking' : 'serving'
        console.log (`[cds] - ${serving} ${name} at ${path}${_impl}`)
    })

    // collect and list _sources unless in cds.watch mode
    if (!cds.watch) {
        const _sources = []
        cds.on ('served', ({model:m}) => _sources.push (...m._sources))
        cds.once ('served', ()=> _sources.push(' ------- '))
        cds.once ('listening', ()=>{
            let n = _sources.length; if (_sources[n-1] === ' ------- ')  _sources.pop()
            let cwd = process.cwd(), base = path.relative (process_cwd, cwd)
            let all = _sources.map (file => file[0] === ' ' ? file : path.join(base,path.relative(cwd,file)))
            console.log (`[cds] - service definitions loaded from:\n\n  ${all.join('\n  ')}\n`)
        })
    }

    // print info when we are finally on air
    cds.on ('listening', ({url})=>{
        console.timeEnd (_timer)
        console.log (`[cds] - server listening on ${url} ...`)
        if (process.stdin.isTTY)  console.log (`[ terminate with ^C ]\n`)
    })

    return cds
}


/**
 * Bootstrap in-memory db if applicable
 */
async function _in_memory_db (cds, models, options) {
    const {kind,credentials={}} = cds.env.requires.db || {}
    const _in_memory = (
        options['in-memory'] || credentials.database === ':memory:' ||
        options['in-memory?'] && !kind
    )
    if (!_in_memory) return
    if (!models || models[0] === 'all')  models = cds.env.deploy.models
    if (options.mock || options['with-mocks']) {
        // also deploy all entities for mocked services, i.e. ignore @cds.persistence.skip
        const mocked = require('../lib/runtime/mocks').ignore_persistence_skip
        models = mocked (await cds.load (models))
    }
    return cds.deploy (models) .to ('sqlite::memory:')
}



function _watch (...args) {
    try { return require('@sap/cds-dk/bin/watch')(...args) }
    catch (e) { if (e.code !== 'MODULE_NOT_FOUND')  throw e }
    console.error (`

    cds run --watch has moved... please install '@sap/cds-dk' and use
    'cds watch' instead as follows:

    npm i -g @sap/cds-dk
    cds watch

    `)
}

/* eslint no-console:off */
