#!/usr/bin/env node
const DEBUG = /\b(y|all|cli)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
module.exports = require('../lib/require') .local (module, '@sap/cds/bin/cds', CLI)
if (!module.parent)  module.exports()

function CLI (cmd = process.argv[2], ...args) {

  // ensure we are the first to load @sap/cds locally
  const cds = require('../lib/cds')

  const Shortcuts = {
    i: 'init',
    c: 'compile',
    m: 'import',
    s: 'serve',
    e: 'env',
    b: 'build',
    d: 'deploy',
    w: 'watch',
    v: 'version', '-v':'version', '--version':'version',
    r: 'repl', '-r':'repl', '-e':'eval',
    h: 'help', '?':'help', '-?':'help', '--help':'help',
  }

  if (cmd in Shortcuts)  cmd = Shortcuts [cmd]
  if (!args.length)  args = process.argv.slice(3)

  // exits to help and version...
  const help = require('./help') .with (_loadTask, Shortcuts)
  if (!cmd && process.stdin.isTTY)  return help()
  if (args.some(a => Shortcuts[a]==='help'))   return help ([cmd])

  // load the task to run...
  const defaultTask = () => { cmd && args.unshift(cmd); return _requireTask('./compile') }
  const task = _loadTask (cmd, defaultTask)

  // prepare arguments and options for specific command
  const {argv, options} = require('./utils/cli').parseArgs (task, args)

  // add error handlers...
  if (cmd !== 'repl')  {
    const { logMessages: log } = require ('./utils/cli')
    const handler = process.env.DEBUG || /run|serve/.test (cmd)
      ? err => { console.error(err); process.exit(1) }
      : err => { log(err);  process.exit(1) }
    process.on('uncaughtException', handler)
    process.on('unhandledRejection', handler)
    // TODO REVISIT --> see comments in cdsv.js
    const messages = []
    cds.on ('compilationMessage', (m) => messages.push (m))
    process.once('beforeExit', () => log (messages))
  }

  // finally run the command
  const result = task.call ({help}, argv, options)
  if (result && Reflect.has(result,'then')) { // handle promise results
    result.then(res => { if (parseInt(res)) process.exitCode = res })// interpret returned int as exit code
  }

  process.on ('SIGTERM', ()=>{ console.log(); process.exit() })
  process.on ('SIGHUP', ()=>{ console.log(); process.exit() })
  process.on ('SIGINT', ()=>{ console.log(); process.exit() })

}

function _loadTask(cmd, _default=()=>{}) {
  const { join, dirname } = require ('path')
  let task // try fetching from ...
  // 1) task function passed from e.g. cds-dk
  if (typeof cmd === 'function') { task = cmd; cmd = '<function>' }
  // 2) cds cds --> means: cds compile cds (would otherwise recursively load ./cds.js)
  if (!task && /^(.\/)?cds$/i.test(cmd))  task = _default()
  // 3) locally installed @sap/cds-dk
  if (!task)  task = _requireTask ('@sap/cds-dk/bin/'+ cmd)
  // 4) locally installed @sap/cds
  if (!task)  task = _requireTask ('./'+ cmd)
  // 5) main module, which could be cds-dk sources (not starting with @sap/ !)
  if (!task)  task = _requireTask (join (dirname (require.main.filename), cmd))
  // 6) globally installed @sap/cds-dk
  if (!task)  task = _requireTask ('@sap/cds-dk/bin/'+ cmd, true)
  // 7) use cmd = 'compile' as default... --> Note: leads to errors like
  if (!task)  task = _default()
  return task
}

function _requireTask (file, global=false) {
  try {
    if (global) {
      const paths = []
      const { join } = require ('path')
      // if started from an npm script, add npm global module dir (the `npm run bookshop` case)
      const { npm_config_prefix } = process.env
      if (npm_config_prefix)  paths.push (npm_config_prefix, join(npm_config_prefix, 'lib'))
      file = require.resolve (file, { paths })
    }
    const task = require (file)
    DEBUG && DEBUG (`[cli] Loaded ${global ? 'global ':''}task from '${require.resolve (file)}'`)
    return task
  } catch(e) {
      if (e.code !== 'MODULE_NOT_FOUND')  throw e
      DEBUG && DEBUG (`[cli] Failed to load ${global ? 'global ':''}task from '${file}' in ${__dirname}`)
    }
}

/* eslint no-console:off */
