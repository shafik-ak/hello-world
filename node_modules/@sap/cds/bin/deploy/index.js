module.exports = Object.assign(deploy, {
  options: ['--to', '--tunnel-address'], flags: ['--no-save', '--auto-undeploy'],
  shortcuts: ['-2'],
  help: `
# SYNOPSIS

    *cds deploy* [ <model> ] [ <options> ]

    Deploys the given model to a database. If no model is given it looks up
    according configuration from _package.json_ or _.cdsrc.json_ in key
    _cds.requires.db_.  Same for the database.

    Supported databases: sqlite, hana


# OPTIONS
    *-2* | *--to* <database> [ : <database specific parameter> ],
      where <database> is 'sqlite' or 'hana', <database specific parameter>
      can be a path to the database file (sqlite) or the service name (hana).

    *--no-save*
      Do not modify the package.json file.

    *--auto-undeploy* (beta feature)
      Tell HDI deployer to automatically undeploy deleted resources

    *--tunnel-address* (beta feature)
      Deploy through the given address (host:port) rather than the original
      database address.  The tunnel must have been opened before, e.g. using 'cf ssh'.

# EXAMPLES
    cds deploy --to sqlite:db
    cds deploy --to hana:myService --auto-undeploy

`})

const cds = require('../../lib/cds')

async function deploy ([_model], options) { // NOSONAR

  const { 'to':url, 'no-save':no_save = cds.env.deploy.no_save } = options
  if (!url && !cds.env.requires.db)  throw new Error(
    `Please specify a database kind or url, e.g.:

    cds deploy --to sql
    cds deploy --to sqlite
    cds deploy --to sqlite:db/my.db
    `)

  const conf = cds.env.requires.db || {}
  const [,_kind,_db] = /(\w+)?(?::(.*))?/.exec(url||'')
  const kind = _kind || conf.use || conf.kind

  try {
    var deployer = require ('./to-'+kind)
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error(`Didn't find a deployer module for '${kind}'`)
    }
  }
  try {
    await deployer.deploy (_model, _db, options)
    if (kind === 'hana')  return // REVISIT: the hana deployer is a bit special
    if (url && !no_save)  await updata_package_json (_kind, _model, _db)
  } catch (e) {
    if (e.code === 'MODEL_NOT_FOUND') {
      throw new Error ('Please specify a data model or configure one in package.json > cds.requires.db.model')
    } else throw e
  }
}


async function updata_package_json (kind, model, database) {
  const {fs,path,promisify} = cds.utils, read = promisify (fs.readFile), write = promisify (fs.writeFile)
  const package_json = path.resolve ('package.json'), exists = fs.isfile (package_json)
  const conf = exists ? JSON.parse (await read (package_json)) : {}
  const requires = ['cds','requires'] .reduce ((p,n)=>p[n] || (p[n]={}), conf)
  // IMPORTANT: cds deploy can work witj defaults for models, but cds.connect can't!
  if (!model) {
    const exists = cds.utils.fs.existsSync
    model = cds.env.requires.db && cds.env.requires.db.model
    || cds.env.deploy.models.filter (exists)
  }
  requires.db = cds.env.requires.db = { kind, model }
  if (database)  requires.db.credentials = { database }
  await write (package_json, JSON.stringify(conf,null,'  '))
  console.log (` > ${ exists ? 'updated' : 'created' } ./package.json`)
}

/* eslint no-console: off */
