const Where = require('./Where')
const { invalidFunctionArgumentError } = require('../utils/errors')

const fnChain = Symbol.for('sap.cds.fnChain')

/**
 * UPDATE statement updates values or rows from a specific table.
 * @extends {Where}
 */
class Update extends Where {
  constructor () {
    super('UPDATE')
  }

  static entity (entity) {
    const cqn = new Update()
    cqn[fnChain] = cqn[fnChain].concat('()') // UPDATE.entity() is not exposed but UPDATE()
    cqn.UPDATE.entity = Where._isEntity(entity, 'UPDATE()')

    return cqn
  }

  /**
   * Sets the values that should be updated
   *
   * @example
   * UPDATE('Authors').set({NAME: 'Jon Doe', STOCK: 123})
   * @param {object} valueObject contains the properties that should be updated
   * @returns {Object} UPDATE statement
   * @throws Error - If no or invalid input parameter provided
   */
  set (valueObject) {
    this[fnChain] = this[fnChain].concat('.set()')

    const checkIsInvalid = this._isInvalidValueObject(valueObject)
    if (checkIsInvalid.status) {
      throw invalidFunctionArgumentError(this[fnChain], checkIsInvalid.data)
    }

    this.UPDATE.data = this._convertToCqnObject(valueObject)
    return this
  }

  /**
   * Sets the values that should be updated
   *
   * @example
   * UPDATE('Authors').set({NAME: 'Jon Doe', STOCK: 123})
   *
   * @param {object} valueObject contains the properties that should be updated
   */
  with (valueObject) {
    this[fnChain] = this[fnChain].concat('.with()')
    return this.set(valueObject)
  }

  _convertToCqnObject (valueObject) {
    const cqnObj = {}
    for (const key in valueObject) {
      cqnObj[key] = this._generateValObj(valueObject[key], key)
    }
    return cqnObj
  }

  _generateValObj (value, key) {
    if (value === null || value === undefined) {
      return { val: null }
    }

    if (value instanceof Buffer) {
      return { val: value }
    }

    if (['-=', '+=', '*=', '/=', '%='].includes(Object.keys(value)[0])) {
      const op = Object.keys(value)[0]
      const val = value[op]
      return { xpr: [{ ref: [key] }, op.substring(0, 1), { val: val }] }
    }

    if (value['=']) {
      return { ref: [value['=']] }
    }

    // value.pipe is a stream indicator
    if (!Array.isArray(value) && typeof value === 'object' && typeof value.pipe !== 'function') {
      const cqnObj = {}
      for (const key in value) {
        cqnObj[key] = this._generateValObj(value[key], key)
      }
      return cqnObj
    }

    return { val: value }
  }

  _isInvalidValueObject (valueObject) {
    if (!valueObject || typeof valueObject !== 'object' || Array.isArray(valueObject)) {
      return { status: true, data: valueObject }
    }

    const invalidEntries = {}

    for (const key of Object.keys(valueObject)) {
      if (
        valueObject[key] === undefined ||
        (valueObject[key] &&
          typeof valueObject[key] === 'object' &&
          !(valueObject[key] instanceof Buffer) &&
          !Array.isArray(valueObject[key]) &&
          Object.keys(valueObject[key]).length === 0)
      ) {
        invalidEntries[key] = valueObject[key]
      }
    }

    if (Object.keys(invalidEntries).length !== 0) {
      return { status: true, data: invalidEntries }
    }

    return { status: false }
  }

  valueOf () {
    return `UPDATE ${Update._quoteElement(this.UPDATE.entity)} `
  }
}

module.exports = Update
