const Pool = require('./Pool')
const Transaction = require('./Transaction')
const { getOptions, getDefaultMainKind } = require('./options')
const { resolve } = require('../utils/thenable')
const cds = require('../cds')

const MODEL = Symbol.for('sap.cds.model')

/**
 * Service to acquire db connection clients.
 */
class Service {
  /**
   * Creates a Service according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {String} [datasource] - name of datasource
   * @param {Object} [options] - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.idleTimeoutMillisForPools] - The time interval in ms until an idle pool is
   * evicted.
   * Default 60000 ms (1 min).
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * Default 10000 ms (10 s).
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * Defaults to half of options.pool.min, but at least 2.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * Default 30000 ms (30 s).
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * Default 480000 ms (8 min).
   * @param {Object} [options.model] - The to be used model.
   * @param {Object|String} [options.kind] - The to be used kind(s).
   * @param {Object} [options.service] - if options.model, the to be used service name.
   * @param {Object} [options.credentials] - Credentials how to connect with a client
   * @param {string} [options.credentials.host] - Address to the db
   * @param {string} [options.credentials.port] - Port for db
   * @param {string} [options.credentials.user] - Username for authentication
   * @param {string} [options.credentials.password] - Password for authentication
   * @param {boolean} [options.multiTenant] - true, if mt is active
   */
  constructor (datasource, options) {
    this.options = getOptions(datasource, options)
    this._addTenantManagers()

    if (this.options.model && typeof this.options.model === 'object' && !Array.isArray(this.options.model)) {
      // we assume that linked detects if csn is linked already
      this._linkServiceModel(this.options.model)
    }
    this._includePackageMethods(datasource)

    this._pools = new Map()

    // Create cache for accessing entities
    Object.defineProperties(this, { _entities: { value: {} } })
  }

  _addTenantManagers () {
    if (this.options.multiTenant === true) {
      if (!this._tenantManagers) {
        this._tenantManagers = new Map()
        for (const [mainKind, _package] of this.options.packages) {
          const TenantManager = _package.TenantManager
          if (TenantManager) {
            this._tenantManagers.set(mainKind, new TenantManager(this.options.connectionOptions.get(mainKind)))
          }
        }
      }
    }
  }

  _includePackageMethods (datasource) {
    for (const [, _package] of this.options.packages) {
      if (_package.serviceFunctions) {
        Object.defineProperties(this, {
          create: { value: _package.serviceFunctions.create, writable: true },
          read: { value: _package.serviceFunctions.read, writable: true },
          update: { value: _package.serviceFunctions.update, writable: true },
          delete: { value: _package.serviceFunctions.delete, writable: true },
          insert: { value: _package.serviceFunctions.insert, writable: true }
        })
      }

      if (_package.httpFunctions) {
        Object.defineProperties(this, {
          get: { value: _package.httpFunctions.get, writable: true },
          post: { value: _package.httpFunctions.post, writable: true },
          put: { value: _package.httpFunctions.put, writable: true },
          patch: { value: _package.httpFunctions.patch, writable: true },
          delete: { value: _package.httpFunctions.delete, writable: true }
        })
      }

      if (_package.messagingFunctions) {
        const boundMessagingFunctions = _package.messagingFunctions.bind.call(this, datasource, this.model)
        Object.defineProperties(this, {
          removeAllListeners: { value: _package.messagingFunctions.removeAllListeners, writable: true },
          putQueue: { value: _package.messagingFunctions.putQueue, writable: true },
          deleteQueue: { value: _package.messagingFunctions.deleteQueue, writable: true },
          addSubscription: { value: _package.messagingFunctions.addSubscription, writable: true },
          messagingOptions: { value: boundMessagingFunctions.messagingOptions, writable: true },
          emit: { value: boundMessagingFunctions.emit, writable: true },
          on: { value: boundMessagingFunctions.on, writable: true }
        })
      }
    }
  }

  _linkServiceModel (csn) {
    if (csn) {
      const model = cds.linked(cds.unfold.for.odata(csn))
      this._useReflectedModel(model)
    }
  }

  _useReflectedModel (model) {
    this.model = model
    const services = this.model.all('service')
    if (services.length === 1) {
      this.entities = this.model.childrenOf(services[0], child => child.kind === 'entity')
    } else if (this.options.service) {
      this.entities = this.model.childrenOf(
        services.find(srv => srv.name === this.options.service),
        child => child.kind === 'entity'
      )
    } else {
      this.entities = this.model.entities
    }
    for (const [, connectionOption] of this.options.connectionOptions) {
      if (!connectionOption.credentials) {
        connectionOption.credentials = {}
      }
      connectionOption.model = model
    }
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} [context] - Context object
   * @param {string} [context.user.id] - The user name for the db connection
   * @param {string} [context.user.locale] - The language identifier
   * @param {string} [context.attr.token] - Full JWT from (HTTP) request
   * @param {string} [context.attr.identityZone] - GUID of a tenant
   * @param {string} [mainKind] - Kind to be acquired (for compound services)
   * @returns {Promise.<Object>} Promise, that resolves with result object if db client acquired successfully
   * @returns {Promise} Promise, that rejects with error if no kind or tenantId provided
   */
  async acquire (context = {}, mainKind = null) {
    mainKind = mainKind || getDefaultMainKind(this.options.packages)

    const tenantId = this._getTenantId(context.attr)
    const poolKey = `${tenantId}-${mainKind}`

    // Fallback in case of first call, or pool has been invalidated
    let pool = this._pools.get(poolKey) || this._createPool(poolKey, tenantId, mainKind)

    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      pool = await pool
    }

    return pool.acquire(context, this._getModel(context))
  }

  _getTenantId ({ identityZone } = {}) {
    if (this.options.multiTenant) {
      if (identityZone) {
        return identityZone
      }

      throw new Error('No valid "GUID" of a tenant provided')
    }

    return 'singleTenant'
  }

  _getModel (context) {
    // Hack if deploy is called, then no model must be loaded.
    if (this.options.model && this.hasOwnProperty('model')) {
      return this.model
    }
    return context[MODEL]
  }

  /**
   * Starts or joins an already started transaction for the given context.
   * @param {Object} [context] - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   * @returns Object
   */
  transaction (context = {}) {
    if (!context._) {
      context._ = {}
    }

    if (!context._.shared) {
      context._.shared = {}
    }

    if (!context._.shared.connections) {
      context._.shared.connections = new Map()
    }

    // only one transaction per session in a specific context
    return context._.shared.connections.get(this) || this._createNewTransaction(context)
  }

  /**
   * Provide large binary stream for a given query.
   *
   * @param {string|object} query - SELECT SQL string or SELECT CQN object.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @param {Object} [context]
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with stream if successful or rejects with error if not.
   * Result object can be undefined if no rows obtained.
   */
  stream (query, values, context = {}, mainKind = null) {
    return this.acquire(context, mainKind).then(client => {
      return client.stream(query, values).then(result => {
        return this.release(client).then(() => {
          return result
        })
      })
    })
  }

  // TODO: Instead of a getter, use a function getTenantManager(mainKind) to support multiple tenantManagers
  /**
   * Getter for TenantManager
   * @returns {TenantManager}
   */
  get tenantManager () {
    if (this._tenantManagers.size === 1) {
      for (const [, tenantManager] of this._tenantManagers) {
        return tenantManager
      }
    }
  }

  _createNewTransaction (context) {
    const transaction = new Transaction(this, context)
    context._.shared.connections.set(this, transaction)
    return transaction
  }

  _handlePoolEviction (pool) {
    if (pool.noClientsBorrowed) {
      return this._disconnect(pool, pool._name)
    }
  }

  _clearPoolTimeout (pool) {
    if (pool._timeout !== undefined) {
      clearTimeout(pool._timeout)
      delete pool._timeout
    }
  }

  _setPoolTimeout (pool) {
    if (this.options.pool.idleTimeoutMillisForPools > 0) {
      this._clearPoolTimeout(pool)

      pool._timeout = setTimeout(() => {
        this._handlePoolEviction(pool)
      }, this.options.pool.idleTimeoutMillisForPools)
    }
  }

  /**
   * Create a pool instance if a test connect succeeds.
   * @param poolKey
   * @returns {*|Function|Promise<T>}
   * @private
   */
  _createPool (poolKey, tenantId, mainKind) {
    const ready = this._getAndCheckCredentials(tenantId, mainKind)
      .then(options => {
        return this._createPoolInstance(poolKey, this.options.packages.get(mainKind).Client, options)
      })
      .catch(err => {
        // Remove pool if multitenancy and crash the node instance on purpose otherwise
        if (this.options.multiTenant) {
          this._pools.delete(poolKey)
        } else {
          setImmediate(() => {
            throw err
          })
        }

        // Throw again or other errors will occur until next tic is reached.
        throw err
      })

    this._pools.set(poolKey, ready)

    return ready
  }

  _createPoolInstance (poolKey, Client, connectionOptions) {
    const pool = new Pool(poolKey, Client, connectionOptions)
    pool._name = poolKey
    this._pools.set(poolKey, pool)

    return pool
  }

  /**
   * Load credentials from instance manager if needed.
   * Test connect in any case.
   * @param {string} tenantId
   * @returns {Object}
   * @private
   */
  _getAndCheckCredentials (tenantId, mainKind) {
    if (this.options.multiTenant) {
      return this._tenantManagers
        .get(mainKind)
        .get(tenantId)
        .then(credentials => {
          // Get defaults from general options; mostly pool options are relevant
          const options = Object.assign({}, this.options.connectionOptions.get(mainKind))
          options.credentials = Object.assign({}, options.credentials || {}, credentials)
          options.pool = Object.assign({}, options.pool)

          const _package = this.options.packages.get(mainKind)
          // A client might not provide the "options" function
          if (_package && _package.options) {
            _package.options(options)
          }

          return this._testConnection(options, _package.Client)
        })
    }

    return this._testConnection(
      this.options.connectionOptions.get(mainKind),
      this.options.packages.get(mainKind).Client
    )
  }

  /**
   * Test the credentials by doing a test connect.
   * @param {Object} connectionOptions
   * @returns {Promise<Object>}
   * @private
   */
  async _testConnection (connectionOptions, Client) {
    if (!Client) {
      return resolve(connectionOptions)
    }

    const client = new Client(connectionOptions)
    await client.connect()
    await client.end()
    return connectionOptions
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._destroyRelease('release', client).then(() => {
      // only remove poolKey for successful releases, otherwise .destroy will fail
      delete client._poolKey
    })
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    const onFinally = () => {
      delete client._poolKey
    }
    return this._destroyRelease('destroy', client).then(onFinally, onFinally)
  }

  _destroyRelease (command, client) {
    const pool = this._getPoolFromClient(client)

    if (!pool) {
      return Promise.reject(new Error('Destroy: Pool not found'))
    }

    this._setPoolTimeout(pool)

    return pool[command](client)
  }

  _getPoolFromClient (client) {
    return this._pools.get(client._poolKey)
  }

  _getPools (tenantId) {
    const pools = []
    for (const key of this._pools.keys()) {
      if (key.startsWith(tenantId)) {
        pools.push(this._pools.get(key))
      }
    }

    return pools
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   * @param {string} [tenantId] - GUID of a tenant.
   * @returns {Promise} resolves if disconnect is successful, rejects with error if not
   */
  disconnect (tenantId) {
    if (this._pools.size === 0) {
      return Promise.resolve()
    }

    if (tenantId) {
      const pools = this._getPools(tenantId)
      return pools.size !== 0
        ? Promise.all(pools.map(pool => this._disconnect(pool, pool._poolKey)))
        : Promise.reject(new Error(`No pool for tenantId ${tenantId}`))
    }

    const disconnects = []

    for (const [poolKey, pool] of this._pools) {
      disconnects.push(this._disconnect(pool, poolKey))
    }

    return Promise.all(disconnects)
  }

  _disconnect (pool, poolKey) {
    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._cleanupPool(this._pools.get(poolKey), poolKey)
      })
    }

    return this._cleanupPool(pool, poolKey)
  }

  _cleanupPool (pool, poolKey) {
    return pool.disconnect().then(() => {
      this._clearPoolTimeout(pool)
      this._pools.delete(poolKey)
    })
  }

  /**
   * Execute CQN or SQL outside of the odata package.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Object} thenable, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  run (query, values, context = {}, mainKind = null) {
    const runs = []
    const promise = this.acquire(context, mainKind).then(client => {
      if (this.options.model && !client._csn) client.setCSN(this.model)
      let chain = client.run(query, values)

      for (const args of runs) {
        chain = chain.then(() => {
          return client.run(...args).catch(err => {
            throw err
          })
        })
      }

      return chain
        .then(res => {
          return this.release(client).then(() => {
            return res
          })
        })
        .catch(err => {
          return this.release(client).then(() => {
            throw err
          })
        })
    })

    const then = (resolve, reject) => {
      return promise.then(resolve).catch(reject)
    }

    const end = {
      then: then,
      catch: promise.catch
    }

    then.run = (...args) => {
      runs.push(args)
      return end
    }

    return end
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion
   * instead of materializing the full set in memory before.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {function} cb - synchronous function to process each row of the result set.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  async foreach (query, values, cb, context, mainKind) {
    const dbc = await this.acquire(context, mainKind)
    try {
      return await dbc.foreach(query, values, cb)
    } finally {
      await this.release(dbc)
    }
  }

  /**
   * Drops all tables/views and creates them again
   * @param {object} csn the unreflected CSN.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  async deploy (csn, context, mainKind) {
    const dbc = await this.acquire(context, mainKind)
    try {
      return await dbc.deploy(csn)
    } finally {
      await this.release(dbc)
    }
  }
}

if (process.env.DEBUG) {
  const { stdout } = require('./debug')

  class DebugSession extends Service {
    acquire (...args) {
      stdout('acquire connection')
      return super.acquire(...args)
    }

    release (...args) {
      stdout('release connection')
      return super.release(...args)
    }

    disconnect () {
      stdout('disconnect session')
      return super.disconnect()
    }
  }

  module.exports = DebugSession
} else {
  module.exports = Service
}
