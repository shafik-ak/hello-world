const runBlock = require('../statements/runBlock')
const cds = require('../cds')

const MAINKINDS = new Map([
  ['messaging', ['enterprise-messaging', 'file-based-messaging', 'in-process-messaging']],
  // TODO: In the future there should be an intermediate layer ['db', ['sqlite', 'hana']],
  ['rest', ['rest', 'odata']]
])

// leftmost has highest priority
const MAINKIND_HIERARCHY = ['rest', 'messaging']

const getDefaultMainKind = packages => {
  if (packages.size === 1) {
    return packages.keys().next().value
  }

  for (const mainKind of MAINKIND_HIERARCHY) {
    const included = packages.has(mainKind)
    if (included) {
      return mainKind
    }
  }
  throw new Error('Cannot acquire connection. No valid "kind" provided')
}

const _getCDSRequires = () => {
  const {
    env: { requires }
  } = require('../cds')
  return requires
}

/**
 * The credentials might be configured at the package.json
 * @returns {Object}
 * @private
 */
const _getFromCdsEnv = datasource => {
  const requires = _getCDSRequires()

  if (requires) {
    // Do not change deep structures
    if (requires[datasource]) {
      return JSON.parse(JSON.stringify(requires[datasource]))
    }

    if (!datasource && requires.db) {
      return JSON.parse(JSON.stringify(requires.db))
    }
  }

  return { pool: {} }
}

const _getCredentials = (kind, url) => {
  // TODO: revisit once there are more sources than HANA and SQLite
  if (kind === 'sqlite') {
    return { database: url }
  }

  return { url }
}

const _getMainKind = kind => {
  for (const [mainKind, kinds] of MAINKINDS) {
    if (kinds.includes(kind)) {
      return mainKind
    }
  }
  return kind
}
/**
 * Parse a string into options.
 * @param {string} datasource
 * @returns {Object}
 * @private
 */
const _parseOptionsString = (datasource = '') => {
  const [, kind, url] = datasource.match(/^(\w+)(?::(.+))?$/) || []

  if (url) {
    return {
      kind,
      credentials: _getCredentials(kind, url)
    }
  }

  // if there is only one match, it is a reference to a data source configuration at "requires"
  return _getFromCdsEnv(kind)
}

const _decorated = fn => {
  const { stdout } = require('./debug')

  return function (...args) {
    if (args.length > 2) {
      stdout(args[0], args[1])
    } else {
      stdout(...args)
    }

    return fn.apply(this, args)
  }
}

const _addDebugToClient = driver => {
  // The driver has a different method for select and transactions
  if (driver.prototype._runSingle) {
    driver.prototype._executeSelect = _decorated(driver.prototype._executeSelect)
    driver.prototype._runSingle = _decorated(driver.prototype._runSingle)

    return
  }

  if (driver.prototype._executeExpand) {
    driver.prototype._executeExpand = _decorated(driver.prototype._executeExpand)
  }

  driver.prototype._executeSQL = _decorated(driver.prototype._executeSQL)
}

const _getDriverPackage = mainKind => {
  switch (mainKind) {
    case 'hana':
    case 'sqlite':
    case 'rest':
    case 'messaging':
      return require(`@sap/cds-${mainKind}`)
    case 'odata':
      return require(`@sap/cds-rest`)
    case undefined:
    case null:
    default:
      return require(mainKind)
  }
}

/**
 * Provided clients will have the @sap group and cds- prefix.
 * Custom can have any string.
 * @param kind
 * @returns {*}
 * @private
 */
const _getDriverPackages = kind => {
  if (typeof kind === 'string') {
    return _getDriverPackages({ [kind]: {} })
  }

  const drivers = new Map()
  for (const singleKind of Object.keys(kind)) {
    const mainKind = _getMainKind(singleKind)
    drivers.set(mainKind, Object.assign(_getDriverPackage(mainKind), { kind: singleKind }))
  }
  return drivers
}

const _addConnectionOptions = options => {
  const baseOptions = Object.assign({}, options)

  options.connectionOptions = new Map()

  if (typeof options.kind === 'string') {
    options.connectionOptions.set(_getMainKind(options.kind), baseOptions)
    return
  }

  const baseCredentials = Object.assign({}, options.credentials)
  delete baseOptions.kind
  for (const _kind of Object.keys(options.kind)) {
    const mergedCredentials = Object.assign({}, baseCredentials, options.kind[_kind].credentials)
    const optionsOfMainKind = Object.assign({}, baseOptions, options.kind[_kind], { credentials: mergedCredentials })
    if (!optionsOfMainKind.kind) {
      optionsOfMainKind.kind = _kind
    }
    options.connectionOptions.set(_getMainKind(_kind), optionsOfMainKind)
  }
}

/**
 * In case the kind is provided as string, require and use the package
 * @param {Object} options
 * @private
 */
const _addClientToOptions = options => {
  if (options.packages) {
    return
  }

  if (typeof options.kind === 'function') {
    options.packages = new Map([[options.kind.name, { Client: options.kind }]])
    return
  }

  options.packages = _getDriverPackages(options.kind)

  for (const [mainKind, _package] of options.packages) {
    if (options.multiTenant !== true) {
      // TODO: Is it really options?
      if (_package.options) {
        _package.options(options.connectionOptions.get(mainKind))
      }
    }

    _package.inject(cds.cds)

    if (!_package.Client.prototype._runBlock) {
      _package.Client.prototype._runBlock = runBlock

      if (process.env.DEBUG) {
        _addDebugToClient(_package.Client)
      }
    }
  }
}

const _getMessagingKindFromMessaging = messaging => {
  const { kind, credentials = {} } = messaging

  if (kind === 'local') {
    return credentials.file ? 'file-based-messaging' : 'in-process-messaging'
  }
  if (!kind) {
    return credentials.management && credentials.messaging
      ? 'enterprise-messaging'
      : credentials.file
        ? 'file-based-messaging'
        : 'in-process-messaging'
  }

  return kind
}

// This is used to enable messaging for kind 'odata' or 'rest'.
const _unwrapRestOrOdata = (options, messaging) => {
  if (options.kind === 'odata' || options.kind === 'rest') {
    const mergedCredentials = Object.assign({}, messaging.credentials, options.credentials)
    let messagingOptions = Object.assign({}, messaging, options, {
      kind: messaging.kind,
      credentials: mergedCredentials
    })
    messagingOptions.kind = _getMessagingKindFromMessaging(messagingOptions)
    options.kind = {
      [options.kind]: {},
      messaging: messagingOptions
    }
  }
}

/**
 * Get defaults or additional data for the given options.
 * @param {String} [datasource]
 * @param {Object} [options]
 * @returns {Object}
 * @throws Error if no valid options.kind provided
 * @private
 */
const getOptions = (datasource, options) => {
  if (datasource && typeof datasource === 'object') {
    return getOptions(undefined, datasource)
  }

  options =
    (datasource && datasource.includes(':')) || !options
      ? Object.assign(_parseOptionsString(datasource), options)
      : Object.assign(_getFromCdsEnv(datasource), options)

  if (datasource) {
    options.datasource = datasource
  }

  if (options.credentials) {
    options.credentials = Object.assign({}, options.credentials)
  }

  // Fallback
  if (options.driver) {
    options.kind = options.kind || options.driver
  }

  if (!options.kind) {
    throw new Error(`No option's parameter "kind" provided`)
  }

  options.pool = Object.assign(
    {
      numTestsPerEvictionRun: options.pool && options.pool.min > 2 ? Math.ceil(options.pool.min / 2) : 2,
      softIdleTimeoutMillis: 30000,
      idleTimeoutMillis: 480000
    },
    options.pool,
    { testOnBorrow: true }
  )

  const requires = _getCDSRequires()
  if (requires && requires.messaging) {
    _unwrapRestOrOdata(options, requires.messaging)
  }
  _addConnectionOptions(options)
  _addClientToOptions(options)
  return options
}

module.exports = { getOptions, getDefaultMainKind }
