const genericPool = require('@sap/cds-foss')('generic-pool')
const { resolve } = require('../utils/thenable')

/**
 * Pool to acquire db connection clients.
 */
class Pool {
  /**
   * Creates a Pool according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {string} poolKey - Identifier the clients are tagged with.
   * @param {string} Client - To be used client.
   * @param {Object} connectionOptions - Pool and Client settings
   * @param {Object} [connectionOptions.pool] - The min and max pool settings.
   * @param {number} [connectionOptions.pool.min] - The minimum number of db connection clients.
   * @param {number} [connectionOptions.pool.max] - The maximum number of db connection clients.
   * @param {number} [connectionOptions.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * @param {number} [connectionOptions.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * @param {number} [connectionOptions.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * @param {number} [connectionOptions.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * @param {Object} [connectionOptions.credentials] - Credentials how to connect with a client
   * @param {string} [connectionOptions.credentials.host] - Address to the db
   * @param {string} [connectionOptions.credentials.port] - Port for db
   * @param {string} [connectionOptions.credentials.user] - Username for authentication
   * @param {string} [connectionOptions.credentials.password] - Password for authentication
   * @param {string} [connectionOptions.reflectedModel] - Reflected model, that belongs to the data source
   */
  constructor (poolKey, Client, connectionOptions) {
    this._poolKey = poolKey
    this._Client = Client
    this._connectOptions = connectionOptions
    this._pool = genericPool.createPool(this._getPoolFactory(connectionOptions), connectionOptions.pool)
  }

  _getPoolFactory (options) {
    return {
      /**
       * Connects the db client.
       *
       * @returns {Promise}
       * @private
       */
      create: () => {
        const Client = this._Client
        return new Client(options).connect()
      },

      /**
       * Closes the database connection of the client and returns a promise which will be resolved upon success.
       *
       * @returns {Promise}
       * @private
       */
      destroy: client => {
        return client.end()
      },

      /**
       * Validate whether the client is in a valid state and successfully connected to the database or not.
       * @returns {Promise}
       * @private
       */
      validate: client => {
        return resolve(client.isValid())
      }
    }
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} context - Event context of using handler.
   * @param {Object} [model] - CSN of service
   */
  acquire (context, model) {
    return this._pool.acquire().then(client => {
      const opts = this._acquireOptions(context)

      // add information to client, so it can be returned to correct pool. Pushed down, so extra .then can be avoided
      client._poolKey = this._poolKey

      // Client propagation
      client.setLocale(opts.locale)
      client.setUser(opts.user)
      client.setSessionContext && client.setSessionContext('VALID-FROM', opts.from)
      client.setSessionContext && client.setSessionContext('VALID-TO', opts.to)

      client.setCSN(model)
      client.setContext(context)

      return client
    })
  }

  _acquireOptions (context) {
    return {
      user: (context.user && context.user.id) || '',
      locale: (context.user && context.user.locale) || 'en_US',
      from: context._ && context._['VALID-FROM'],
      to: context._ && context._['VALID-TO']
    }
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._pool.release(client)
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return this._pool.destroy(client)
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   */
  disconnect () {
    return this._pool.drain().then(() => {
      return this._pool.clear()
    })
  }

  get noClientsBorrowed () {
    return this._pool.borrowed === 0
  }
}

module.exports = Pool
