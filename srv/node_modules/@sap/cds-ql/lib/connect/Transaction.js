// Support for legacy push down of model
const MODEL = Symbol.for('sap.cds.model')

/**
 * Transaction to encapsulate operations on a data source which should be executed as an indivisible unit of work.
 */
class Transaction {
  /**
   * Creates a transaction for a given connection service and a specific context.
   * @param {Object} service - Session allowing to acquire and manage data source clients
   * @param {Object} context - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   */
  constructor (service, context) {
    this._service = service
    this._context = context

    for (const [, _package] of this._service.options.packages) {
      if (_package.serviceFunctions) {
        Object.defineProperties(this, {
          create: { value: _package.serviceFunctions.create, writable: true },
          read: { value: _package.serviceFunctions.read, writable: true },
          update: { value: _package.serviceFunctions.update, writable: true },
          delete: { value: _package.serviceFunctions.delete, writable: true },
          insert: { value: _package.serviceFunctions.insert, writable: true }
        })
      }

      if (_package.httpFunctions) {
        Object.defineProperties(this, {
          get: { value: _package.httpFunctions.get, writable: true },
          post: { value: _package.httpFunctions.post, writable: true },
          put: { value: _package.httpFunctions.put, writable: true },
          patch: { value: _package.httpFunctions.patch, writable: true },
          delete: { value: _package.httpFunctions.delete, writable: true }
        })
      }
    }
  }

  _acquireAndExecute (clientFn, ...args) {
    // Run has been used before, but acquire is not done yet
    if (this.client instanceof Promise) {
      return this.client.then(() => {
        if (this.client.stack) {
          throw this.client
        }

        return this.client[clientFn](...args)
      })
    }

    // There has been an error on acquire
    if (this.client && this.client.stack) {
      return Promise.reject(this.client)
    }

    // Run has been used before and acquire is done
    if (this.client && this.client[clientFn]) {
      return this.client[clientFn](...args)
    }

    // Acquire and execute
    this.client = this._service
      .acquire(this._context, args[3])
      .then(client => {
        this.client = client
        client.setCSN(this._service.options.model ? this._service.model : this._context[MODEL])
        client.setContext(this._context)

        return client.begin()
      })
      .catch(err => {
        this.client = err

        throw err
      })
      .then(() => {
        if (args.length === 1 && Array.isArray(args[0])) {
          return Promise.all(args[0].map(stmt => this.client[clientFn](stmt)))
        }
        return this.client[clientFn](...args)
      })

    return this.client
  }

  _removeNoLongerNeededConnection () {
    const dbc = this.client
    delete this.client

    this._context._.shared.connections.delete(this._service)

    return dbc
  }

  async _endTransaction (command, ignoreReleaseError) {
    if (this.client instanceof Promise) {
      await this.client
    }

    const dbc = this._removeNoLongerNeededConnection()

    // In case there is no dbc
    if (!dbc) {
      if (ignoreReleaseError === true) {
        return
      }
      throw new Error(`Cannot ${command}: client not found`)
    }

    // An error has occurred and there is no client
    if (dbc.stack) {
      throw dbc
    }

    try {
      await dbc[command]()

      return await this._service.release(dbc)
    } catch (err) {
      await this._service.destroy(dbc)
      // Success of destroy must trigger the error handling.
      throw err
    }
  }

  _addThenableToRun (promise) {
    const then = (resolve, reject) => {
      return promise.then(resolve, reject).catch(reject)
    }

    then.run = (...args) => {
      return this._addThenableToRun(promise.then(() => this._acquireAndExecute('run', ...args)))
    }

    return { then, catch: promise.catch }
  }

  run (...args) {
    return this._addThenableToRun(this._acquireAndExecute('run', ...args))
  }

  foreach (...args) {
    return this._acquireAndExecute('foreach', ...args)
  }

  commit (ignoreReleaseError) {
    return this._endTransaction('commit', ignoreReleaseError)
  }

  rollback (ignoreReleaseError) {
    return this._endTransaction('rollback', ignoreReleaseError)
  }
}

module.exports = Transaction
