const { resolve } = require('../utils/thenable')

class Message {
  constructor (event, payload, raw, topic) {
    this.event = event || topic
    this.data = payload.data
    this.headers = Object.assign({}, payload)
    delete this.headers.data
    Object.defineProperty(this, '_', { value: raw })
  }

  reject (arg) {
    // TODO: Clarify if error is needed (maybe to be alligned with REST/OData service handlers)
    throw typeof arg === 'string' ? new Error(arg) : arg
  }
}

const dataHandler = (onHandlers, errHandlers, base) => raw => {
  const { subject: topic } = raw.source.properties
  if (!topic) {
    return
  }

  const [, entity, event] = topic.match(new RegExp(`^${base}(?:\\/([^/]*))?\\/([^/]*)$`)) || []

  const matchedHandlers = onHandlers.filter(
    each =>
      (event && entity && (each.event === '*' || each.event === event) && each.entity === entity) ||
      (event && !entity && !each.entity && each.event === event) ||
      (!event && !entity && each.topic === topic)
  )

  if (!matchedHandlers.length) return

  let payload
  try {
    payload = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(raw.payload.chunks[0])))
  } catch (err) {
    return raw.done()
  }
  const msg = new Message(event, payload, raw, topic)

  return matchedHandlers
    .reduce((chain, handler) => chain.then(() => handler.handler(msg)), resolve())
    .then(() => raw.done())
    .catch(err => {
      console.error(err)
      const chain = errHandlers.reduce((chain, errHandler) => chain.then(() => errHandler(err)), resolve())
      return chain.then(() => raw.done())
    })
}
module.exports = dataHandler
