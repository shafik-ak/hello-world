'use strict';

const url = require('url');
const commons = require('@sap/odata-commons');
const HttpStatusCodes = commons.http.HttpStatusCode.StatusCodes;
const HttpMethods = commons.http.HttpMethod.Methods;
const HeaderNames = commons.http.HttpHeader.HeaderNames;
const ResourceKind = commons.uri.UriResource.ResourceKind;
const EdmTypeKind = commons.edm.EdmType.TypeKind;

const RequestContract = require('./RequestContract');
const UriHelper = require('../utils/UriHelper');
const Preferences = require('../http/Preferences');
const ConditionalRequestValidator = require('../validator/ConditionalRequestValidator');

/**
 * Request object wrapper to carry original request information.
 * @hideconstructor
 */
class OdataRequest {
    /**
     * Creates an instance of OdataRequest.
     * The constructor also splits the URL into service, OData, and query parts.
     *
     * @param {Object} inRequest  A request object with {method, url, headers, payload}
     * @param {Function} serviceResolutionFn - Function to resolve the service name in the request URL.
     *  It must return an object with the 'base' and 'path' parts of the input URL.
     */
    constructor(inRequest, serviceResolutionFn) {
        this._inRequest = inRequest;
        this._serviceResolutionFn = serviceResolutionFn;

        /**
         * OData request ID, set in case of batch processing from the deserialized OData batch payload
         * @type {?string}
         * @private
         */
        this._odataRequestId = this._inRequest.getOdataRequestId ? this._inRequest.getOdataRequestId() : null;
        this._atomicityGroupId = this._inRequest.getAtomicityGroupId ? this._inRequest.getAtomicityGroupId() : null;
        this._url = url.parse(this._inRequest.url);

        this._rawODataPath = null;
        this._queryOptions = null;
        this._uriInfo = null;

        /**
         * @type {RequestContract}
         * @private
         */
        this._contract = new RequestContract();

        this._body = null;
        this._preferences = null;
        this._service = null;
        this._logger = null;
        this._validateEtagHasBeenCalled = false;
        this._isConditional = null;
        this._etagValidationOutCome = HttpStatusCodes.OK;
        this._concurrentSegment = null;
        this._getConcurrentResourceHasBeenCalled = false;
        this._applicationData = null;

        // Transfer batch information to the batched OdataRequest.
        this._batchContext = this._inRequest.getBatchContext ? this._inRequest.getBatchContext() : null;

        this._deepInsertExpand = [];
        this._hasDelta = false;
    }

    /**
     * Returns the current logger instance.
     * @returns {LoggerFacade} The current logger
     */
    getLogger() {
        return this._logger;
    }

    /**
     * Sets the current logger instance.
     * @param {LoggerFacade} logger The current logger
     * @returns {OdataRequest} This OData request instance
     * @package
     */
    setLogger(logger) {
        this._logger = logger;
        return this;
    }

    /**
     * Returns the resource-path part of the request URL that belongs to OData.
     * @returns {string} undecoded OData path, e.g., "Employees"
     */
    getOdataPath() {
        if (this._rawODataPath === null) this._rawODataPath = this._serviceResolutionFn(this._url.pathname || '');
        return this._rawODataPath;
    }

    /**
     * Returns the request method.
     * @returns {string} The request method like GET, PUT, POST, ...
     */
    getMethod() {
        return this._inRequest.method;
    }

    /**
     * Returns the header value for a given name.
     * @param {string} name the name of the header
     * @returns {string} The header value or undefined, if not found
     */
    getHeader(name) {
        return this._inRequest.headers[name];
    }

    /**
     * Returns all available headers.
     * @returns {Object} All headers with header:headerValue
     */
    getHeaders() {
        return this._inRequest.headers;
    }

    /**
     * Returns the parsed url object parsed with node.js url module.
     * @returns {Object} The parsed url object.
     */
    getUrlObject() {
        return this._url;
    }


    /**
     * Returns the current query options. Structure of the object is defined as follows
     * Example:
     *  url: http://server:port/service/?foo=bar1&foo=bar2&bar=foo
     *  result:
     *  {
     *   foo: ['bar1', 'bar2'],
     *   bar: 'foo'
     *  }
     *
     * @returns {Object} the parsed query-options object
     */
    getQueryOptions() {
        if (this._queryOptions === null) this._queryOptions = UriHelper.parseQueryString(this._url.search);
        return this._queryOptions;
    }

    /**
     * Sets the UriInfo object. This is done while processing the request.
     * @param {UriInfo} uriInfo The uri info
     * @returns {OdataRequest} this request object
     * @package
     */
    setUriInfo(uriInfo) {
        this._uriInfo = uriInfo;
        return this;
    }

    /**
     * Returns the uri info object.
     * This object is the result of the URI parsing and will be set
     * while processing the request but before reaching the application handlers.
     *
     * @returns {UriInfo} The uri info object.
     */
    getUriInfo() {
        return this._uriInfo;
    }

    /**
     * Returns the current request contract.
     * @returns {RequestContract} The current request contract
     */
    getContract() {
        return this._contract;
    }

    /**
     * Sets the request body. The body is set though the parsing of the payload.
     * @param {*} body The request body
     * @returns {OdataRequest} This instance
     * @package
     */
    setBody(body) {
        this._body = body;
        return this;
    }

    /**
     * Returns the request body created by application. This is the parsed result of the request payload.
     * @returns {*} request body
     */
    getBody() {
        return this._body;
    }

    /**
     * Sets the parsed preferences
     * @param {Preferences} preferences the preferences
     * @returns {OdataRequest} this request object
     * @package
     */
    setPreferences(preferences) {
        this._preferences = preferences;
        return this;
    }

    /**
     * Returns the preferences parsed from the request header.
     * @returns {Preferences} the preferences
     */
    getPreferences() {
        if (!this._preferences) this._preferences = new Preferences();
        return this._preferences;
    }

    /**
     * Returns the original incoming node request message.
     * @returns {IncomingMessage} the original incoming request
     */
    getIncomingRequest() {
        return this._inRequest;
    }

    /**
     * Set the used service instance.
     * @param {Service} service the service instance
     * @returns {OdataRequest} this request object
     * @package
     */
    setService(service) {
        this._service = service;
        return this;
    }

    /**
     * Return the used service instance.
     * @returns {Service} the service instance
     */
    getService() {
        return this._service;
    }

    /**
     * Returns true if this request is a conditional request.
     * A request is conditional if at least one of the following supported headers are present: If-Match, If-None-Match.
     *
     * @returns {boolean} True if this request is conditional, else false
     */
    isConditional() {
        if (this._isConditional === null) {
            this._isConditional = Boolean(this.getHeader(HeaderNames.IF_MATCH.toLowerCase())
                || this.getHeader(HeaderNames.IF_NONE_MATCH.toLowerCase()));
        }
        return this._isConditional;
    }

    /**
     * Validates a provided resource etag value against the conditional etag header values of If-Match and If-None-Match.
     * @param {string} etag The etag value of the resource
     * @returns {HttpStatusCode.StatusCodes.OK | HttpStatusCode.StatusCodes.NOT_MODIFIED} OK, if validation was ok,
     *      NOT_MODIFIED if etag values are matching indicating that the resource was not modified
     * @throws {PreconditionFailedError} if the validations failed
     */
    validateEtag(etag) {
        this._logger.path('Entering OdataRequest.validateEtag()...');
        this._logger.debug('Provided etag:', etag);

        this._validateEtagHasBeenCalled = true;

        this._etagValidationOutCome = new ConditionalRequestValidator().validateEtag(
            this.getHeader(HeaderNames.IF_MATCH.toLowerCase()),
            this.getHeader(HeaderNames.IF_NONE_MATCH.toLowerCase()),
            this.getMethod(),
            this.getUriInfo().getLastSegment().getKind(),
            etag) ?
            HttpStatusCodes.NOT_MODIFIED : HttpStatusCodes.OK;
        this._logger.debug('Outcome of conditional request processing ETag validation:', this._etagValidationOutCome);

        return this._etagValidationOutCome;
    }

    /**
     * Returns the concurrent UriResource segment if the resource addressed by this URI is concurrent.
     * @returns {?UriResource} the concurrent UriResource segment, if this resource is concurrent, else null
     */
    getConcurrentResource() {
        if (this._getConcurrentResourceHasBeenCalled) {
            return this._concurrentSegment;
        }
        const lastSegment = this.getUriInfo().getLastSegment();
        let segment = null;

        if ((lastSegment.getKind() === ResourceKind.METADATA
            || lastSegment.getKind() === ResourceKind.SERVICE)) {
            this._getConcurrentResourceHasBeenCalled = true;
            this._concurrentSegment = lastSegment;
            return lastSegment;
        }

        if (this.getMethod() !== HttpMethods.GET
            && (lastSegment.getKind() === ResourceKind.REF || lastSegment.getKind() === ResourceKind.REF_COLLECTION)) {
            segment = this.getUriInfo().getLastSegment(-2);
        } else {
            segment = this.getUriInfo().getPathSegments().reduceRight(
                (result, tempSegment) =>
                    !result
                    && !tempSegment.getAction()
                    && tempSegment.getEdmType() && tempSegment.getEdmType().getKind() === EdmTypeKind.ENTITY
                    && !(tempSegment.getNavigationProperty() && tempSegment.getNavigationProperty().containsTarget())
                    || tempSegment.getFunction() ?
                        tempSegment : result,
                null);
        }
        if (segment && !(segment.getEntitySet() && segment.getEntitySet().isConcurrent()
            || segment.getSingleton() && segment.getSingleton().isConcurrent()
            || segment.getTarget() && segment.getTarget().isConcurrent())) {
            segment = null;
        }
        this._getConcurrentResourceHasBeenCalled = true;
        this._concurrentSegment = segment;
        return segment;
    }

    /**
     * Return the outcome of the etag validation process. This can be one of the following outcomes:
     *  - HttpStatusCode.OK = Validation was ok
     *  - HttpStatusCode.NOT_MODIFIED = Validation was ok and outcome is "resource is not modified"
     * Default is HttpStatusCode.OK.
     *
     * @returns {HttpStatusCode.StatusCodes.OK | HttpStatusCode.StatusCodes.NOT_MODIFIED} The status code
     * @package
     */
    getETAGValidationStatus() {
        return this._etagValidationOutCome;
    }

    /**
     * Return true if the etag validation has been called.
     * @returns {boolean} True if the etag validation has been called, else false
     * @package
     */
    validateEtagHasBeenCalled() {
        return this._validateEtagHasBeenCalled;
    }

    /**
     * Return OData request ID.
     * @returns {?string} the request ID
     */
    getOdataRequestId() {
        return this._odataRequestId;
    }

    /**
     * Return atomicity group ID.
     * @returns {?string} the group ID
     */
    getAtomicityGroupId() {
        return this._atomicityGroupId;
    }

    /**
     * Get custom application data associated with this request.
     * @returns {Object} data the application data
     */
    getApplicationData() {
        return this._applicationData;
    }

    /**
     * Set custom application data.
     * @param {Object} data the custom application data
     * @returns {OdataRequest} this request object
     */
    setApplicationData(data) {
        this._applicationData = data;
        return this;
    }

    /**
     * Get custom application data associated with the batch request containing this request.
     * @returns {Object} data the custom application associated with the batch request
     */
    getBatchApplicationData() {
        return this._batchContext ? this._batchContext.getRequest().getApplicationData() : null;
    }

    /**
     * Set an ExpandItem array; these are the top-level expands from a deep insert.
     * @param {ExpandItem[]} expand The expand item to set
     * @returns {OdataRequest} This instance of odata request
     * @package
     */
    setDeepInsertExpand(expand) {
        this._deepInsertExpand = expand;
        return this;
    }

    /**
     * Returns the top-level expand items from a deep-insert payload.
     * Returns an empty array if the payload is not nested.
     *
     * @returns {ExpandItem[]} the top-level expand items derived from a deep insert payload;
     *                         can be empty if there is no expand item available but not null
     */
    getDeepInsertExpand() {
        return this._deepInsertExpand;
    }

    /**
     * Sets the information that there is a delta annotation in the request.
     * @param {boolean} hasDelta whether there is a delta annotation in the request
     * @returns {OdataRequest} this instance of OdataRequest
     * @package
     */
    setHasDelta(hasDelta) {
        this._hasDelta = hasDelta;
        return this;
    }

    /**
     * Returns the information whether there is a delta annotation in the request.
     * @returns {boolean} whether there is a delta annotation in the request
     */
    hasDelta() {
        return this._hasDelta;
    }
}

module.exports = OdataRequest;
