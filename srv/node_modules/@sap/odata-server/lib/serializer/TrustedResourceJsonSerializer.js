'use strict';

const commons = require('@sap/odata-commons');
const MetaProperties = commons.format.JsonFormat.MetaProperties;
const Annotations = commons.format.JsonFormat.Annotations;
const EdmTypeKind = commons.edm.EdmType.TypeKind;
const EdmPrimitiveTypeKind = commons.edm.EdmPrimitiveTypeKind;
const SerializationError = require('../errors/SerializationError');

/**
 * JSON serializer for trusted OData resources, i.e., there is no validation.
 */
class TrustedResourceJsonSerializer {
    /**
     * @param {JsonContentTypeInfo} formatParams JSON serializing options
     */
    constructor(formatParams) {
        this._formatParams = formatParams;
    }

    /**
     * Serializes entity to OData JSON string.
     * @param {EdmEntityType} entityType - entity type of the entity
     * @param {Object} data - entity data
     * @returns {string} entity, serialized in OData JSON format
     */
    serializeEntity(entityType, data) {
        const value = data.value;

        try {
            return JSON.stringify(this._serializeEntity(
                this._serializeAnnotations({}, value, MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG),
                entityType, value));
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the entity.', error);
        }
    }

    /**
     * Serializes entity collection to OData JSON string.
     * @param {EdmEntityType} entityType - entity type for the entities in the collection
     * @param {Object} data - entity collection data
     * @returns {string} entity collection, serialized in OData JSON format
     */
    serializeEntityCollection(entityType, data) {
        const value = data.value;

        try {
            let serializedEntityCollection = this._serializeAnnotations({}, data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);
            this._serializeOperationAdvertisement(serializedEntityCollection, data);

            serializedEntityCollection.value = value.map(currentEntity =>
                this._serializeEntity({}, entityType, currentEntity));
            this._serializeAnnotations(serializedEntityCollection, data, MetaProperties.NEXT_LINK);

            return JSON.stringify(serializedEntityCollection);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the entity collection', error);
        }
    }

    /**
     * Serialize a primitive-type value to an OData JSON string.
     * @param {(EdmProperty|EdmReturnType)} propertyOrReturnType EDM property or EDM return type
     * @param {Object} data the data with the value
     * @returns {string} serialized representation in OData JSON format
     */
    serializePrimitive(propertyOrReturnType, data) {
        const value = data.value;

        try {
            let result = this._serializeAnnotations({}, data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.ETAG);

            result.value = value === null || value === undefined ?
                null :
                this._serializePropertyValue(propertyOrReturnType, value);

            return JSON.stringify(result);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the primitive value', error);
        }
    }

    /**
     * Serialize a primitive-type collection value to an OData JSON string.
     * @param {(EdmProperty|EdmReturnType)} propertyOrReturnType EDM property or EDM return type
     * @param {Object} data the data with the values
     * @returns {string} serialized representation in OData JSON format
     */
    serializePrimitiveCollection(propertyOrReturnType, data) {
        const value = data.value;

        try {
            let result = this._serializeAnnotations({}, data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT, MetaProperties.ETAG);

            result.value = [];
            if (value === null || value === undefined) return JSON.stringify(result);
            result.value = value.map(valueItem =>
                valueItem === null ? null : this._serializePropertyValue(propertyOrReturnType, valueItem));
            this._serializeAnnotations(result, data, MetaProperties.NEXT_LINK);
            return JSON.stringify(result);
        } catch (error) {
            throw new SerializationError(
                'An error occurred during serialization of the primitive collection value', error);
        }
    }

    /**
     * Serialize a complex-type value to an OData JSON string.
     * @param {(EdmProperty|EdmReturnType)} propertyOrReturnType EDM property or EDM return type
     * @param {Object} data the data with the value
     * @returns {string} serialized representation in OData JSON format
     */
    serializeComplex(propertyOrReturnType, data) {
        const value = data.value;

        try {
            let result = this._serializeAnnotations({}, value || data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.ETAG);

            if (value === null || value === undefined) return JSON.stringify(result);

            this._serializeStructure(result, propertyOrReturnType.getType(), value);
            return JSON.stringify(result);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the complex value', error);
        }
    }

    /**
     * Serialize a complex-type collection value to an OData JSON string.
     * @param {(EdmProperty|EdmReturnType)} propertyOrReturnType EDM property or EDM return type
     * @param {Object} data the data with the value
     * @returns {string} serialized representation in OData JSON format
     */
    serializeComplexCollection(propertyOrReturnType, data) {
        const value = data.value;

        try {
            let result = this._serializeAnnotations({}, data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);
            this._serializeAnnotations(result, value, MetaProperties.ETAG);
            result.value = [];
            if (value === null || value === undefined) return JSON.stringify(result);
            const type = propertyOrReturnType.getType();
            result.value = value.map(valueItem =>
                valueItem === null ? null : this._serializeStructure({}, type, valueItem));
            this._serializeAnnotations(result, data, MetaProperties.NEXT_LINK);
            return JSON.stringify(result);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the complex collection value',
                error);
        }
    }

    /**
     * Serializes entity to OData JSON string.
     * @param {Object} result the result object
     * @param {EdmEntityType} entityType - entity type of the entity
     * @param {Object} data - entity data
     * @returns {Object} plain object, representing the serialized entity
     * @private
     */
    _serializeEntity(result, entityType, data) {
        this._serializeAnnotations(result, data, MetaProperties.ETAG);
        this._serializeOperationAdvertisement(result, data);

        this._serializeStructure(result, entityType, data);

        // Add annotation '"@odata.id": null' for an entity of a transient type if some properties have been
        // aggregated away or if not all of the base type's properties have been serialized.
        let type = entityType;
        while (type.isReduced) type = type.getBaseType();
        if (entityType.isReduced
            && (entityType.isReduced()
                || Array.from(type.getProperties().keys()).some(name => result[name] === undefined))) {
            result[Annotations.ID] = null;  // eslint-disable-line no-param-reassign
        }

        return result;
    }

    /**
     * Serializes annotations.
     * @param {Object} result the result object
     * @param {Object} sourceData the data
     * @param {string[]} metaProperties meta properties to consider
     * @returns {Object} object containing the serialized annotations
     * @private
     */
    _serializeAnnotations(result, sourceData, ...metaProperties) {
        if (!sourceData) return result;

        for (const metaProperty of metaProperties) {
            const annotation = MetaProperties.getAnnotation(metaProperty);
            // eslint-disable-next-line no-param-reassign
            result[annotation] = this._convertAnnotationValue(annotation, sourceData[metaProperty]);
        }

        return result;
    }

    /**
     * Converts an OData annotation value.
     * Returns the converted value if it is for a supported OData annotation.
     * A value for an unsupported OData annotation will result in an error.
     * If the annotation is not an OData-defined annotation the value is returned 'as is'.
     *
     * @param {string} annotation The annotation
     * @param {*} value The value of the annotation
     * @returns {*} The value of the annotation or the converted one if it is an OData annotation
     * @throws {SerializationError} In case there is an error with converting the annotation value
     * @private
     */
    _convertAnnotationValue(annotation, value) {
        if (value === undefined) return value;
        if (annotation === Annotations.COUNT) {
            return this._serializePropertyValue({ getType: () => EdmPrimitiveTypeKind.Int64 }, value);
        } else if (annotation === Annotations.ETAG
            || annotation === Annotations.METADATA_ETAG
            || annotation === Annotations.MEDIA_ETAG) {
            return 'W/"' + value + '"';
        } else if (annotation === Annotations.CONTEXT
            || annotation === Annotations.NEXT_LINK
            || annotation === Annotations.MEDIA_CONTENT_TYPE
            || annotation === Annotations.MEDIA_EDIT_LINK
            || annotation === Annotations.MEDIA_READ_LINK) {
            return value;
        } else if (annotation.startsWith('@odata.')) {
            throw new SerializationError("Unsupported OData annotation '" + annotation + "'");
        } else {
            return value;
        }
    }

    /**
     * Serializes properties of a structured type.
     * @param {Object} result the result object
     * @param {EdmEntityType|EdmComplexType} type - EDM type for the specified data
     * @param {Object} data - structure data, represented as a plain object with property-value pairs
     * @returns {Object} JSON object containing the serialized properties of the structured type
     * @private
     */
    _serializeStructure(result, type, data) {
        for (const entityProp of Object.keys(data)) {
            const [identifier, star, annotation] = this._getPropertyNameAndAnnotation(entityProp);

            if (annotation) {
                let newPropertyName = entityProp;
                if (star) newPropertyName = newPropertyName.replace('*', '');
                if (newPropertyName.startsWith('@odata.')) continue;
                // eslint-disable-next-line no-param-reassign
                result[newPropertyName] = this._convertAnnotationValue(annotation, data[entityProp]);
            }

            if (identifier && !star && !annotation) {
                const propertyValue = data[entityProp];
                const edmProperty = type.getStructuralProperty(entityProp);
                if (edmProperty) {
                    const propertyType = edmProperty.getType();
                    // "The values for stream properties do not appear in the entity payload."
                    if (propertyType === EdmPrimitiveTypeKind.Stream) continue;
                    const isComplex = propertyType.getKind() === EdmTypeKind.COMPLEX;
                    // Add the type annotation to a dynamic property.
                    if (!isComplex
                        && ![EdmPrimitiveTypeKind.Boolean, EdmPrimitiveTypeKind.Double, EdmPrimitiveTypeKind.String]
                            .includes(propertyType)
                         && (edmProperty.constructor.name !== 'EdmProperty')) {
                        // eslint-disable-next-line no-param-reassign
                        result[entityProp + Annotations.TYPE] = '#' + propertyType.getFullQualifiedName().name;
                    }
                    // Serialize the value.
                    // eslint-disable-next-line no-param-reassign
                    result[entityProp] = this._serializeProperty(edmProperty, propertyValue);

                } else {
                    const edmNavigationProperty = type.getNavigationProperty(entityProp);
                    if (edmNavigationProperty && propertyValue === null) {
                        // eslint-disable-next-line no-param-reassign
                        result[entityProp] = edmNavigationProperty.isCollection() ? [] : null;
                    } else if (edmNavigationProperty && propertyValue !== undefined) {
                        const expandedEntityType = edmNavigationProperty.getEntityType();
                        // eslint-disable-next-line no-param-reassign
                        result[entityProp] = Array.isArray(propertyValue) ?
                            propertyValue.map(currentEntity =>
                                this._serializeEntity({}, expandedEntityType, currentEntity)) :
                            this._serializeEntity({}, expandedEntityType, propertyValue);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Serializes EDM property.
     * @param {EdmProperty} property - EDM property, which has to be serialized
     * @param {*} propertyValue - property value
     * @returns {*} serialized property value
     * @private
     */
    _serializeProperty(property, propertyValue) {
        if (propertyValue === null || propertyValue === undefined) return property.isCollection() ? [] : null;
        try {
            return property.isCollection() ?
                propertyValue.map(value => this._serializePropertyValue(property, value)) :
                this._serializePropertyValue(property, propertyValue);
        } catch (error) {
            throw new SerializationError("Serialization of the '" + property.getName() + "' property failed.", error);
        }
    }

    /**
     * Serializes a single value of an EDM property.
     * @param {EdmProperty} property - EDM property for which the value has to be serialized
     * @param {*} propertyValue - property value which has to be serialized
     * @returns {*} serialized property value
     * @private
     */
    _serializePropertyValue(property, propertyValue) {
        // This is used to serialize null elements inside a collection.
        if (propertyValue === null) return null;

        let type = property.getType();
        switch (type.getKind()) {
            case EdmTypeKind.DEFINITION:
                type = type.getUnderlyingType();
                // eslint-disable-line no-fallthrough
            case EdmTypeKind.PRIMITIVE:
                if (type === EdmPrimitiveTypeKind.Decimal || type === EdmPrimitiveTypeKind.Int64) {
                    return this._formatParams.getIEEE754Setting() ? String(propertyValue) : Number(propertyValue);
                }
                if (type === EdmPrimitiveTypeKind.Binary) {
                    return propertyValue.toString('base64')
                        // Convert the standard base64 encoding to the URL-safe variant.
                        .replace(new RegExp('\\+', 'g'), '-').replace(new RegExp('/', 'g'), '_');
                }
                return propertyValue;
            case EdmTypeKind.COMPLEX:
                return this._serializeStructure({}, type, propertyValue);
            case EdmTypeKind.ENUM: {
                let result = [];
                let remaining = propertyValue;
                const flags = type.isFlags();
                for (const [name, member] of type.getMembers()) {
                    const memberValue = member.getValue();
                    if (flags) {
                        // Use bitwise AND operator to check whether all bits of the member value are set.
                        if ((memberValue & remaining) === memberValue) {
                            result.push(name);
                            // Use bitwise XOR operator to remove the member-value bits from the remaining value.
                            remaining ^= memberValue;
                        }
                    } else if (propertyValue === memberValue) return name;
                }
                return result.join(',');
            }
            default:
                throw new SerializationError(
                    'Serialization of properties of type kind ' + type.getKind() + ' is not supported');
        }
    }

    /**
     * Sets all advertised operations from the passed data in the result.
     * @param {Object} result the result object
     * @param {Object} data entity data
     * @returns {Object} object with every operation advertisement from the passed data
     * @private
     */
    _serializeOperationAdvertisement(result, data) {
        for (const propertyName of Object.keys(data)) {
            // eslint-disable-next-line no-param-reassign
            if (propertyName.startsWith('#')) result[propertyName] = {}; // Only odata.metadata=minimal
        }
        return result;
    }

    /**
     * Returns the property name and the annotation name for a name.
     * If the name starts with an '@' like '@odata.etag' the property name is empty
     * and '@odata.etag' is the annotation.
     * If the name is 'Property@any.annotation' then the property name would be 'Property'
     * and the annotation would be '@any.annotation'.
     * The information about an optional star character in names like 'Property*@annotation' is also returned.
     * @param {string} name - the name
     * @returns {string[]} - an array of strings: [propertyName, star, annotation]
     * @private
     */
    _getPropertyNameAndAnnotation(name) {
        if (!name.includes('*') && !name.includes('@') && !name.includes('#')) return [name];
        let index = name.indexOf('*');
        const star = index >= 0;
        if (index === -1) index = name.indexOf('@');
        if (index === -1) index = name.indexOf('#');
        if (index === -1) index = name.length;
        const propertyName = name.substring(0, index);
        if (star && index < name.length) index++;
        const annotation = name[index] === '@' ? name.substring(index) : null;
        return [propertyName, star, annotation];
    }
}

module.exports = TrustedResourceJsonSerializer;
