const FunctionBuilder = require('@sap/cds-sql').builder.FunctionBuilder

const dateTimeFunctions = new Map([
  ['year', "'%Y'"],
  ['month', "'%m'"],
  ['dayofmonth', "'%d'"],
  ['second', "'%f'"],
  ['hour', "'%H'"],
  ['minute', "'%M'"]
])
const standadFunctions = ['locate', 'substring', 'to_date', 'to_time']

class CustomFunctionBuilder extends FunctionBuilder {
  get ExpressionBuilder () {
    const ExpressionBuilder = require('./CustomExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', { value: ExpressionBuilder })
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./CustomReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', { value: ReferenceBuilder })
    return ReferenceBuilder
  }

  get SelectBuilder () {
    const SelectBuilder = require('./CustomSelectBuilder')
    Object.defineProperty(this, 'SelectBuilder', { value: SelectBuilder })
    return SelectBuilder
  }

  _functionArgs (element) {
    return (element.ref && element.ref[1].args) || element.args
  }

  _handleFunction () {
    let functionName = this._functionName(this._obj)
    let args = this._functionArgs(this._obj)

    if (functionName === 'concat') {
      this._concatFunction(args)
    } else if (dateTimeFunctions.has(functionName)) {
      this._timeFunction(functionName, args)
    } else if (functionName.includes('contains')) {
      this._handleContains(args)
    } else if (standadFunctions.includes(functionName)) {
      this._standardFunction(functionName, args)
    } else if (functionName === 'seconds_between') {
      this._secondsBetweenFunction(args)
    } else {
      super._handleFunction()
    }
  }

  _concatFunction (args) {
    const res = []
    for (const arg of args) {
      if (arg.ref) {
        const { sql, values } = new this.ReferenceBuilder(arg, this._options, this._csn).build()
        res.push(sql)
        this._outputObj.values.push(...values)
      } else if (arg.val) {
        this._outputObj.values.push(arg.val)
        res.push(this._options.placeholder)
      }
    }
    this._outputObj.sql.push('(')
    this._outputObj.sql.push(res.join(' || '))
    this._outputObj.sql.push(')')
  }

  _handleContains (args) {
    const contains = this._obj.func
      ? !this._obj.func.toLowerCase().includes('not')
      : !this._obj.ref[0].toLowerCase().includes('not')
    const columns = this._columns(args)
    const params = this._obj.func ? args.slice(1, args.length - 1) : this._obj.ref[1].args.slice(1, args.length - 1)

    for (const param of params) {
      if (param === 'or' || param === 'and' || param === 'not') {
        this._outputObj.sql.push(param)
      } else {
        const searchText = param.val.toLowerCase()
        this._outputObj.sql.push('(')
        this._createLikeComparison(contains, columns, searchText)
        this._outputObj.sql.push(')')
      }
    }
  }

  _createLikeComparison (contains, columns, searchText) {
    const length = columns.length
    for (let i = 0; i < length; i++) {
      if (columns[i].ref) {
        const { sql } = new this.ReferenceBuilder(columns[i], this._options, this._csn).build()
        this._outputObj.sql.push('lower', '(', sql, ')', contains ? 'LIKE' : 'NOT LIKE', '?')
        this._outputObj.values.push(`%${searchText.replace(/(_|%)/g, '\\$1')}%`)
        if (i !== columns.length - 1 && columns[i + 1] !== ')') {
          this._outputObj.sql.push(contains ? 'OR' : 'AND')
        }
      }
    }
  }

  _columns (args) {
    return args[0].xpr || args[0].list || [args[0]]
  }

  _standardFunction (functionName, args) {
    switch (functionName) {
      case 'locate':
        functionName = 'INSTR'
        break
      case 'substring':
        functionName = 'substr'
        break
      case 'to_date':
        functionName = 'date'
        break
      case 'to_time':
        functionName = 'time'
        break
      default:
        break
    }

    this._outputObj.sql.push(functionName, '(')
    if (typeof args === 'string') {
      this._outputObj.sql.push(args, ')')
    } else {
      this._addFunctionArgs(args)
      this._outputObj.sql.push(')')
    }
  }

  _val (val) {
    this._outputObj.sql.push('?')
    this._outputObj.values.push(val)
  }

  _ref (ref) {
    this._outputObj.sql.push(new this.ReferenceBuilder(ref, this._options, this._csn).build().sql)
  }

  _secondsBetweenFunction (args) {
    this._outputObj.sql.push('strftime(?,')
    this._outputObj.values.push('%s')
    if (args[1].val) {
      this._val(args[1].val)
    } else {
      this._ref(args[1])
    }
    this._outputObj.sql.push(') - strftime(?,')
    this._outputObj.values.push('%s')
    if (args[0].val) {
      this._val(args[0].val)
    } else {
      this._ref(args[0])
    }
    this._outputObj.sql.push(')')
  }

  _timeFunction (functionName, args) {
    this._outputObj.sql.push('strftime(')
    this._outputObj.sql.push(dateTimeFunctions.get(functionName), ',')
    if (typeof args === 'string') {
      this._outputObj.sql.push(args, ')')
    } else {
      this._addFunctionArgs(args)
      this._outputObj.sql.push(')')
    }
  }
}

module.exports = CustomFunctionBuilder
