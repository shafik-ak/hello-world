const { Database } = require('sqlite3')
const { Readable } = require('stream')
const SqliteStatement = require('../statement/SqliteStatement')
const CustomBuilder = require('../customBuilder')
const {
  BaseClient,
  builder: { sqlFactory },
  expand: { createJoinCQNFromExpanded, hasExpand, rawToExpanded },
  composition: {
    hasCompositionDelete,
    createCascadeDeleteCQNs,
    hasDeepInsert,
    createDeepInsertCQNs,
    hasDeepUpdate,
    selectDeepUpdateData,
    createDeepUpdateCQNs
  },
  postProcessing: { getPostProcessMapper, postProcess },
  thenable: { resolve, reject }
} = require('@sap/cds-sql')

const {
  convertToBoolean,
  convertToDateString,
  convertInt64ToString,
  convertToISOTime,
  convertToISONoMillis
} = require('./util')

class Client extends BaseClient {
  /**
   * Create an SqliteClient object.
   *
   * @param {Object} options - Connection details.
   * @param {Object} options.credentials - Connection details.
   * @param {string} options.credentials.database - Filename to the database or :memory; for in memory
   */
  constructor ({ credentials }) {
    super([
      ['cds.Boolean', convertToBoolean],
      ['cds.Date', convertToDateString],
      ['cds.Integer64', convertInt64ToString],
      ['cds.DateTime', convertToISONoMillis],
      ['cds.Timestamp', convertToISOTime]
    ])

    this._credentials = Object.assign({}, credentials)
    this._user = 'anonymous' // default user
    this._transCount = 0
  }

  /**
   * Open database connection.
   *
   * Opening connection occurs while opening Sqlite database.
   *
   * @returns {Promise} Promise, that resolves with SqliteClient if _credentials is successful or rejects with error if not.
   */
  connect () {
    return new Promise((resolve, reject) => {
      // .options() will ensure that credentials.database is set
      if (!this._credentials) {
        return reject(new Error('Cannot connect to database. No connection credentials provided.'))
      }

      this._dbc = new Database(this._credentials.database, err => {
        if (err) {
          return reject(err)
        }

        resolve(this)
      })
    })
  }

  /**
   * Close database connection.
   *
   * Closing connection occurs while closing Sqlite database.
   *
   * @returns {Promise} Promise, that resolves if end is successful or rejects with error if not.
   */
  end () {
    return new Promise((resolve, reject) => {
      this._dbc.close(err => {
        if (err) {
          return reject(err)
        }

        resolve()
      })
    })
  }

  /**
   * Execute SQL statement.
   *
   * If execution of SQL statement requires additional values,
   * then the values to be provided as an array.
   * In order to provide multiple value sets with a single execute (example: batch insert)
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * In case of SELECT the result object contains a result-set.
   * In other cases the result is an empty array - DIFFERENT TO HANA!
   *
   * The query can be provided as SQL string or as CQN object.
   *
   * @example <caption>Simple Select as SQL string<caption>
   * .execute("SELECT * FROM T")
   * @example <caption>Select with filter as SQL string<caption>
   * .execute("SELECT * FROM T WHERE X = ?", [1])
   * @example <caption>Single Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [1, 'a'])
   * @example <caption>Multiple Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [[1, 'a'], [2, 'b']])
   * @example <caption>Simple Select as CQN object<caption>
   * .execute(SELECT.from('T'))
   * @example <caption>Select with filter as CQN object<caption>
   * .execute(SELECT.from('T').where(['x', '=', 1])
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  execute (query, values = []) {
    if (this._toBeDestroyed) {
      return reject(new Error('Client is in an inconsistent state'))
    }

    if (!Array.isArray(values) && (typeof query !== 'string' || typeof values !== 'object')) {
      return reject(new Error(`Cannot execute SQL statement. Invalid values provided: ${JSON.stringify(values)}`))
    }

    if (typeof query === 'string') {
      return this._executeSQL(query, values)
    }

    if (typeof query === 'function') {
      return this._runBlock(query)
    }

    try {
      if (hasExpand(query)) {
        return this._processExpand(query)
      }

      if (hasCompositionDelete(this._csn && this._csn.definitions, query)) {
        return this._processCascadeDelete(query)
      }

      if (hasDeepInsert(this._csn && this._csn.definitions, query)) {
        return this._processDeepInsert(query)
      }

      if (hasDeepUpdate(this._csn && this._csn.definitions, query)) {
        return this._processDeepUpdate(query)
      }

      return this._execute(query, values)
      // The clients of this client are expecting a promise return in any case.
    } catch (err) {
      return reject(err)
    }
  }

  /**
   * Provide large binary stream for a given query.
   * Sqlite does not support streaming natively.
   * Instead a readable stream is created and the value is pushed in the stream.
   *
   * @param {string|object} query - SELECT SQL string or SELECT CQN object.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @returns {Promise} Promise, that resolves with stream if successful or rejects with error if not.
   * Result object can be undefined if no rows obtained or non-streamable data type.
   */
  async stream (query, values = []) {
    if (!query.SELECT && (typeof query !== 'string' || !query.trim().startsWith('SELECT'))) {
      throw new Error(`Cannot stream from sqlite. Invalid query provided: ${JSON.stringify(query)}`)
    }

    const resultSet = await this.execute(query, values)

    if (resultSet.length === 0) {
      return
    }

    let val = Object.values(resultSet[0])[0]
    if (val === null) {
      return null
    }
    if (typeof val === 'number') {
      val = val.toString()
    }

    const stream_ = new Readable()
    stream_.push(val)
    stream_.push(null)

    return stream_
  }

  _returnFirstResultIfOne (isOne, result) {
    if (isOne) {
      return result.length > 0 ? result[0] : null
    }

    return result
  }

  _execute (cqn, inValues = []) {
    const { sql, values = [] } = sqlFactory(
      cqn,
      {
        typeConversion: this._typeConversionMap,
        user: this._user,
        customBuilder: CustomBuilder,
        now: { sql: "strftime('%Y-%m-%dT%H:%M:%SZ','now')" } // '2012-12-03T07:16:23Z'
      },
      this._csn
    )
    const outValues = inValues.length > 0 ? inValues : values

    return this._streamValues(cqn, outValues).then(() => {
      return this._executeSQL(
        sql,
        outValues,
        cqn.SELECT && cqn.SELECT.one,
        getPostProcessMapper(this._toService, this._csn, cqn)
      )
    })
  }

  /**
   * Checks which of the sqlite3 is most fitting for the sql values combination.
   * @param {string} sql - Raw SQL query string
   * @param {Array} values - Array of DML values, which are added as query parameters
   * @param {Boolean} isOne - Array of DML values, which are added as query parameters
   * @param {Map} [postMapper] - SELECT post processing type conversion config
   * @returns {*}
   * @private
   */
  _executeSQL (sql, values, isOne, postMapper) {
    // support named binding parameters
    if (values && typeof values === 'object' && !Array.isArray(values)) {
      values = this._getValuesProxy(values)
    }

    if (this._isStatementType('select', sql)) {
      return this._executeSelect(sql, values, isOne, postMapper)
    }

    // Only bulk inserts will have arrays in arrays
    if (this._isStatementType('insert', sql) && Array.isArray(values[0]) && values.length > 1) {
      return this._bulkInsert(sql, values)
    }

    return this._runSingle(sql, Array.isArray(values[0]) ? values[0] : values)
  }

  _getValuesProxy (values) {
    return new Proxy(values, {
      getOwnPropertyDescriptor: (obj, prop) => {
        if (prop.length > 1 && prop.startsWith(':')) {
          return Object.getOwnPropertyDescriptor(obj, prop.slice(1))
        }
        return Object.getOwnPropertyDescriptor(obj, prop)
      },
      get: (obj, prop) => {
        if (prop.length > 1 && prop.startsWith(':')) {
          return obj[prop.slice(1)]
        }
        return obj[prop]
      },
      ownKeys: target => {
        return Reflect.ownKeys(target).map(key => `:${key}`)
      }
    })
  }

  _isStatementType (type, sql) {
    // Regex is faster than toLower + trim + startsWith
    return new RegExp(`^\\s*${type}`, 'i').test(sql)
  }

  _executeSelect (sql, values, isOne, postMapper) {
    return new Promise((resolve, reject) => {
      // All is faster than each for us, as the result needs to be returned as whole.
      this._traced(this._dbc.all, sql, values, (err, result) => {
        if (err) {
          err.failedQuery = sql
          return reject(err)
        }

        if (result) Object.setPrototypeOf(result, Array.prototype)

        resolve(this._returnFirstResultIfOne(isOne, postProcess(result, postMapper)))
      })
    })
  }

  _runSingle (sql, values) {
    return new Promise((resolve, reject) => {
      this._traced(this._dbc.run, sql, values, function (err) {
        if (err) {
          err.failedQuery = sql
          return reject(err)
        }
        resolve(this.changes)
      })
    })
  }

  /**
   * Prepare and execute SQL statement.
   *
   * @param {string} sql - SQL string to be prepared.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @returns {Promise} Promise, that resolves with HdbStatement if successful and rejects if not.
   */

  preparedExecute (sql, values) {
    const that = this
    return new Promise((resolve, reject) => {
      this._traced(this._preparedExecuteCb, sql, values, that, (error, results) => {
        if (!error) {
          resolve(results)
        } else {
          reject(error)
        }
      })
    })
  }

  /**
   * Wrapper to use callbacks, which are needed for tracing.
   */
  _preparedExecuteCb (sql, values, client, cb) {
    client
      .prepareStatement(sql)
      .then(statement => {
        return statement.execute(values)
      })
      .then(results => cb(null, results))
      .catch(error => cb(error))
  }

  _bulkInsert (sql, values) {
    return this.preparedExecute(sql, values).then(() => values.length)
  }

  _processExpand (cqn) {
    const queries = []
    const expandQueries = createJoinCQNFromExpanded(cqn, this._csn)

    for (const cqn of expandQueries.queries) {
      cqn._conversionMapper = getPostProcessMapper(this._toService, this._csn, cqn)

      const { sql, values } = sqlFactory(cqn, { customBuilder: CustomBuilder })
      queries.push(this._executeSelect(sql, values, false))
    }

    return rawToExpanded(expandQueries, queries, cqn.SELECT.one)
  }

  _processCascadeDelete (cqn) {
    return this.processNestedCQNs(
      createCascadeDeleteCQNs(this._csn && this._csn.definitions, cqn),
      this._execute.bind(this)
    )
  }

  _processDeepInsert (cqn) {
    return this.processNestedCQNs(
      [createDeepInsertCQNs(this._csn && this._csn.definitions, cqn)],
      this._execute.bind(this)
    )
  }

  _processDeepUpdate (cqn) {
    /* istanbul ignore next */
    return selectDeepUpdateData(this._csn && this._csn.definitions, cqn, this._execute.bind(this), this._context).then(
      selectData => {
        return this.processNestedCQNs(
          createDeepUpdateCQNs(this._csn && this._csn.definitions, cqn, selectData),
          this._execute.bind(this)
        )
      }
    )
  }

  _stream2Buffer (stream) {
    return new Promise(resolve => {
      const buffer = []
      stream.on('data', chunk => {
        buffer.push(chunk)
      })
      stream.on('end', () => {
        resolve(Buffer.concat(buffer))
      })
      stream.on('error', () => {
        stream.removeAllListeners('error')
        stream.push(null)
      })
    })
  }

  async _streamValues (cqn, values) {
    if (cqn.UPDATE || cqn.INSERT) {
      for (let i = 0; i < values.length; i++) {
        if (values[i] && typeof values[i].pipe === 'function') {
          values[i] = await this._stream2Buffer(values[i])
        }
      }
    }
  }

  /**
   * Prepare SQL statement.
   * Beware: For tracing use preparedExecute instead.
   *
   * @param {string} sql - SQL statement.
   * @returns {Promise} Promise, that resolves with SqliteStatement if successful and rejects if not.
   */
  prepareStatement (sql) {
    return new Promise((resolve, reject) => {
      this._dbc.serialize(() => {
        const stmt = this._dbc.prepare(sql, err => {
          if (err) {
            err.failedQuery = sql
            return reject(err)
          }

          resolve(new SqliteStatement(stmt, this._dbc))
        })
      })
    })
  }

  /**
   * Returns connection state.
   *
   * @returns {boolean} true for connected, false for not connected
   */
  isConnected () {
    return this._dbc.open === true
  }

  /**
   * Set database locale.
   *
   * Locale is currently not supported by the node.js Sqlite driver.
   * There is a possibility to set locale in Sqlite, for example, in Java:
   * https://stackoverflow.com/questions/13720092/why-and-where-to-call-setlocale
   */
  setLocale () {}

  /**
   * Set database user.
   *
   * Username/password is not supported by default in Sqlite.
   */
  setUser (user) {
    this._user = user || 'anonymous'
  }

  /**
   * Execute begin transaction.
   *
   * @returns {Promise} - Resolves if begin is successful, rejects if not.
   */
  begin () {
    this._transCount++

    if (this._transCount === 1) {
      return this.execute('BEGIN')
    }

    return resolve()
  }

  /**
   * Execute commit transaction.
   *
   * @returns {Promise} - Resolves if commit is successful, rejects if not.
   */
  commit () {
    if (this._transCount === 0) {
      return resolve()
    }

    this._transCount--

    if (this._transCount === 0) {
      return this.execute('COMMIT')
    }

    return resolve()
  }

  /**
   * Execute rollback transaction.
   *
   * @returns {Promise} - Resolves if rollback is successful, rejects if not.
   */
  rollback () {
    if (this._transCount === 0) {
      return resolve()
    }

    this._transCount--

    if (this._transCount === 0) {
      return this.execute('ROLLBACK')
    }

    return resolve()
  }

  /**
   * Forwards deploy to the base class providing client information.
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return super.deploy(csn, 'sqlite')
  }
}

module.exports = Client
