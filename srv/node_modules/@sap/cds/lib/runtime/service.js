const cds = require ('../cds')
const lib = require('@sap/cds-services'); lib.inject(cds)

/**
 * Decorate cds.service
 */

 module.exports = Object.assign ({__proto__:cds.builtin.classes.service}, {
    impl : fn=>fn,
    client : { for: lib.for },
    provider : { for: service_provider_for },
    adapter : { for: Object.assign (lib.to, {
        odata : lib.to.odata_v4,
        fiori : lib.to.odata_v4,
    }) },
    providers : [],
    passport : lib.passport,
    performanceMeasurement : lib.performanceMeasurement,
    bindings : require('./bindings'),
    path4, impl4,
})



function service_provider_for (def, /*in:*/ csn, o) {

    const options = { ...o, service:def.name, kind:o.use||o.kind }
    const provider = lib.service (csn, options)
    provider.$impl = impl4 (def, o.with)
    provider.path = path4 (def, o.at)

    provider.tx = (...args) => provider.transaction(...args)

    // adding convenience methods ...
    provider.on.succeeded = (event, entity, handler) => {
        if (!handler) [entity,handler] = [undefined,entity]
        return provider.on (event,entity, (req)=>{
            req.on('succeeded', ()=>handler(req))
        })
    }
    provider.on.failed = (event, entity, handler) => {
        if (!handler) [entity,handler] = [undefined,entity]
        return provider.on (event,entity, req=>{
            req.on('failed', ()=>handler(req))
        })
    }
    provider.on.resultsOf = (...args) => provider.after (...args)
    return provider
}



const { isdir, isfile, path:{ dirname, parse, resolve }} = cds.utils

/**
 * Resolve a service implementation function as follows...
 * 1. if _impl is a function --> got it
 * 2. if _impl is a string --> `require (it)` (using model source if available)
 * 3. if we got the model's source --> `require (<basename>.js) || require (js/<basename>.js) || require (handlers/<basename>.js)`
 */
function impl4 (def, _impl = def['@impl'], cwd=process.cwd()) { // NOSONAR

    // is it a direct impl passed via cds.serve(...).with (<>) ?
    if (typeof _impl === 'function')  return _found (_impl.name || '<in code>', _impl)

    // determine model's neighbourhood dir to search in...
    // Note: @source has precedence over $location as the latter
    // may refer to a merged csn file if loaded from csn.json
    const _source = def['@source'] || def.$location && def.$location.file
    const dir = _source && isdir(dirname(_source)) || '.'
    const root = resolve(dir)

    // fetch impl specified through @impl or via ds.serve(...).with (<>)
    // search in model's neighbourhood as well as relative to cwd
    if (_impl) {
        if (!_impl.endsWith('.js'))  _impl += '.js'
        return _fetch (_impl, /*in:*/ root, cwd)
        || _notFound() // fail if not found
    }

    // search for <service-file>.js in model's neighbourhood
    const twin = parse(_source).name + '.js'
    return _fetch (twin, /*in:*/ root, './js', './handlers')

    function _fetch (file, /*in:*/ root, ...subfolders) {
        for (let each of [root,...subfolders]) {
            const found = isfile (resolve (root, each, file))
            if (found)  return _found (found)
        }
    }

    function _found (_source, _impl) {
        return _impl ? { _source, _impl } : {
            _source, get _impl() { return require(this._source) }
        }
    }

    function _notFound (){
        throw new Error(`No such handler for ${def.name}: ${_impl}`)
    }
}

/**
 * Resolve a service endpoint path to mount it to as follows...
 * Use _path or def[@path] if given with leading '/' prepended if necessary.
 * Otherwise, use the service definition name with stripped 'Service'
 */
function path4 (def, _path = def['@path']) {
  if (_path)  return _path.replace(/^[^/]/, c => '/'+c)
  else  return '/' + ( // generate one from the service's name
    /[^.]+$/.exec(def.name)[0]  //> my.very.CatalogService --> CatalogService
    .replace(/Service$/, '')        //> CatalogService --> Catalog
    .replace(/^[A-Z]/, c => c.toLowerCase())  //> Catalog --> catalog
    .replace(/[A-Z][a-z]/g, c => '-'+c.toLowerCase())  //> FooBar --> foo-bar
    .replace(/[A-Z]/g, c => c.toLowerCase())  //> FOO --> foo
    .replace(/_/g,'-')  //> foo_bar --> foo-bar
  )
}
