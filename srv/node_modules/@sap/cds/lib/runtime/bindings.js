const DEBUG = /\b(y|all|serve)\b/.test (process.env.DEBUG) && console.warn
// || console.debug

const cds = require ('../cds')
const { readFile, readFileSync, writeFile, writeFileSync } = require ('fs')
const [ read, write ] = [ readFile, writeFile ].map(require('util').promisify)
const path = require ('path')
const os = require ('os')


class Bindings {

    static import(){
        return (Bindings.instance = new Bindings).import()
    }
    static export(...args){ return (
        Promise.resolve (Bindings.instance || (new Bindings).load())
     ) .then (b => b.export(...args)) }

    constructor() {
        Bindings.instance = this
        this.cds = {provides:{}}
    }

    async load (sync) {
        const tmp = path.resolve (cds.env.tmp || os.tmpdir())
        this._source = path.join (tmp, 'cds-services.json')
        DEBUG && DEBUG('[cds] - reading bindings from:', this._source)
        try { Object.assign (this, JSON.parse (sync ? readFileSync (this._source) : await read (this._source))) }
        catch (e) { /* ignored */ }
        return this
    }
    async store (sync) {
        DEBUG && DEBUG ('[cds] - writing bindings to:', this._source)
        const json = JSON.stringify ({cds:this.cds},null,'  ')
        return sync ? writeFileSync (this._source, json) : write (this._source, json)
    }

    async import() {
        const required = cds.env.requires
        if (required) {
            const provided = (await this.load()) .cds.provides
            for (let each in provided) {
                const req = required[each]
                if (req)  Object.assign (
                    req.credentials || (req.credentials = {}),
                    provided[each].credentials || provided[req.service].credentials
                )
            }
        }
        return this
    }

    async export (services, url) {
        this.cleanup (this.url = url)
        // register our services
        const provides = this.cds.provides
        for (let each of services) {
            if (each.name in cds.env.requires)  continue
            provides[each.name] = {
                kind: each.options.to || 'odata',
                credentials: {
                    ...each.options.credentials,
                    url: url + each.path
                }
            };
        }
        process.on ('exit', ()=>this.purge())
        return this.store()
    }

    purge() {
        this.load(true)
        DEBUG && DEBUG ('[cds] - purging bindings from:', this._source)
        this.cleanup()
        this.store(true)
    }

    cleanup (url=this.url) {
        // remove all services served at the same url
        const all = this.cds.provides
        for (let [key,srv] of Object.entries (all)) {
            if (srv.credentials && srv.credentials.url && srv.credentials.url.startsWith(url))  delete all [key]
        }
        return this
    }
}


class Dummy {
    static import(){ return this }
    static export(){ return this }
}

module.exports = cds.env.no_bindings || process.env.NODE_ENV === 'production' ? Dummy : Bindings
/* eslint no-console:off */
