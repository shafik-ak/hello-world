module.exports = Object.assign (cds_serve, { activate:_activate })
const cds = require ('../cds')
const cache = cds_serve.cache = {}

const ProtocolAdapter = {for:(srv, to='odata_v4') => {
  if (srv._adapters) {
    const a = srv._adapters[to];  if (a) return a
  } else {
    Object.defineProperty (srv,'_adapters', {value:{}})
  }
  const adapter4 = cds.service.adapter.for[to]
  if (adapter4)  return srv._adapters[to] = adapter4(srv)
  else throw new Error (`service protocol ${to} is not supported`)
}}


const _unfold_localized = require('../alpha/_localized').serve

/**
 * Load given model(s) and construct providers for all defined services.
 */
function cds_serve (service_or_model, _options) { // NOSONAR

  if (Array.isArray(service_or_model) && service_or_model.length === 1)
    service_or_model = service_or_model[0]

  if (!_isIdentifier(service_or_model)) {
    (_options || (_options={})) .from = service_or_model
    service_or_model = 'all'
  }

  cds.ql.disable_cds_run()

  const o = {..._options}, fluent = {
    // Fluent API to fill in options...
    from (model) { o.from = model; return this },
    to (protocol) { if (protocol) { o.to = protocol }  return this },
    at (path) { if (path) { o.at = path }  return this },
    with (impl) { if (impl) { o.with = impl }  return this },
    // Fluent API to finalize our job...
    in (app) { ready.then (all => _mount(all,app,o)); return this },
    then (r,e) { return ready.then (all => r(_return(all,o)), e) },
    catch (e) { return ready.catch(e) },
  }

  const ready = Promise.resolve() //> runs after options filled in fluently:
  .then (()=> _load (service_or_model,o))
  .then (csn => _providers4 (csn,o))

  return fluent
}


function _isIdentifier (x) {
  // if (x === 'srv' || x === 'app')  return false
  return typeof x === 'string' && /^[\w$]*$/.test (x)
}


/**
 * Load the given model if it's not already a parsed csn passed in
 */
function _load (service_or_model, o) {

  let model

  //> cds.serve(...).from('app')
  if (o.from) {
    model = o.from
    o.service = service_or_model
  }

  if (!model) model = o.from

  //> cds.serve(...).from(csn)
  if (typeof model === 'object' && !Array.isArray(model))
    return model

  //> cds.serve(...)
  if (!model) {
    //> cds.serve(..., {service})  ==>  cds.serve(service) .from (...)
    //> Note: this is for compatibility only; it's not documented anymore
    if (o.service)  model = service_or_model

    //> cds.serve('all')  ==>  cds.serve('all').from('all')
    //> cds.serve(service)  ==>  cds.serve(service).from('all')
    else { model = 'all'; o.service = service_or_model }
  }

  if (model === 'all' || model[0] === 'all') {
    const {app,srv} = cds.env.folders
    model = [[ app, srv ], 'services', '.' ].find (m => cds.resolve(m))
    if (!model)  throw new Error (`[cds] - \n
      No service models found in current working directory.
      Make sure you call cds.serve in the root of your project.
    `)
  }

  const key = Array.isArray(model) ? model.join(';') : model
  const cached = cache[key]
  if (cached) return cached

  return cache[key] = cds.load (model)
}


/**
 * Construct providers for all services defined in the loaded model.
 */
function _providers4 (csn, o, n=0) { // NOSONAR

  const providers = [], required = cds.env.requires
  const _include = !o.service || o.service === 'all' ? ()=>true
    : (def) => def.name.endsWith (o.service)
  const _exclude = (def) => {
    if (def['@cds.ignore'] || def['@cds.serve.ignore'])  return true // exclude all marked ignore
    if (o.mocked && def.name in cds.services)  return true // skip already served ones
    if (!o.mocked && def.name in required)  return true // skip required ones, if not mocked
  }

  if (!cds.services.skipped)  cds.services.skipped = []
  const {requires:{db}} = cds.env, ad_hoc = cds.options
  const is_sqlite = db && db.kind === 'sqlite'  ||  ad_hoc && ad_hoc.kind === 'sqlite'
  cds.reflect(csn) .foreach (cds.service, def => {
    if (!_include(def) || _exclude(def))  return cds.services.skipped.push ({ service:def.name, csn })  // might be mocked afterward
    if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
    if (is_sqlite)  _unfold_localized (csn)
    const provider = cds.service.provider.for (def, csn, o)
    if (is_sqlite)  _unfold_localized (provider.model) // REVISIT: this is because provider._csn = provider.model
    cds.service.providers.push (provider)
    cds.services [def.name] = provider
    providers.push (provider)
    PATCH_dispatch (provider)
  })

  if (!o.mocked && !o['with-mocks'])  _activate (providers)

  return providers
}

/**
 * Invoke all provided service implementation functions or classes.
 * IMPORTANT: this is run in a second pass after all providers are
 * constructed and registered so implementations can connect to
 * each others.
 */
function _activate (providers) {
  for (let each of providers) {
    if (each.$impl)  each.impl (each.$impl._impl)
  }
}

/**
 * Add constructed providers to express app
 */
function _mount (providers, /*to:*/ app, options) {
  cds.serve.app = app
  if (providers.length == 0)  return providers
  for (let each of providers) {
    // audit logger to be provided here, current workaround: take it from service
    cds.service.performanceMeasurement(app)
    cds.service.passport(each, app, each._auditLogger, options)
    // add use method to services for backward compatibility
    each.use = app.use
    // catch Fiori's lookup requests for resources in webapp and ugly warnings
    app.use (each.path+'/webapp/', (_,res)=> res.sendStatus(404))
    // register the actual adapter
    app.use (each.path, ProtocolAdapter.for (each, options.to))
    cds.emit ('serve', each)
  }
  // REVISIT too confuding usage of .skipped, .mocked, .mock, ...
  // NOTE: all providers are read from the same model --> we use the first provider's model as *the* model
  if (!options.skipped) cds.emit ('served', { model:providers[0].model, app })
  return providers
}

/**
 * Returns a single picked provider or a map of all constructed providers
 */
function _return (providers,o) {
  if (providers.length === 0)  return
  let all={}, srv='none'
  for (let each of providers) {
    srv = all[each.name] = _as_express_handler (each,o)
  }
  if (providers.length === 1 && srv.name.endsWith(o.service) >= 0) { // NOSONAR
    if (!(srv.name in srv))  Object.assign (srv,all)  // NOSONAR
    return srv
  }
  else return all
}

/**
 * Decorates services as handler functions to delegate requests to the default protocol adapter.
 * This supports usages like this:
 * @example
 * const { CatalogService } = cds.serve(...)
 * app.use ('/cats', CatalogService)
 */
function _as_express_handler (srv,o) {
    const adapter = ProtocolAdapter.for (srv, o.to)
    const fn = (...args) => adapter(...args)
    Object.setPrototypeOf (fn, srv)
    Object.defineProperty (fn, 'name', {value:srv.name})
    return fn
}

function PATCH_dispatch (provider) {
  const {processEvent:dispatch} = provider
  provider.dispatch = provider.processEvent = (req, ...etc) => {
    if (req._.odataReq) Object.defineProperty (req, 'params', {get:()=>{
      const params = req._.odataReq._uriInfo._pathSegments .map (seg => seg._keyPredicates[0] && seg._keyPredicates[0]._value)
      Object.defineProperty (req, 'params', { value: params })
      return params
    }, configurable:true })
    if (req._.req) {
      req._.path = req._.odataReq ? req._.odataReq._url.pathname : req._.req.path
      req._.query = req._.odataReq ? req._.odataReq._queryOptions : req._.req.query
      ;(req._.shared && req._.shared.req || req._.req) .emit ('dispatch', req)
    }
    return dispatch.call (provider, req, ...etc)
  }
}
