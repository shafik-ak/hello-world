const { Service, Promised } = require ('./service-client')
const cds = require('../cds')

module.exports = Object.assign (cds_connect, {
	to: cds_connect_to,
	db: cds_connect,
})

/**
 * Connects to a service as primary datasource.
 * The connected service is set as cds.db.
 */
function cds_connect (options) {
	if (options === false)  return
	if (cds.db)  return (!options || typeof options === 'string') ? cds : _error (`You need to disconnect before creating a new primary connection!`)
	cds.db = cds.services.db = cds_connect_to (options || 'db', undefined, true)
	return cds
}


/**
 * Connects to a specified service, either served locally, with ad-hoc options
 * or with options as configured in cds.env.requires.<datasource>.
 */
function cds_connect_to (datasource, options, ___primary) {
	if (typeof datasource === 'object')  [ datasource, options ] = [ undefined, datasource ]

	const cached = cds.services [datasource]
	if (cached)  return !options ? cached : _error (`attempt to reconnect to '${datasource}' with new options`)

	const [ds,o] = _options4 (datasource, options)
	const srv = new Service (ds,o, ___primary)
	if (Array.isArray(o.model) || typeof o.model === 'string') {
		srv.model = _not_yet_loaded
		var model = cds.load (o.model) .then (csn => {
			if (csn) srv.model = _unfold_localized (cds.linked (cds.compile.for.odata(csn)))
			return srv
		})
	}
	const promised = Promised (srv, model)
	if (o.primary || ds === 'db')  cds.db = cds.services.db = promised
	if (ds)  cds.services [datasource] = promised

	cds.emit ('connect', srv)
	return promised
}


cds.on ('disconnect', srv => {
	if (srv === cds.db)  cds.db = undefined
	delete cds.services [srv.name]
})


function _options4 (name, _options) { // NOSONAR
	const [, kind, url ] = /^(\w+):(.*)/.exec(name) || []
	if (kind) return _options4 (kind, {
		kind, ..._options, credentials: { database:url }
	})
	const conf = cds.env.requires [name]
	const o = { ...conf, ..._options }
	if (o.use)  o.kind = o.use
	if (!o.kind) {
		o.kind = name === 'sqlite' ? name : o.driver
		if (!o.kind && !o.silent) { // still not --> provide a good error message...
			if (!conf && name) _error (`didn't find a configuration for 'cds.requires.${name}'`)
			if (conf)  _error (`configuration for 'cds.requires.${name}' lacks mandatory property 'kind'`)
			else  _error (`provided options object lacks mandatory property 'kind'`)
		}
	}
	// comes from defaults now
	// if (o.kind === 'sqlite' && !o.credentials)  o.credentials = { database: `sqlite.db` }
	return [ name, o ]
}


const {connect:_unfold_localized} = require('../alpha/_localized')
const _not_yet_loaded = new Proxy ({}, {
	get() { throw new Error('Model not yet loaded') }
})

function _error (msg) {
	throw new Error ('[cds.connect] - '+ msg)
}
