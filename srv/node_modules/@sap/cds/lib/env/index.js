const defaults = require.resolve ('./defaults'), DEFAULTS = require(defaults)
const user_home = require('os').homedir()
const path = require('path')
const fs = require('../utils/fs')
const cache = {}
const compat = require('./compat')
const process_cwd = process.cwd()
let tmp

/**
 * Both a config inctance as well as factory for.
 */
const Config = [ class {

  /**
   * This is the one and only way to constructs new instances.
   * Public API is through `cds.env.for (<context>)`
   * @param context - the app context, like 'cds' or 'your-app'
   * @returns {Config}
   */
  for (context, cwd=process_cwd, _ignore_cache=false) {
    const cached = cache[cwd] || (cache[cwd] = {})
    return !_ignore_cache && cached[context] || (
      cached[context] = new Config (context, cwd)
    )
  }


  /**
   * Only used internally, i.e. through cds.env.for(<context>)
   */
  constructor (_context, _home) {

    Object.assign (this, { _context, _home, _sources:[] })

    if (_context === 'cds')  compat (this)
    if (_context === 'cds')  this._add (DEFAULTS, defaults)
    if (!_home)  return

    // 1. fill-in additional process.env content in dev
    if (process.env.NODE_ENV !== 'production') {
      this._add_to_process_env (_home, 'default-env.json')
    }

    // 2. read config sources in defined order
    if (_context === 'cds') {
      this._load (user_home, '.cdsrc.json')
      this._load (_home, '.cdsrc.json')
    }
    this._load (_home, 'package.json', p => p[_context])
    this._add (_process_env4(_context), '{process.env}')

    // 3. resolve profiles after config is filled completely
    // this._resolve_profiles()

    // 4. handle service configurations in cds.requires
    this._add_vcap_services (process.env.VCAP_SERVICES)
    this._link_required_services()

  }

  /**
   * Retrieves the value for a config option, specified as a property path.
   */
  get (option) {
    if (!option)  return
    return option.split('.').reduce ((p,n)=> p && p[n], this)
  }

  /**
   * Provides access to system defaults for cds env.
   */
  get defaults() { return DEFAULTS }
  get tmp() { return tmp || (tmp = require('os').tmpdir()) }

  /**
   * For WING only to find out whether this is a Java or Node.js project
   */
  get "project-nature" () {
    const has_pom_xml = [this.folders.srv,'.'] .some (
      f => fs.isfile (path.join (this._home, f, 'pom.xml'))
    )
    return has_pom_xml ? 'java' : 'nodejs'
  }


//////////////////////////////////////////////////////////////////////////
//
//    DANGER ZONE!
//    The following are internal APIs which can always change!
//


  /** @returns {Config} */
  _load (cwd, res, _conf=o=>o) {
    const json = _readJson (res = path.join(cwd, res))  // only support JSON
    if (json) {
      const conf  = _conf (json)
      if (conf) {
        this._sources.push (res)
        _merge (this, conf, this.profiles)
      }
    }
    return this
  }

  /** @returns {Config} */
  _add (conf, /*from:*/ _src) {
    if (!conf)  return this
    if (_src)  this._sources.push (_src)
    _merge (this, conf, this.profiles)
    return this
  }

  // _resolve_profiles (dst=this, src=this) {
  //   _merge (dst, src, this.profiles)
  // }

  _add_to_process_env (cwd, filename) {
    const file = path.resolve (cwd,filename)
    const json = _readJson (file)
    if (!json)  return
    for (const key in json) {
      if (key in process.env)  continue // do not change existing env vars
      const val = json[key]
      process.env[key] = typeof val === 'string' ? val : JSON.stringify(val)
    }
    this._sources.push (file)
  }

  _link_required_services () {
    const { requires } = this
    for (let each in requires)  requires[each] = _merged (each)
    function _merged (key) {
      let entry = requires [key]
      if (entry._is_merged || entry.kind === key || !(entry.kind in requires))  return entry
      else return Object.defineProperty (
        _merge ({..._merged(entry.kind)}, entry, false, 'cloned'),
        '_is_merged', {value:true}
      )
    }
  }

  _add_vcap_services (VCAP_SERVICES) {
    if (this.features && this.features.vcaps === false)  return
    if (!this.requires)  return
    if (!VCAP_SERVICES) return
    try {
      const vcaps = JSON.parse (VCAP_SERVICES)
      const any = _add_vcap_services_to (this, vcaps)
      if (any)  this._sources.push ('{VCAP_SERVICES}')
    } catch(e) {
      throw new Error ('[cds.env] - failed to parse VCAP_SERVICES:\n  '+ e.message)
    }
  }



//////////////////////////////////////////////////////////////////////////
//
//    FORBIDDEN ZONE!
//    The following are hacks for tests which should not exist!
//    Tests should test public APIs, not internal ones.
//    Tests should even less intrude hacks to core components
//


  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _for_tests (...conf) {
    const env = new Config('cds')
    env.profiles = _determineProfilesFrom (process.env)
    this._for_tests.vcaps = (vcaps) => { _add_vcap_services_to (env, vcaps)}
    // merge all configs, then resolve profiles (same as in 'for' function above)
    for (let c of [...conf].reverse())  _merge(env, c, env.profiles)
    // env._resolve_profiles()
    return env
  }
  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _merge_with (src) {
    _merge (this, src, this.profiles)
    return this
  }

} ][0] //> to make this a nameless class




//////////////////////////////////////////////////////////////////////////
//
//    Local Helpers...
//

/**
 * @returns {Config} dst
 */
function _merge (dst, src, _profiles,_clone) { // NOSONAR
  for (let p in src) {
    const v = src[p]
    if (_profiles && p[0] === '[') {
      if (_profiles.includes(p.slice(1,-1)))  _merge (dst, v, _profiles, _clone)
      delete dst[p]
    }
    else if (typeof v === 'object' && !Array.isArray(v)) {
      if (!dst[p])  dst[p] = {}
      else if (_clone)  dst[p] = {...dst[p]}
      _merge (dst[p], v, _profiles)
    }
    else if (v !== undefined)  dst[p] = v
  }
  return dst
}

function _process_env4 (prefix) {
  const PREF_ = prefix.toUpperCase()+'_'
  const env = process.env, all = JSON.parse (env[PREF_+'CONFIG'] || '{}')
  for (let p in env) if (p.startsWith(PREF_) && p !== PREF_+'ENV' && p !== PREF_+'CONFIG') {
    let o=all, path = p.slice(PREF_.length).toLowerCase().split('_')
    while (path.length > 1) {
      let p = path.shift()
      if (!o[p])  o[p] = {}
      o = o[p]
    }
    o[path.shift()] = env[p]
  }
  return all
}


function _add_vcap_services_to (env, vcaps={}) { //NOSONAR
  let any
  for (let service in env.requires) {
    const conf = env.requires [service]
    const { credentials } = (
      conf.vcap && _fetch (conf.vcap) ||  //> alternatives, e.g. { name:'foo', tag:'foo' }
      _fetch ({ name: service })  ||
      _fetch ({ tag: env._context+':'+service }) ||
      _fetch ({ tag: conf.kind }) || // important for hanatrial, labeled 'hanatrial', tagged 'hana'
      _fetch ({ label: conf.kind }) ||
      {/* not found */}
    )
    if (credentials)  any = conf.credentials = Object.assign ({}, conf.credentials, credentials)
  }
  return any

  function _fetch (predicate) { //NOSONAR
    const filter = _filter4 (predicate)
    for (let stype in vcaps) {
      const found = _array(vcaps,stype) .find (filter)
      if (found)  return found
    }
  }

  function _filter4 (predicate) {
    let filter;  for (let key in predicate) {
      const val = predicate[key], prev=filter, next=(
        key === 'tag' ? e => _array(e,'tags').includes (val)
        : e => val !== undefined ? e[key] === val : false
      )
      filter = prev ? e => prev(e) || next(e) : next
    }
    return filter
  }

  function _array(o,p) {
    const v = o[p]
    if (!v || Array.isArray(v))  return v || []
    throw new Error(`Expected '${p}' to be an array, but was: ${require('util').inspect(vcaps)}`)
  }

}

function _readJson (file) {
  try {
    const src = fs.readFileSync (require.resolve (file))
    return JSON.parse (src)
  } catch (e) {
    if (e instanceof SyntaxError)  console.error(`Error parsing '${file}': ${e.message}`)
    else if (e.code !== 'MODULE_NOT_FOUND')  console.error(e.message)
  }
}

function _determineProfilesFrom (env = process.evnt) {
  if (env.NODE_ENV !== 'production' && !/\bdevelopment\b/.test(env.CDS_ENV)) {
    if (env.CDS_ENV)  env.CDS_ENV += ',development'
    else  env.CDS_ENV = 'development'
  }
  const split = (x) => env[x] ? env[x].split (/\s*,\s*/) : []
  const profiles = [ ...split ('NODE_ENV'), ...split ('CDS_ENV') ]
  return [...new Set (profiles)]
}


Config.prototype.profiles = _determineProfilesFrom (process.env)
module.exports = Config.prototype.for ('cds', process_cwd)
/* eslint no-console:0 */
