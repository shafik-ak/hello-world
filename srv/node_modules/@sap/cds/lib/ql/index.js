const cds = require('../cds'), {extend} = cds
const lib = require ('@sap/cds-ql');  lib.inject (cds)

const ql = module.exports = extend ((_context) => ({
    get SELECT() { return {
        from(...args) { return Object.defineProperty (SELECT.from(...args), '_context', {value:_context}) },
    }},
    get INSERT() { return {
        into(...args) { return Object.defineProperty (INSERT.into(...args), '_context', {value:_context}) },
    }},
    UPDATE(...args) {
        return Object.defineProperty (UPDATE(...args), '_context', {value:_context})
    },
    get DELETE() { return {
        from(...args) { return Object.defineProperty (DELETE.from(...args), '_context', {value:_context}) },
    }},
})) .with (lib.statements, {
    connect: (...args) => new lib.Service(...args), // FIXME: for compatibility to double-services messaging implementation only
    disable_cds_run
})




const ANY = ql.BaseStatement.prototype
const {inspect} = require('util')

extend (ANY) .with ({

    /** Turns all queries into Thenables which execute with primary db by default */
    then(r,e) {
        if ('_promised' in this)  return this._promised.then (r,e)
        const srv = !this._target.service ? cds.db : cds.services [this._target.service.name]
        return 'then' in srv ? srv.then (s => this._then(s,r,e)) : this._then(srv,r,e)
    }, _then (srv,r,e) {
        const tx = !this._context ? srv : srv.transaction (this._context)
        const p = tx.run (this) .then (r,e)
        Object.defineProperty(this, '_promised', {value:p})
        return p
    },

    /** Beautifies output in REPL */
    [inspect.custom]() {
        const colors = process.env.CDS_TERM_COLORS !== false
        for (let x in this) {
            const v = this[x];  if (typeof v === 'function')  continue
            return inspect ({[x]:v}, {colors, depth: 22})
            .replace (/^\w*\s/,'')
            .replace(/{ ref: \[([^\]]*)\] }/g, (_,ref) => '{ref:['+ref.slice(1,-1)+']}')
            .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
            .replace(/{ (xpr|ref|val): /g, '{$1:')
        }
    },

})

// Capture q._target when creating new queries
const _smart = (ANY_for) => (e, ...etc) => {
    // NOTE: DO NOT add || entity.name, as ql.BaseStatement impl does something special for views
    const q = ANY_for (e._entityName || e, ...etc)
    Object.defineProperties (q, typeof e === 'string' ? {
        _target: {value: {name:e}}
    } : { // some more special handling to have typed classes look like CSN definitions
        _target: {value: !e._entityName ? e : {__proto__:e, name: e._entityName }},
    })
    return q
}


const { SELECT } = ql
const SELECT_from = _smart (SELECT.from)
const SELECT_prototype = SELECT.from('x').__proto__
const SELECT_columns = SELECT_prototype.columns

extend (SELECT) .with ({

    /**
     * @example
     * SELECT.from('Foo',(foo)=>{...})
     * SELECT.from('Foo',{ID:11})
     * SELECT.from('Foo',11)
     */
    from (entity, a2, a3) {
        if (a2 === undefined || typeof a2 === 'function' || Array.isArray(a2)) {
            return SELECT_from (entity) .columns (a2)
        }
        if (typeof a2 !== 'object') {
            const ID = entity.keys ? Object.keys(entity.keys)[0] : 'ID'
            a2 = { [ID]: a2 }
        }
        return SELECT_from (entity) .byKey (a2) .columns (a3)

        // else throw new Error (`
    //     Invalid value for second argument in call to SELECT.from(...,<arg2>).
    //     Expected none or one of 'function', 'array', 'object', 'number',
    //     or 'string', but received a '${typeof a2}'
    //     `)
    },

    /**
     * @example
     * SELECT.distinct(Foo)
     * SELECT.distinct(Foo,{ID:11})
     * SELECT.distinct(Foo,(foo)=>{...})
     * SELECT.distinct.from(Foo)
     * SELECT.distinct([a,b]).from(Foo)
     */
    distinct: Object.assign ((...args) => {
        // SELECT.distinct('Foo', foo=>{...})
        if (args.length === 2 && typeof args[1] === 'function') {
            return SELECT.distinct.from (...args)
        }
        // SELECT.distinct('Foo')
        if (args.length === 1 && !Array.isArray(args[0])) {
            const q = SELECT.distinct.from (args[0])
            extend (q,) .with ({ from: (entity) => SELECT.distinct.from (entity) .columns (...args) })
            return q
        }
        // SELECT.distinct('a','b').from('Foo')
        else return {
            from: (entity) => SELECT.distinct.from (entity) .columns (...args)
        }
    },{
        // SELECT.distinct.from('Foo', ...)
        from (...args) {
            const q = SELECT.from(...args)
            q.SELECT = { distinct:true, ...q.SELECT }
            return q
        }
    }),

    one:  Object.assign ((...args) => {
        // SELECT.one('Foo', foo=>{...})
        if (args.length === 2 && typeof args[1] === 'function') {
            return SELECT.one.from (...args)
        }
        // SELECT.one('Foo')
        if (args.length === 1 && !Array.isArray(args[0])) {
            const q = SELECT.one.from (args[0])
            extend(q) .with ({ from: (entity) => SELECT.one.from (entity) .columns (...args) })
            return q
        }
        // SELECT.one('a').from('Foo')
        else return {
            from: (entity) => SELECT.one.from (entity) .columns (...args)
        }
    },{
        // SELECT.one.from('Foo', ...)
        from (...args) {
            const q = SELECT.from(...args)
            q.SELECT = { one:true, ...q.SELECT }
            return q
        }
    }),

})

extend (SELECT_prototype) .with ({

    byKey,

    /** Asllows to redirect queries
     * @example
     * const SELECT = req.query
     * return SELECT.from ('OtherEntity')
     */
    from (...args) {
        const q = SELECT.from (...args), {from} = q.SELECT
        Object.assign (q.SELECT, this.SELECT, {from})
        return q
    },

    /** @example
     * SELECT.from('Foo') .columns ((foo)=>{...})
     */
    columns (cols, ...more) {
        if (!cols) return this
        if (typeof cols === 'function')  cols = _projection4 (cols, this.entity)
        return SELECT_columns.call (this,cols,...more)
    },

    /** @example
     * SELECT.from(...).expand(...)
     */
    expand (ref,cols, exp='expand') {
        const { SELECT } = this, columns = SELECT.columns || (SELECT.columns=[])
        const col = {ref:ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
        columns.push (col)
        return this
    },

    /** @example
     * SELECT.from(...).inline(...)
     */
    inline (ref,cols) {
        return this.expand (ref,cols,'inline')
    },

    /** @example
     * SELECT.from(...).foreach(...)
     */
    foreach (callback) {
        return this.then (rows => rows.map (callback))
    },

})


const INSERT_into = _smart (ql.INSERT.into)
const INSERT = (...entries) => ({ into(entity) {
    return INSERT.into (entity) .entries (...entries)
}})
INSERT.into = (entity,...etc) => {
    const q = INSERT_into (entity)
    if (etc.length)  q.entries (...etc)
    return q
}
extend (ql) .with ({ INSERT })


const UPDATE_ = ql.UPDATE
const UPDATE_prototype = UPDATE_('x').__proto__
const UPDATE_set = UPDATE_prototype.set
const UPDATE = ql.UPDATE = _smart ((entity,a2) => {
    if (a2) {
        if (typeof a2 !== 'object')  a2 = {ID:a2}
        return UPDATE_(entity) .byKey (a2)
    }
    return UPDATE_(entity)
})
UPDATE.entity = UPDATE

extend (UPDATE_prototype) .with ({

    byKey,

    /** Add support for UPDATE('Foo').set ( expr | fragments | feather ) */
    set(...args) {  // NOSONAR

        if (typeof args[0] === 'object') return UPDATE_set.apply (this, args)
        const cqn = this.UPDATE.data = {}
        if (args.length === 1) for (let each of _data(args[0])) {
            const {xpr:[lhs,op,...rhs]} = cds.parse.expr (each)
            cqn[lhs.ref.join('.')] = _rhs (lhs, op, ...rhs)
        } else for (let i=0; i<args.length; ++i) {
            const [,col,op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec (args[i])
            cqn[col] = _rhs (col, op, {val:args[++i]})
        }
        function _rhs (lhs, op, ...rhs) {
            if (op === '=')  return rhs.length === 1 ? rhs[0] : {xpr:rhs}
            if (op.length === 2 && op[1] === '=')  return {xpr:[ lhs.ref ? lhs : {ref:[lhs]}, op[0], ...rhs ]}
            else throw new Error ('Invalid operator in UPDATE(...).set() expression: '+ op)
        }
        return this
    }
})


const { DELETE } = ql
const DELETE_from = _smart (DELETE.from)
const DELETE_prototype = DELETE.from('x').__proto__

extend (DELETE) .with ({
    from (entity, a2) {
        if (a2 === undefined) {
            return DELETE_from (entity)
        }
        if (typeof a2 !== 'object') {
            const ID = entity.keys ? Object.keys(entity.keys)[0] : 'ID'
            a2 = { [ID]: a2 }
        }
        return DELETE_from (entity) .byKey (a2)
    }
})
extend (DELETE_prototype) .with ({
    byKey
})

function _data(s) {  // NOSONAR
    let all=[], start=0, scope=0, close=0, stack=[ close ]
    for (let i=0; i<s.length; ++i) {
        const c = s[i]
        if (c === ',' && !scope) {
            all.push(s.slice(start,i))
            start = i+1
        } else if (c === "'") {
            while (i<s.length) {
                if (s[++i] === "'") {
                    if (s[i+1] === "'")  ++i  // NOSONAR
                    else break
                }
            }
        }
        else if (c === '(') { scope++; stack.unshift(close=')') }
        else if (c === '[') { scope++; stack.unshift(close=']') }
        else if (c === '{') { scope++; stack.unshift(close='}') }
        else if (c === close) { scope--; stack.shift(); close = stack[0] }
    }
    all.push (s.slice(start))
    return all
}

/**  */
function _projection4 (x, entity) { /* eslint no-unused-vars: off */ // NOSONAR
    if (Array.isArray(x))  return x.map (c => c.ref ? c : {ref:c.split('.')})
    if (typeof x === 'function') {
        const columns=[]
        x (new Proxy ({},{
            get: (_,p) => {
                let col = {ref:[p]};  columns.push(col)
                return new Proxy (noop,{
                    // handle getters like (foo)=>{ foo.bar.car }
                    get: (_,p,me) => {
                        if (p === 'where')  return pred => { col.where = _predicate4(pred); return me }
                        if (p === 'as')  return alias => { col.as = alias; return me }
                        else { col.ref.push(p); return me }
                    },
                    // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
                    apply: (_,__,[fn,{levels=1}={}]) => {
                        if (/^_\b/.test(fn)) {
                            // inline
                            col.inline = _projection4(fn)
                            // REVISIT: following is a flattening implementation, in case cds.ql does not support .inline
                            // columns.pop() // remove the expanded col
                            // for (let each of _projection4(fn)) { // replace by n inlined ones
                            //     columns.push (col = {...each, ref:[...col.ref,...each.ref]})
                            // }
                        } else {
                            // expand
                            col.expand = _projection4(fn)
                            while (--levels) { // add n-level deep hierarchy expands
                                col.expand.push (col = {...col, expand: [...col.expand] })
                            }
                        }
                    },
                })
            }
        }))
        return columns
    }
    else throw new Error ('invalid second argument for SELECT.from(entity,projection)')
}


function byKey (ID) {
    if (typeof ID !== 'object') ID={ID}
    if (this.SELECT)  this.SELECT.one = true
    return this.where (ID)
}

/**
 * Helper to create a predicate from a feather object
 */
function _predicate4 (o) {
    const predicates = []
    for (let each in o) {
        predicates.push ('and', {ref:each.split('.')}, '=', {val:o[each]})
    }
    return predicates.slice(1)
}

function disable_cds_run(){
    if (disable_cds_run.once || cds.env.singletenant)  return; else disable_cds_run.once = true
    const disabled = ()=>{ throw new Error (`
    Shortcut srv.run() is only available in plain node programs and disabled
    when running services. Always run queries like that in event handlers:
     srv.on('READ','Foo', (req)=>{
        const tx = cds.transaction(req)
        tx.run (SELECT.from('Foo'))
     }
    `)}
    // delete query.then
    Object.defineProperty (ANY, 'then', {value:disabled})
    Object.defineProperty (lib.Service.prototype, 'run', {value:disabled})
}
disable_cds_run.once = true //> REVISIT: switching that off for the time being
const noop=()=>{}
