import {Definition} from "./specs/CSN"
import * as CQN from "./specs/CQN"
import { STATUS_CODES } from "http"

export type Query = CQN.Query

export class ConstructedQuery {
	then(_resolved:(x:any)=>any, _rejected:(e:Error)=>any) : any
}

interface Constructable<T> {
	new(...args: any[]): T
}

// export = _cds;
export type _cds = {ql:QL & ((context:object) => QL)}

declare class QL {
	SELECT : typeof SELECT
	INSERT : typeof INSERT
	UPDATE : typeof UPDATE
	DELETE : typeof DELETE
	CREATE : typeof CREATE
	DROP : typeof DROP
}


export class SELECT<T> extends ConstructedQuery {
	static distinct : typeof SELECT
	static one : typeof SELECT_one
	static from (entity: Definition | string, primaryKey? : number | string | object, projection? : (e:any)=>void) : SELECT<any>
	static from <T> (entity:Constructable<T>, primaryKey : number | string | object, projection? : (e:T)=>void) : SELECT<T> & Promise<T>
	static from <T> (entity:Constructable<T>, projection? : (e:T)=>void) : SELECT<T> & Promise<T[]>
	static from <T> (entity:T, primaryKey : number | string | object, projection? : (e:T)=>void) : SELECT<T> & Promise<T>
	static from <T> (entity:T, projection? : (e:T)=>void) : SELECT<T> & Promise<T[]>
	byKey (primaryKey? : number | string | object) : SELECT<T> & Promise<T>
	columns (projection:(e:T)=>void) : this
	columns (...col:string[]) : this
	where (predicate:object) : this
	where (...expr : any[]) : this
	having (...expr : string[]) : this
	having (predicate:object) : this
	groupBy (...expr : string[]) : this
	orderBy (...expr : string[]) : this
	limit (rows : number, offset? : number) : this
	SELECT : CQN.SELECT
}

export class SELECT_one<T> extends SELECT<T> {
	static from (entity: Definition | string, primaryKey? : number | string | object, projection? : (e:any)=>void) : SELECT<any>
	static from <T> (entity:Constructable<T>, projection? : (e:T)=>void) : SELECT<T> & Promise<T>
	static from <T> (entity:Constructable<T>, primaryKey? : number | string | object, projection? : (e:T)=>void) : SELECT<T> & Promise<T>
	static from <T> (entity:T, primaryKey? : number | string | object, projection? : (e:T)=>void) : SELECT<T> & Promise<T>
}

export class INSERT<T> extends ConstructedQuery {
	static into  (entity : Definition | string, entries? : object | object[]) : INSERT<any>
	static into <T> (entity:Constructable<T>, data? : (e:T)=>void) : INSERT<T>
	static into <T> (entity:Constructable<T>, data? : object) : INSERT<T>
	static into <T> (entity:T, entries? : T | object) : INSERT<T>
	data (block : (e:T)=>void) : this
	entries (...entries : object[]) : this
	columns (...col: string[]) : this
	values (... val: any[]) : this
	rows (... row: any[]) : this
	INSERT : CQN.INSERT
}

export class DELETE<T> extends ConstructedQuery {
	static from (entity : Definition | string) : DELETE<any>
	DELETE : CQN.DELETE
	where (predicate:object) : this
	where (...expr : any[]) : this
}

export class UPDATE<T> extends ConstructedQuery {
	UPDATE : CQN.UPDATE
	constructor(entity:Constructable<T>, data? : (e:T)=>void)
	with (block: (e:T)=>void) : this
	set (block: (e:T)=>void) : this
	set (data:object) : this
	with (data:object) : this
	where (predicate:object) : this
	where (...expr : any[]) : this
}

export class CREATE extends ConstructedQuery {
	static entity (entity : Definition | string) : CREATE
	CREATE : CQN.CREATE
	then() : any
}

export class DROP extends ConstructedQuery {
	static entity (entity : Definition | string) : DROP
	DROP : CQN.DROP
}
