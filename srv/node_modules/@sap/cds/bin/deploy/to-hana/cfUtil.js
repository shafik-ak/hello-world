
const runCommand = require('./runCommand');
const { nullLogger } = require('./logger');

const POLL_TIMEOUT = 180 * 1000; //ms
const POLL_RETRY_TIMEOUT = 1000; //ms, since polling takes 1-2sec, repoll almost immediately

class CfUtil {

    /**
     *
     * @param {*} serviceName
     * * @param {*} servicePlan
     * @param {*} logger
     * @returns true if service is available at marketplace
     */
    static async hasMarketplaceService(serviceName, servicePlan, logger) {
        try {
            const marketplaceCmd = await runCommand('cf', ['marketplace', '-s', serviceName], logger);
            return marketplaceCmd.code === 0 && marketplaceCmd.stdout.indexOf(servicePlan) >= 0
        } catch (err) {
            throw this._getError(err);
        }
    }

    /**
     *
     * @param {*} serviceName
     * @param {*} logger
     * @returns service, or undefined
     */
    static async getService(serviceName, logger) {
        try {
            const serviceCmd = await runCommand('cf', ['service', serviceName], logger);

            let serviceInfo;
            if (serviceCmd.code === 0) {
                serviceInfo = {
                    name: serviceName,
                    status: /^\s*status\s*:\s*(.*)$/mi.exec(serviceCmd.stdout)[1],
                    service: /^\s*service\s*:\s*(.*)$/mi.exec(serviceCmd.stdout)[1]
                }
            }

            return serviceInfo;
        } catch (err) {
            throw this._getError(err);
        }
    }

    static async _pollService(serviceName, resolve, reject, startTime, logger = nullLogger) {
        if (Date.now() - startTime >= POLL_TIMEOUT) {
            logger.log();
            return reject(new Error(`[cds.deploy] - Aborting service creation after ${POLL_TIMEOUT/1000}sec.`));
        }

        const serviceCmd = await runCommand('cf', ['service', serviceName]);
        if (serviceCmd.code !== 0) {
            return reject(new Error(`[cds.deploy] - Getting service info failed with code ${serviceCmd.code}.`));
        }

        if (serviceCmd.stdout.includes('succeeded')) {
            logger.log();
            logger.log(serviceCmd.stdout);

            return resolve();
        }

        if (serviceCmd.stdout.includes('failed')) {
            logger.log();
            logger.log(serviceCmd.stdout);

            return reject(new Error(`[cds.deploy] - Service creation failed.`));
        }

        setTimeout(() => {
            logger.write('.');
            CfUtil._pollService(serviceName, resolve, reject, startTime, logger);
        }, POLL_RETRY_TIMEOUT);

        return null; // for sonar
    }

    /**
     * Triggers service creation and resolves once service is created or rejects in case of errors
     *
     * @param {*} service
     * @param {*} plan
     * @param {*} serviceName
     * @param {*} options
     * @param {*} logger
     */
    static async createService(service, plan, serviceName, options, logger) {
        // cf create-service SERVICE PLAN SERVICE_INSTANCE
        // FIXME: eslint sagt hierzu:   94:28  error  Promise executor functions should not be async  no-async-promise-executor
        // --> berechtigt: eine async funktion liefert als antwort eine Promise, die in eine Promise zu verpacken ist speziell
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                const cfArgs = ['create-service', service, plan, serviceName];
                if (options) {
                    cfArgs.push('-c');
                    cfArgs.push(JSON.stringify(options));
                }
                const createServiceCmd = await runCommand('cf', cfArgs, logger);
                if (createServiceCmd) {
                    if (createServiceCmd.code !== 0) {
                        return reject(new Error('[cds.deploy] - Create request failed'));
                    }

                    if (createServiceCmd.stdout.includes('already exists')) {
                        return resolve();
                    }
                }

                return CfUtil._pollService(serviceName, resolve, reject, Date.now(), logger);
            } catch (err) {
                reject(this._getError(err));
            }
        });
    }

    /**
     * Returns the serice key
     *
     * @param {*} serviceInstance
     * @param {*} serviceKeyName
     * @param {*} logger
     * @returns service key
     */
    static async getServiceKey(serviceInstance, serviceKeyName, logger) {
        try {
            const createServiceKeyCmd = await runCommand('cf', ['create-service-key', serviceInstance, serviceKeyName, '-c', `{"permissions":"development"}`], logger);
            if (createServiceKeyCmd.code === 0) {
                const getServiceKeyCmd = await runCommand('cf', ['service-key', serviceInstance, serviceKeyName], nullLogger);

                const keyJsonStr = getServiceKeyCmd.stdout.match(/\{([\s\S]*)\}/);
                return JSON.parse(keyJsonStr[0]);
            }

            return null;
        } catch (err) {
            throw this._getError(err);
        }
    }

    static _getError(err) {
        if (err.code === 'ENOENT') {
            return new Error(`Command 'cf' not found. Make sure you have the Cloud Foundry command line tool installed.`);
        } else {
            return err;
        }
    }
}

module.exports = CfUtil;

/* eslint no-console: off */