'use strict';

// Main entry for the CDS semantic checks

const baseModel = require('../base/model');
const alerts = require('../base/alerts');
const checkAnnotationAssignments = require('./checkAnnotationAssignments');
const getFunctionAndActionChecks = require('./checkFunctionsActions');
const keywords = require('../base/keywords');
const { checkNotEmptyOrOnlyVirtualElems, checkNoUnmanagedAssocsInGroupByOrderBy } = require('./checkArtifacts');
const { checkPrimaryKeyTypeCompatibility, checkVirtualElement, checkManagedAssoc, checkCardinality, checkLocalizedElement } = require('./checkElements');
const { checkExpression } = require('./checkExpressions');
const { foreachPath } = require('../model/modelUtils');

// Note: For the organization of these checks, we distinguish the following terms:
// - a 'construct' is something that has a 'kind' (so this is the the most general term)
// - an 'artifact' is a construct that lives in 'model.definitions' (e.g. an entity or an unbound function)
// - a 'member' is a construct that lives in an artifact, possibly nested (e.g. an element, function or parameter)
// - a 'container' is an artifact that can contain other artifacts (e.g. a context or service)

// Generally, the main 'semanticCheck' function ensures that for each construct, the appropriate
// check functions are called according to 'kind', from generic to specific.
// For example, an entity is an artifact, which is a construct, so the following
// function would be called:
// - checkGenericConstruct(art)
// - checkGenericArtifact(art)
// - checkEntity(art)
// To keep things simple, the actual check functions are intended to be leafs in this call hierarchy,
// so please do not call specific check functions from generic ones, and do not iterate members within
// artifact check functions (or artifacts within containers) just in order to call sub-checks. It is
// of course OK to iterate content if that is part of the actual check itself.

// Perform semantic check on all artifacts within (augmented) model. Report errors to model.messages.
function semanticCheck(model) {
  const { error, info, signal } = alerts(model);
  const { checkActionOrFunction, checkActionOrFunctionParameter} = getFunctionAndActionChecks(model);

  let currentService = undefined;

  // Iterate the model and call generic/specific checkers on each construct
  // (please do not put any actual checks here)
  baseModel.forEachDefinition(model, artifact => {
    checkGenericConstruct(artifact);
    checkGenericArtifact(artifact);
    if (artifact.kind == 'context' || artifact.kind == 'service' || artifact.kind == 'namespace' || artifact.kind == 'accesspolicy') {
      checkGenericContainer(artifact);
    }

    if (artifact.kind === 'context' || artifact.kind === 'service')
      currentService = artifact.name.absolute;

    callKindSpecificCheck(artifact, currentService);
    baseModel.forEachMemberRecursively(artifact, member => {
      checkGenericConstruct(member);
      checkGenericMember(member);
      callKindSpecificCheck(member, currentService);
    }); 
  });

  // Call the appropriate kind-specific check function for 'construct'
  function callKindSpecificCheck(construct, serviceName) {
    // For each kind, there must be a check function (so that we don't forget one)
    const checkFunctions = {
      context: nothingToCheckYet,
      service: nothingToCheckYet,
      namespace: nothingToCheckYet,
      accesspolicy: nothingToCheckYet,
      entity: checkEntity,
      annotation: nothingToCheckYet,
      type: checkType,
      element: checkElement,
      param: checkParam,
      enum: nothingToCheckYet,
      const: nothingToCheckYet,
      key: nothingToCheckYet,
      function: checkActionFunction,
      action: checkActionFunction,
      query: nothingToCheckYet,
      view: checkView,
      role: nothingToCheckYet,
      aspect: nothingToCheckYet,
      event: nothingToCheckYet,
      package: nothingToCheckYet,
    }
    let func = checkFunctions[construct.kind];
    if (!func) {
      throw Error('No check function defined for kind ' + construct.kind);
    }
    func(construct, serviceName);
  }

  // ----------------------------------------------------------------------------------
  // Generic check functions. Please put only common checks here and do not iterate
  // or dispatch further (should be done above in semanticCheck)

  // Called for every 'construct', i.e for artifacts and members alike
  function checkGenericConstruct(construct) {
    if (construct.name.id && construct.name.id.indexOf('.') != -1) {
      signal(error`The character '.' is not allowed in an identifier: "${construct.name.id}"`, construct.name.location);
    }
    if (construct.name.id && keywords.cdl.includes(construct.name.id.toUpperCase())) {
      signal(info`Using reserved keyword "${construct.name.id}" as identifier is not recommended`, construct.name.location);
    }
    checkAnnotationAssignments(construct, model);
  }

  // Called for each main artifact (no need to iterate its members)
  function checkGenericArtifact(art) {
    // user defined objects must not live in namespace cds,
    //   exception: they can live in cds.foundation
    // Only an INFO during compile time, 
    // reclassified to errors in the backends
    checkNotEmptyOrOnlyVirtualElems(art, model);
  }

  // Called for each member (no need to iterate sub-members)
  // eslint-disable-next-line no-unused-vars
  function checkGenericMember(member) {
    // No checks yet
  }

  // Called for each container (no need to iterate contained artifacts)
  function checkGenericContainer(container) {
    if (container.kind === 'namespace' && container.name.absolute === 'localized') {
      baseModel.forEachGeneric(container, "artifacts", checkLocalizedObjects);
    }

    function checkLocalizedObjects(artifact) {
      if (artifact.kind === "namespace") {
        baseModel.forEachGeneric(artifact, "artifacts", checkLocalizedObjects);
      } else if (!artifact.query) {
        signal(error`The namespace "localized" is reserved for localization views`, artifact.name.location);
      }
    }
  }

  // ----------------------------------------------------------------------------------
  // Specific check functions, normally one per kind (exceptions are OK where kinds are
  // too similar)

  function checkEntity(entity) {
    if (source(entity)) { // projection
      checkProjection(entity, model);
    }
  }

  function isAbstractEntity(entity) {
    return entity && entity.abstract && entity.abstract.val===true;
  }

  function checkProjection(entity) {
    // TODO: check too simple (just one source), as most of those in this file
    let sourceEntity = source(entity)._artifact;
    if(sourceEntity && isAbstractEntity(sourceEntity)) {
      signal(error`Projection ${entity.name.absolute} on abstract entity ${sourceEntity.name.absolute}`, source(entity).location);
    }
  }

  function checkView(view) {
    // TODO: check too simple (just one source), as most of those in this file
    if (source(view)) {
      let sourceEntity = source(view)._artifact;
      if(sourceEntity && isAbstractEntity(sourceEntity)) {
        signal(error`View ${view.name.absolute} on abstract entity ${sourceEntity.name.absolute}`, source(view).location);
      }
    }
    checkNoUnmanagedAssocsInGroupByOrderBy(view, model);
    // Check expressions in the various places where they may occur
    for (let query of view.$queries || []) {
      if (query.from) {
        checkExpressionsInPaths(query.from);
      }
      if (query.where) {
        checkExpression(query.where, model);
        checkExpressionsInPaths(query.where);
      }
      if (query.groupBy) {
        for (let groupByEntry of query.groupBy) {
          checkExpression(groupByEntry, model);
          checkExpressionsInPaths(groupByEntry);
        }
      }
      if (query.having) {
        checkExpression(query.having, model);
        checkExpressionsInPaths(query.having);
      }
      if (query.orderBy) {
        for (let orderByEntry of query.orderBy) {
          checkExpression(orderByEntry.value, model);
          checkExpressionsInPaths(orderByEntry.value);
        }
      }
      if (query.elements) {
        for (let elemName in query.elements) {
          checkExpressionsInPaths(query.elements[elemName].value);
        }
      }
    }
  }

  // Traverses 'node' recursively and applies 'checkExpression' to all expressions
  // found within paths (e.g. filters, parameters, ...)
  function checkExpressionsInPaths(node) {
    foreachPath(node, path => {
      for (let pathStep of path) {
        if (pathStep.where) {
          checkExpression(pathStep.where, model);
        }
        // FIXME: I can't actually think of a way to make this check fail, because
        // params are limited to actual values and params
        if (pathStep.namedArgs) {
          checkExpression(pathStep.namedArgs, model);
        }
      }
    });
  }

  function checkType(type) {
    checkManagedAssoc(type, model);
  }

  function checkElement(elem) {
    checkPrimaryKeyTypeCompatibility(elem, model);
    checkVirtualElement(elem, model);
    checkManagedAssoc(elem, model);
    checkCardinality(elem, model);
    if (elem.onCond && !elem.onCond.$inferred) {
      checkExpression(elem.onCond, model);
    }
    if (elem.value) {
      checkExpression(elem.value, model);
    }
    checkLocalizedElement(elem, model);
  }

  // Actions and functions are almost identical, so we use only one check function
  function checkActionFunction(act, serviceName) {
    checkActionOrFunction(act, serviceName);
  }

  function checkParam(param, serviceName) {
    if (param._parent && (param._parent.kind == 'action' || param._parent.kind == 'function')) {
      checkActionOrFunctionParameter(param, serviceName);
    }
  }

  // Dummy for things that we don't check yet
  function nothingToCheckYet() {
    // Intentionally empty
  }
}

// TODO: checks on one "source" are incomplete!
function source( view ) {
  let from = view.query && view.query.from;
  return from && from.length === 1 && from[0] && from[0].path && from[0];
}

module.exports = semanticCheck;
