const edmxDict = require('./Dictionary.json');
const { CompileMessage } = require('../../base/messages');

function validateTerm(term, target, location, messages) {
  if (!edmxDict.terms[term])
    messages.push(new CompileMessage(location, `Error in annotation translation: unknown term: ${term}, target: ${target}`));
}

function validateType(obj, env) {
  let expectedType = env.expectedType || edmxDict.terms[env.term] && edmxDict.terms[env.term].Type;
  if (!expectedType)
    return;
  // handle the case when a colletion is empty -> result in empty array
  if (obj._name === 'Collection' && obj._selfClosing)
    return;
  env.expectedType = expectedType;
  if (expectedType.startsWith('Edm.'))
    validateBuiltin(obj, env);
  else if (expectedType.startsWith('Collection('))
    validateCollection(obj, env);
  else
    // if it is not builtin or collectection => it is a complex type
    validateComplexType(obj, env);
}

function validateBuiltin(obj, env) {
  switch (env.expectedType) {
    case 'Edm.Boolean':
      checkIfProp('Bool');
      break;
    case 'Edm.String':
      checkIfProp('String');
      break;
    case 'Edm.Byte':
    case 'Edm.Int32':
    case 'Edm.Int64':
      checkIfProp('Int');
      break;
    case 'Edm.Double':
      checkIfProp('Float');
      break;
    case 'Edm.Decimal':
      checkIfProp('Decimal');
      break;
    case 'Edm.PropertyPath':
      checkIfProp('PropertyPath');
      break;
    case 'Edm.NavigationPropertyPath':
      checkIfProp('NavigationPropertyPath');
      break;
    case 'Edm.AnnotationPath':
      checkIfProp('AnnotationPath');
      break;
    case 'Edm.PrimitiveType':
  }

  function checkIfProp(prop) {
    if (obj._attributes) {
      if (!obj._attributes[prop] && !obj._attributes.Path)
        env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: expected: ${env.expectedType}, target: ${env.target}, annotation: ${env.term}`, 'Warning'));
    } else {
      if (!obj[prop])
        env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: ${env.expectedType}, target: ${env.target}, annotation: ${env.term}`, 'Warning'));
    }
  }
}

function validateCollection(obj, env) {
  if (!obj.Collection)
    env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: expected: ${env.expectedType}, but 'Collection' was not found, target: ${env.target}, annotation: ${env.term}`, 'Warning'));
  else {
    env.expectedType = env.expectedType.slice(11, -1);
    obj.Collection.forEach(elem => {
      validateType(elem, env);
    });
  }
}

function validateComplexType(obj, env) {
  if (obj.Record) {

    for (let record of obj.Record) {
      // 1. check the 'type' attribute
      let definedType = edmxDict.types[record._attributes.Type];// of what type the record is defined
      let baseTypeName = record._attributes.Type;
      while (definedType && definedType.BaseType) {
        baseTypeName = definedType.BaseType;
        definedType = edmxDict.types[definedType.BaseType];
      }
      // this conparison is used as baseTypeName can be the expectedType, but with a suffix 'Abstract', e.g. baseTypeName can be 'UI.DataFieldAbstract' and the expectedType to be 'UI.DataField'
      if (!baseTypeName.includes(env.expectedType)) {
        env.messages.push(new CompileMessage(record._location, `Unexpected kind in annotation translation: found type: ${record._attributes.Type}, but expected: ${env.expectedType}, target: ${env.target}`, 'Warning'));
        return;
      }

      if (record.PropertyValue || record.Annotation) {
        if (record.PropertyValue) {
          let definedProperties = record.PropertyValue;
          let expectedProperties = edmxDict.types[record._attributes.Type].Properties;
          for (let prop of definedProperties) {
            // 2. Check if all a property is existing in the Dictionary.json
            if (prop._attributes && !expectedProperties[prop._attributes.Property])
              env.messages.push(new CompileMessage(prop._location, `Unexpected kind in annotation translation: not existing property: ${prop._attributes.Property} of type ${env.expectedType}, target: ${env.target}`, 'Warning'));
            else
              // 3. check the type of the property
              validateType(prop, Object.assign({}, env, { expectedType: expectedProperties[prop._attributes.Property] }));
          }
        }

        if (record.Annotation) {
          for (let anno of record.Annotation) {
            validateTerm(anno._attributes.Term, env.target, anno._location, env.messages);
            validateType(anno, Object.assign({}, env, { term: anno._attributes.Term, expectedType: undefined }));
          }
        }
      } else
        env.messages.push(new CompileMessage(record._location, `Unexpected kind in annotation translation: empty record of type ${env.expectedType}, target: ${env.target}`, 'Warning'));
    }

  }

  if (edmxDict.types[env.expectedType] && edmxDict.types[env.expectedType].$kind === 'EnumType') {
    validateEnum(obj, env);
  } else if (obj._attributes && obj._attributes.EnumMember) // when enum is declared, but the type is not an enum
    env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: the type ${env.expectedType} is not an enum type, target: ${env.target}`, 'Warning'));
}

function validateEnum(obj, env) {
  if (obj._attributes && obj._attributes.EnumMember) {
    // the value contains whitespaces => array
    if (/\s/.test(obj._attributes.EnumMember)) {
      // TODO: uglyyy, rewrite it
      let enumSymbols = obj._attributes.EnumMember.split(' ');
      enumSymbols.forEach(s => validateEnum({ _attributes: { EnumMember: s }, _location: obj._location }, env));
    }
    let enumSymbol = obj._attributes.EnumMember.split('/').pop();
    if (!edmxDict.types[env.expectedType].Members.includes(enumSymbol))
      env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: unexisting value ${enumSymbol} in enum type ${env.expectedType}, target: ${env.target}`, 'Warning'));
  }
  if (obj._attributes && !obj._attributes.EnumMember && !obj._attributes.Path)
    env.messages.push(new CompileMessage(obj._location, `Unexpected kind in annotation translation: enum value expected for enum type ${env.expectedType}, target: ${env.target}`, 'Warning'));
}

module.exports = {
  validateTerm,
  validateType,
};