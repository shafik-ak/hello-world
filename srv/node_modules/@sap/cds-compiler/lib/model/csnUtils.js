'use strict'

const { setProp } = require('../base/model');
const csnRefs = require('../model/csnRefs');

// Low-level utility functions to work with compact CSN.

/**
 * Get utility functions for a given CSN.
 * @param model - (compact) CSN model
 */
function getUtils(model) {
  const { artifactRef, inspectRef } = csnRefs(model);

  return {
    getCsnDef,
    isStructured,
    getFinalType,
    getFinalTypeDef,
    isBuiltinType,
    isManagedAssociationElement,
    isAssocOrComposition,
    isAssociation,
    isComposition,
    getArtifactDatabaseNameOf,
    getNamespaceOfArtifact,
    addStringAnnotationTo,
    getServiceName,
    hasBoolAnnotation,
    cloneWithTransformations,
    getFinalBaseType,
    inspectRef
  };

  /**
   * Create an object to track visited objects identified
   * by a unique sring.
   * @param id - initial entry (optional)
   */
  function createVisited(id) {
    let visited = {};
    check(id);
    return { check };

    /**
     * Check if an identififer has already been visited and
     * add it to the list of visited identifiers.
     * @param id - unique identifier
     */
    function check(id) {
      if (!id) return;
      if (visited[id]) {
        throw new Error('Circular dependency');
      }
      visited[id] = true;
    }
  }

  /**
   * Get the CSN definition for an artifact name.
   * @param defName - absolute name of the artifact
   */
  function getCsnDef(defName) {
    if (model.definitions[defName])
      return model.definitions[defName]
    else
      throw new Error(`Nonexistent definition in the model: '${defName}'`);
  }

  /**
   * Returns if an artifact is a structured type
   * or a typedef of a structured type.
   * @param obj - artifact
   */
  function isStructured(obj) {
    return obj.elements ||
      (obj.type && ((getFinalTypeDef(obj.type).elements) || (obj.type.ref && getFinalBaseType(obj.type).elements)));
  }

  /**
   * Resolves typedefs to its final typedef which is returned.
   * If the artifact for typename isn't a typedef, the name itself is returned.
   * @param typeName - absolute name
   */
  function getFinalTypeDef(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    if (!type) {
      return typeName;
    }
    for (let nextType = type; nextType;) {
      type = nextType;
      visited.check(type.type);
      nextType = model.definitions[nextType.type];
    }
    return type;
  }

  /**
   * Resolves typedefs to its final type (name) which is returned.
   * @param typeName - absolute name
   */
  function getFinalType(typeName) {
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type && type.type) {
      typeName = type.type;
      visited.check(typeName);
      type = model.definitions[typeName];
    }
    return typeName;
  }

  // Tell if a type is (directly) a builtin type
  // Note that in CSN builtins are not in the definition of the model, so we can only check against their absolute names.
  // Builtin types are "cds.<something>", i.e. they are directly in 'cds', but not for example
  // in 'cds.foundation'. Also note, that a type might be a ref object, that refers to something else,
  // so if you consider type chains don't forget first to resolve to the final type before
  function isBuiltinType(type) {
    return typeof(type) === 'string' && type.startsWith('cds.') && type.indexOf('.') === type.lastIndexOf('.')
  }

  // Return true if 'node' is a managed association element
  // TODO: what about elements having a type, which (finally) is an assoc?
  function isManagedAssociationElement(node) {
    return node.target != undefined && node.on == undefined;
  }

  /**
   * Returns if a type is an association or a composition or a typedef
   * to any of them.
   * @param typeName - absolute type name
   */
  function isAssocOrComposition(typeName) {
    if (typeName === 'cds.Association' || typeName === 'cds.Composition')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association' || type.type === 'cds.Composition')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Returns if a type is an association or a typedef to it.
   * @param typeName - absolute type name
   */
  function isAssociation(typeName) {
    if (typeName === 'cds.Association')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Association')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  /**
   * Returns if a type is an composition or a typedef to it.
   * @param typeName - absolute type name
   */
  function isComposition(typeName) {
    if (typeName === 'cds.Composition')
      return true;
    let visited = createVisited(typeName);
    let type = model.definitions[typeName];
    while (type) {
      if (type.type === 'cds.Composition')
        return true;
      visited.check(type.type);
      type = model.definitions[type.type];
    }
    return false;
  }

  // Return the resulting database name for (absolute) 'artifactName', depending on the current naming
  // convention.
  // - For the 'hdbcds' naming convention, this means converting '.' to '::' on
  //   the border between namespace and top-level artifact.
  // - For the 'plain' naming convention, it means converting all '.' to '_' and uppercasing.
  // - For the 'quoted' naming convention, this is just 'artifactName'.
  // No other naming conventions are accepted
  function getArtifactDatabaseNameOf(artifactName, namingConvention, namespace = undefined) {
    if (namingConvention == 'hdbcds') {
      if (namespace) {
        return `${namespace}::${artifactName.substring(namespace.length + 1)}`;
      }
      return artifactName;
    }
    else if (namingConvention == 'plain') {
      return artifactName.replace(/\./g, '_').toUpperCase();
    }
    else if (namingConvention == 'quoted') {
      return artifactName;
    }
    else {
      throw new Error('Unknown naming convention: ' + namingConvention);
    }
  }

  /**
   * Return the namespace part of the artifact name.
   * @param name - absolute name of artifact
   */
  function getNamespaceOfArtifact(name) {
    let lastDotIdx = name.lastIndexOf('.');
    while (model.definitions[name]) {
      if (model.definitions[name].kind === 'namespace')
        return name;
      lastDotIdx = name.lastIndexOf('.');
      if (lastDotIdx === -1) return undefined;
      name = name.substring(0, lastDotIdx);
    }
    return name;
  }
  /**
   * Add an annotation with absolute name 'absoluteName' (including '@') and string value 'theValue' to 'node'
   * 
   * @param {any} absoluteName Name of the annotation, including '@'
   * @param {any} theValue string value of the annotation
   * @param {any} node Node to add the annotation to
   */
  function addStringAnnotationTo(absoluteName, theValue, node) {
    // Sanity check
    if (!absoluteName.startsWith('@')) {
      throw Error('Annotation name should start with "@": ' + absoluteName);
    }
     // Assemble the annotation
    node[absoluteName] = theValue;
  }

  /**
   * Return the name of the service in which the artifact is contained.
   * Returns null if the artifact doesn't live in a service.
   * @param artifactName - absolute name of artifact
   */
  function getServiceName(artifactName) {
    for(;;) {
      let idx = artifactName.lastIndexOf('.');
      if (idx == -1) return null;
      artifactName = artifactName.substring(0, idx);
      let artifact = model.definitions[artifactName];
      if (artifact && artifact.kind === 'service') {
        return artifactName;
      }
    }
  }

  /**
   * Clone 'node', transforming nodes therein recursively. Object 'transformers' is expected
   * to contain a mapping of property 'key' names to transformer functions. The node's properties
   * are walked recursively, calling each transformer function on its corresponding property
   * 'key' of 'node', replacing 'value' in 'resultNode' with the function's return value
   * (returning 'undefined' will delete the property).
   * If no transformation function is found for 'key', the first letter of 'key' is tried
   * instead (this seems to be intended for handling annotations that start with '@' ?)
   * 
   * Regardless of their names, transformers are never applied to dictionary elements.
   * 
   * The transformer functions are called with the following signature:
   * transformer(value, node, resultNode, key)
   * 
   * @param {any} node Node to transform
   * @param {any} transformers Object defining transformer functions
   * @returns 
   */
  function cloneWithTransformations(node, transformers) {

    return transformNode(node);

  // This general transformation function will be applied to each node recursively
    function transformNode(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
      if (node == null || typeof node !== 'object') {
        return node
      }
    // Simply return if node is to be ignored
      if (node == undefined || node._ignore)
        return undefined;
    // Transform arrays element-wise
      if (node instanceof Array) {
        return node.map(transformNode);
      }
    // Things not having 'proto' are dictionaries
      let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
      let resultNode = Object.create(proto);
      for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
        let transformer = (proto == undefined) ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
        let resultValue = (transformer || transformNode)(node[key], node, resultNode, key);
        if (resultValue !== undefined) {
          resultNode[key] = resultValue;
        }
      }
      return resultNode;
    }
  }
  
  // Resolve to the final type of a type, that means follow type chains, references to other types or
  // elements a.s.o
  // Works for all kinds of types, strings as well as type objects. Strings need to be absolute type names.
  // Returns the final type as string (if it has a name, which is not always the case, think of embedded structures),
  // else the type object itself is returned. If a type is structured, you can navigate into it by providing a path,
  // e.g. given the following model
  //     type bar: S.foo;
  //     type s1 {
  //       s: s2;
  //     };
  //     type s2 {
  //       u: type of S.e:t;
  //     }
  //     service S {
  //       type foo: type of S.e:i.j1;
  //       entity e {
  //         key i: { j1: Integer };
  //         t: bar;
  //         v: s1;
  //         x: blutz.s.u;
  //       };
  //       type blutz: S.e.v;
  //       view V as select from e {
  //         1+1 as i: bar,
  //       };
  //       type tt: type of V:i;
  //    }
  // the following calls will all return 'cds.Integer'
  //     getFinalBaseType('S.tt')
  //     getFinalBaseType('S.e',['i','j1'])
  //     getFinalBaseType('S.e',['t'])
  //     getFinalBaseType('S.e',['x'])
  //     getFinalBaseType('S.blutz',['s', 'u'])
  // Types are always resolved as far as possible. A type name which has no further definition is simply returned.
  // Composed types (structures, entities, vies, ...) are returned as type objects, if not drilled down into
  // the elements. Path steps that have no corresponding element lead to 'undefined'. Refs to something that has
  // no type (e.g. expr in a view without explicit type) returns 'null'
  function getFinalBaseType(type, path = [], cycleCheck = undefined) {
    if (!type)
      return type;
    if (typeof(type) === 'string') {
      if (type.startsWith('cds.') && type.indexOf('.') === type.lastIndexOf('.')) // built-in type
        return type;
      if (cycleCheck) {
        let visited = path.length? type + ':' + path.join('.') : type;
        if (cycleCheck[visited])
          throw new Error('Circular type chain on type ' + type);
        else
          cycleCheck[visited] = true;
      }
      else {
        cycleCheck = Object.create(null);
      }
      let definedType = model.definitions[type];
      if (definedType && definedType.type)
        return getFinalBaseType(definedType.type, path, cycleCheck);
      else
        return getFinalBaseType(definedType, path, cycleCheck);
    }
    else if (typeof(type) === 'object') {
      if (type.ref) {
        // assert type.ref instanceof Array && type.ref.length >= 1
        const ref = artifactRef(type);
        return getFinalBaseType(ref, path, cycleCheck);
      }
      else if (type.elements) {
        if (path.length) {
          let [e, ...p] = path;
          return getFinalBaseType(type.elements[e], p, cycleCheck);
        }
      }
      else if (type.type)
        return (getFinalBaseType(type.type, path, cycleCheck));
      else if (type.items)
        return getFinalBaseType(type.items, path, cycleCheck);
      else
        // TODO: this happens if we don't have a type, e.g. an expression in a select list
        // in a view without explicit type. Instead of returning null we might want to return
        // the object instead?
        return null;
    }
    return type;
  }
}


function cloneCsn(csn){
  const clonedCsn = clone(csn);
  if(csn.messages){
    setProp(clonedCsn, 'messages', csn.messages);
  }

  return clonedCsn;

  // This general transformation function will be applied to each node recursively
  function clone(node) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
    if (node == null || typeof node !== 'object') {
      return node
    }
    // Transform arrays element-wise
    if (node instanceof Array) {
      return node.map(clone);
    }
    // Things not having 'proto' are dictionaries
    let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
    let resultNode = Object.create(proto);
    for (let key of Object.keys(node)) {
      // Clone each property
      let resultValue = clone(node[key], node, resultNode, key);
      if (resultValue !== undefined) {
        resultNode[key] = resultValue;
      }
    }
    if(node.$location){
      setProp(resultNode, "$location", node.$location);
    }
    if(node.elements && !resultNode.elements){
      setProp(resultNode, 'elements', node.elements);
    }
    if (node.technicalConfig && !resultNode.technicalConfig)
      setProp(resultNode, 'technicalConfig', node.technicalConfig);

    if(node.$env && !resultNode.$env){
      setProp(resultNode, '$env', node.$env);
    }
    
    return resultNode;
  }
}

// Apply function `callback` to all artifacts in dictionary
// `model.definitions`.  See function `forEachGeneric` for details.
// callback will be called with artifact, artifact name, csn-path to artifact
function forEachDefinition( csn, callback ) {
  forEachGeneric( csn, 'definitions', callback );
}

// Apply function `callback` to all members of object `obj` (main artifact or
// parent member).  Members are considered those in dictionaries `elements`,
// `enum`, `actions` and `params` of `obj`, `elements` and `enums` are also
// searched inside property `items` (array of).  See function `forEachGeneric`
// for details.
function forEachMember( construct, callback, path=[]) {
  let obj = construct.returns || construct; // why the extra `returns` for actions?
  const obj_path = Array.from(path); // Clone the path

  if(construct._ignore || obj._ignore){
    return;
  }

  if(construct.returns){
    obj_path.push("returns");
  }

  if(obj.items){
    obj_path.push("items");
  }

  obj = obj.items || obj;
  forEachGeneric( obj, 'elements', callback, obj_path );
  forEachGeneric( obj, 'payload', callback, obj_path );
  forEachGeneric( obj, 'enum', callback, obj_path );
  forEachGeneric( obj, 'foreignKeys', callback, obj_path );
  forEachGeneric( construct, 'actions', callback, path );
  forEachGeneric( construct, 'params', callback, path );
}

// Apply function `callback(member, memberName)` to each member in `construct`,
// recursively (i.e. also for sub-elements of elements).
function forEachMemberRecursively( construct, callback, path=[] ) {
  forEachMember( construct, ( member, memberName, prop, subpath ) => {
    callback( member, memberName, prop, subpath );
    // Descend into nested members, too
    forEachMemberRecursively( member, callback, subpath);
  }, path);
}

// Apply function `callback` to all objects in dictionary `dict`, including all
// duplicates (found under the same name).  Function `callback` is called with
// the following arguments: the object, the name, and -if it is a duplicate-
// the array index and the array containing all duplicates.
function forEachGeneric( obj, prop, callback, path = []) {
  let dict = obj[prop];
  for (let name in dict) {
    let dictObj = dict[name];
    if (dictObj instanceof Array) // redefinitions - not in CSN!
      dictObj.forEach( (o) => callback( o, name, prop, path.concat([prop, name])) )
    else
      callback( dictObj, name, prop, path.concat([prop, name]) );
  }
}

// For each property named 'ref' in 'node' (recursively), call callback(ref, node, path)
function forEachRef(node, callback, path = []) {
  if (node == null || typeof node !== 'object') {
    // Primitive node
    return;
  }

  if(node._ignore){
    return; 
  }
  
  if(Array.isArray(node)){
    for (let i = 0; i < node.length; i++) {
      // Descend recursively
      forEachRef(node[i], callback, path.concat([i]));
    }
  } else {
    for (let name in node) {
      // If ref found within a non-dictionary, call callback
      if (name === 'ref' && Object.getPrototypeOf(node)) {
        callback(node.ref, node, path);
      }
      // Descend recursively
      forEachRef(node[name], callback, path.concat([name]));
    }
  }
}

// Like Object.assign() but copies also non enumerable properties
function assignAll(target, ...sources) {
  sources.forEach(source => {
    let descriptors = Object.getOwnPropertyNames(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});
    // by default, Object.assign copies enumerable Symbols too
    Object.getOwnPropertySymbols(source).forEach(sym => {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

function forAllQueries(query, callback, path = []){
  return traverseQuery(query, callback, path);
  function traverseQuery( q, cb, p ) {
    if (q.SELECT) {
      p.push('SELECT');
      cb( q, p);
      q = q.SELECT;
      traverseFrom( q.from, cb, p.concat(['from']) );
    }
    else if (q.SET) {
      p.push('SET');
      cb( q, p);
      q = q.SET;
    }
    for (const prop of ['args', 'xpr', 'columns', 'where', 'having']) {
      // all properties which could have sub queries (directly or indirectly)
      const expr = q[prop];
      if (expr && typeof expr === 'object') {
        if(Array.isArray(expr)){
          for(let i = 0; i < expr.length; i++){
            traverseQuery(expr[i], cb, p.concat([prop, i]));
          }
        } else {
          for(const argName of Object.keys( expr )){
            traverseQuery(expr[argName], cb, p.concat([prop, argName]))
          }
        }
      }
    }
  }
  
  function traverseFrom( from, callback, path = [] ) {
    if (from.ref) // ignore
      return;
    else if (from.args){ // join
      for(let i = 0; i < from.args.length; i++){
        traverseFrom(from.args[i], callback, path.concat(['args', i]));
      }
    }           
    else
      traverseQuery( from, callback, path ); // sub query in FROM
  }
}

/**
 * Returns true if the element has a specific annotation set to the given value.
 * @param artifact - the artifact object
 * @param annotationName - the name of the annotation (including the @)
 * @param value - the value
 */
function hasBoolAnnotation(artifact, annotationName, value = true) {
  return artifact[annotationName] === value;
}


module.exports = {
  getUtils,
  cloneCsn,
  assignAll,
  forEachGeneric,
  forEachDefinition,
  forEachMember,
  forEachMemberRecursively,
  forEachRef,
  forAllQueries,
  hasBoolAnnotation
};
