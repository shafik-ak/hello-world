let W = require("../walker")

const MaxMsgLen = 160;
const DefaultStrictFuzzy=true;

const $extra="$extra";
const $class = "$class";
const $classes = "$classes";
const magicElements=["$location"]; // accepted on all levels

function reportError(ctx,path,node,msg) {
  let rpath=path.filter(X => !X.startsWith("{"))
  let message = "/"+rpath.join("/")+" "+msg;
  if(rpath.length>0) message+=" in "+JSON.stringify(node);
  if(message.length>MaxMsgLen) message=message.substr(0,MaxMsgLen)+"...";
  ctx.messages.push({path:rpath,message,error:true})
}

function reportInfo(ctx,path,node,msg) {
  let rpath=path.filter(X => !X.startsWith("{"))
  let message = "/"+rpath.join("/")+" "+msg;
  if(rpath.length>0) message+=" in "+JSON.stringify(node);
  if(message.length>MaxMsgLen) message=message.substr(0,MaxMsgLen)+"...";
  ctx.messages.push({path:rpath,message,info:true})
}

function getOpt(ctx,name,defaultValue) {
  let r = defaultValue;
  if(ctx.options && ctx.options[name]!==undefined)
    r = ctx.options[name];
  return r;
}

function hit(ctx,node,className,path,overwriteLastHit=undefined) {
  if(!isExtrable(node)) return;
  //if(className==="Dict") return;
  if(overwriteLastHit===undefined) {
    let strictFuzzy=getOpt(ctx,"strictFuzzy",DefaultStrictFuzzy);
    overwriteLastHit=strictFuzzy?false:true;
  }
  if(overwriteLastHit)
    Object.defineProperty(node,$class,{configurable:true,enumerable:false,value:className})
  if(node[$classes]===undefined)
    Object.defineProperty(node,$classes,{configurable:true,enumerable:false,value:[]})
  if(!node[$classes].includes(className))
    node[$classes].push(className)
}

function postProcess(csn,ctx,funcs,root) {
  let fctx = {messages:ctx.messages,fuzzy:true,options:ctx.options};

  let func = funcs[root];
  func(csn,fctx,[])

  W.walkWithPath(csn,(isNode,path,node) => {
    if(!isNode) return;
    if(!isExtrable(node)) {
      return;
    }
    if(node[$class]!==undefined) {
      let className = node[$class];
      let func = funcs[className];
      func(node,fctx,path)
      if(ctx.options && ctx.options.keepClasses) {
        if(Array.isArray(node))
          node.push({"$CLASS":className})
        else
          node["$CLASS"]=className;
      }
      if(!delete node[$class])
        throw Error("Deletion of $class failed:" + path.join("/"));
    }
    if(node[$classes]!==undefined) {
      if(ctx.options && ctx.options.keepClasses) {
        let classNames = node[$classes];
        if(Array.isArray(node))
          node.push({"$CLASSES":classNames})
        else
          node["$CLASSES"]=classNames;
      }
      if(!delete node[$classes])
        throw Error("Deletion of $classes failed:" + path.join("/"));
    }
  })

  // remove marked for deletion
  ctx.toRemove.forEach(P => {
    let node = csn;
    P.forEach((N,I) => {
      if(node===undefined) return;
      if(I===P.length-1) { // last node in path?
        delete node[N]; // delete the property
      } else {
        node = node[N];
      }
    })
  })
}

function checkTypeOf(ctx,path,node,F,rc) {
  if(!rc && F(node,{messages:[]},path)) {
    rc=true;
    F(node,ctx,path);
  }
  return rc;
}

function isExtrable(node) {
  if(typeof node !== "object") return false;
//  if(Array.isArray(node)) return false;
  if(node===null) return false;
  return true;
}

function fuzzy(ctx,path,node,props,className) {
  if(props.length===0) return;
  if(!isExtrable(node)) return;

  for(let element in node) {
    if(element.startsWith("@")) return;//annotations
    if(!props.includes(element)) {
      let epath = path.concat(element)
      if(element===$extra) continue;
      if(element===$class) continue;
      if(element===$classes) continue;
      if(!magicElements.includes(element)) {
        if(ctx.options && ctx.options.fuzzyCsnError)
          reportError(ctx,epath,node,"{"+className+"}: Unknown element '"+element+"'");
        else
          reportInfo(ctx,epath,node,"{"+className+"}: Unknown element '"+element+"'");
        if(!(ctx.options && ctx.options.skipFuzzyDelete)) {
          // prepare, copy and delete
          if(!Object.getOwnPropertyNames(node).includes($extra)) {
            Object.defineProperty(node,$extra,{configurable:true,enumerable:true,value:{}})
          }
          node[$extra][element]=node[element];
          delete node[element];
        }
      }
    }
  }
}

function rmv(ctx,p) {
  if(ctx && ctx.toRemove)
    ctx.toRemove.push(p.filter(X => X[0]!=='{'))
}

module.exports = {
  checkTypeOf,
  reportError,
  reportInfo,
  hit,
  postProcess,
  fuzzy,
  rmv
}
