/**
* Module for json parsing based on antlr4.
* It returns extended structure which contains the json data and corresponding locations.
* The locations have start and stop tokens, which have start and stop offsets.
* The offsets show the location of those tags in the originating json provided as string.
* In addition the getPathLocation is attached and has internal reference to the returned structure,
* which enables calling it with one argument: path to be resolved.
*
* The extended structure has nodes with:
*  - type: one of object, array, string, number, boolean
*  - start: is the location of the first token
*  - stop: is the location of the last token
*  - value: the value of the node
*
* Each location has start and stop offsets, also line and column,
* where the stop.column points to the end of the last token.
*
* The value node for the different types is as follows:
*  - primitive types: the value of the primitive type
*  - array: an array of extended structures (as described) of the originating array
*  - object: a map of the object's dictionary keys having extended structures (as described) of the the corresponding nodes
*
* The module provides functions as:
*  - parse: performs the actual parsing
*  - getPathLocation: returns the location of path, which is provided as array of names
*  - sliceXXX - returns substrings of the content for specified location
*/

var antlr4 = require('antlr4');
var Parser = require('../../gen/JSONParser.js').JSONParser;
var Lexer = require('../../gen/JSONLexer.js').JSONLexer;

const Messages = require("../../base/messages.js");

function parse( source, filename, attachMessages=true, defaultObject=true) {
  var lexer = new Lexer( new antlr4.InputStream(source) );

  var errorListener = new ErrorListener(filename);

  lexer.removeErrorListeners();
  lexer.addErrorListener( errorListener );

  var tokenStream = new antlr4.CommonTokenStream(lexer);
  var parser = new Parser( tokenStream );

  parser.removeErrorListeners();
  parser.addErrorListener( errorListener );

  var tree = parser.json();
  if(errorListener.messages.length>0) {
    let R = tree.ret;
    R.messages = errorListener.messages;
  }

  tree.ret.filename = filename;
  if(defaultObject)
    setDefaultRootLocation(tree.ret);//needed when the json is completely wrong
  tree.ret.getPathLocation = function (path) {
    return getPathLocation(tree.ret, path);
  }
  tree.ret.condense = function ( options = {attachLocations: true, attachMessages: true, defaultObject} ) {
    const condense = require('./condense.js');
    let R = condense(tree.ret, options);
    if(typeof R !== "object") { // NO OBJECT RETURNED -> invalid JSON - initialize anyway
      if(options.defaultObject)
        R={};
      else
        return undefined; // used in tests
    }
    if(options.attachLocations)
      attachHiddenProperty(R, "locations", tree.ret);
    if(options.attachMessages)
      R.messages = tree.ret.messages;
    return R;
  }
  if(attachMessages)
    tree.ret.messages = errorListener.messages;
  return tree.ret;
}

function setDefaultRootLocation(O) {
  O.start={line:1,column:1,offset:0,start:1,stop:1};
  O.stop={line:1,column:1,offset:0,start:1,stop:1};
}

function attachHiddenProperty(obj,name,value) {
  Object.defineProperty(obj, name, {
    enumerable: false,
    configurable: true,
    writable: false,
    value: value
  });
}

// throws if path not found
function getPathLocation(M, P) {
  let filename = M.filename; // make sure to get the file name before M is changed
  let R = M;
  P.forEach(E => {
    M = M.value[E];
    if(M) R=M;
  });
  if(!R) {
    throw Error("no location for "+P.join("/"));
  }
  return {filename,start:R.start,stop:R.stop};
}

function sliceFirst(content, location) {
  return content.slice(location.start.start, location.start.stop+1);
}
function sliceLast(content, location) {
  return content.slice(location.stop.start, location.stop.stop+1);
}

function slice(content, location) {
  return content.slice(location.start.start, location.stop.stop+1);
}

class InvalidJSON extends Error {
  constructor(msg, location, severity = 'Error') {
    super(msg);
    //TODO improve location
    this.location = location;
    this.severity = severity;
  }
  toString() {
    return Messages.messageString(this);
  }
}

class ErrorListener extends antlr4.error.ErrorListener {
  constructor(...args) {
    super(...args);
    this.filename = args[0];
    this.messages = [];
  }

  syntaxError(recognizer, offendingSymbol, line, column, msg) {
    var loc = offendingSymbol
      ?
        this.tokenLocation( offendingSymbol )
      :
        this.lexerLocation(recognizer, line, column);
    this.messages.push( new InvalidJSON( msg, loc ) );
  }

  lexerLocation(recognizer, line , column) {
    return {
      filename:this.filename,
      start: {
        line,
        column,
        offset:recognizer._tokenStartCharIndex
      },
      end: {
        line,
        column,
        offset:recognizer._tokenStartCharIndex+1
      }
    }
  }

  tokenLocation( token ) {
    return {
      filename: this.filename,
      start: { offset: token.start, line: token.line, column: token.column + 1},
      end: {
        offset: token.stop + 1,
        line: token.line,
        column: token.stop - token.start + token.column + 2
      }
    }
  }

}

module.exports = {
  parse,
  getPathLocation,
  sliceFirst,
  sliceLast,
  slice
}
