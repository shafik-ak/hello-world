/**
 * Walker module provides non-recursive tree walkers with different flavours
 * @module json/walker
 */

/**
 * Checks if the provided parameter is an object
 * @param obj the variable to check
 * @returns true if the parameter is an object otherwise it returns false
 */
function isObject(obj) {
  return obj && typeof obj === "object";
}

/**
 * Checks if the provided parameter is an array
 * @param obj the variable to check
 * @returns true if the parameter is an array otherwise it returns false
 */
function isArray(obj) {
  return Array.isArray(obj);
}

/**
 * Checks if the provided parameter is a function
 * @param obj the variable to check
 * @returns true if the parameter is a function otherwise it returns false
 */
function isFunction(obj) {
  return obj && {}.toString.call(obj) === '[object Function]';
}

/**
 * Callback of the forEach function called for each node it walks
 * @callback forEachCallback
 * @param {string} name of the node
 * @param {object} node
 */

/**
 * Loops over all elements in an object and calls the specified callback(key,obj)
 * @param {object} obj
 * @param {forEachCallback} callback
 */
function forEach(obj, callback) {
  for(var key in obj) {
    callback(key, obj[key]);
  }
}

/**
 * Callback of the walk function
 * @callback walkCallback
 * @param {boolean} isNode specifies if node or leaf
 * @param {object} node
 */

/**
 * Walks all nodes calling the provided callback function for each node
 * @param {object} node to start from
 * @param {walkCallback} callback function called for each node: callback(isNode,node)
 */
function walk(node, callback) {

  function filterNodes(objs, result) {
    for(var key in objs) {
      var obj = objs[key];
      if(isObject(obj))
        result.push(obj);
      else
        callback(false,obj);
    }
  }

  var next = [node];
  while(next.length>0) {
    var more = []
    next.forEach(X => {
      filterNodes(X, more);
      callback(true,X);
    });
    next = more;
  } // while array not empty
}


/**
 * Callback of the walkWithPath function
 * @callback walkWithPathCallback
 * @param {boolean} isNode false if leaf
 * @param {array} path specifies the path from the root to the node
 * @param {object} node
 */

/**
 * Walks all nodes calling the provided callback function for each node
 * @param {object} node to start from
 * @param {walkWithPathCallback} callback function called for each node: callback(isNode,path,node)
 * @param check - optional callback function which returns true if the walk should continue
 */
function walkWithPath(node, callback, check) {

  function filterNodes (path, objs, result) {
    for(var key in objs) {
      var obj = objs[key];
      var newPath = path.concat([key]);
      if(isObject(obj)) {
        if(check) { // callback provided - ask if the scan should proceed
          if(check(newPath,obj))
            result.push([newPath,obj]);
        } else {
          result.push([newPath,obj]);
        }
      } else {
        callback(false,path.concat([key]),obj);
      }
    }
  }

  var next = [[[],node]];
  while(next.length>0) {
    var more = []
    next.forEach(X => {
      var P,O;
      [P,O] = X;
      filterNodes(P, O, more);
      callback(true,P,O);
    });
    next = more;
  } // while array not empty
}

/**
 * Callback of the walkNodesEx function called for each node it walks
 * @callback walkNodesExCallback
 * @param {object} node
 * @returns {object} next node to walk
 */

/**
 * Walks nodes using a callback to select which child node to walk further
 * @param {object} root node to start from
 * @param {walkNodesExCallback} callback obtains the next node to walk, passing the current node as parameter
 */
function walkNodesEx(root, callback) {

  function filterNodes(obj, result) {
    // extract child objects
    for(var key in obj) {
      let iobj = obj[key];
      if(isObject(iobj)) {
        let nobj = callback(iobj);
        if(nobj) {
          result.push(nobj);
        }
      }
    }
  } // filterNodes

  let next = [root];
  while(next.length>0) {
    var more = []
    next.forEach(iobj => {
      filterNodes(iobj, more);
    });
    next = more;
  } // while array not empty
}

/**
 * Callback of the walkNodesExFn function called for each node it walks
 * @callback walkNodesExFnCallback
 * @param {object} node
 * @returns {object} next array of: node to walk and a walkNodesExFnCallback function or an array of such functions
 */

/**
 * Walks nodes using context-dependent callbacks to select which child node to walk further
 * @param {object} root node to start from
 * @param {walkNodesExFnCallback} callback obtains the next node to walk and the filter funtions, passing the current node as parameter
 */
function walkNodesExFn(root, callback) {

  function filterNodes(obj, nextcallback, result) {
    // extract child objects
    for(var key in obj) {
      let iobj = obj[key];
      if(isObject(iobj)) {
        let nobj = nextcallback(iobj);
        if(nobj) {
          if(isArray(nobj) && !isFunction(nobj[1])) {
            nobj.forEach(NO => {
              if(NO !== undefined)
                result.push(NO)
            });
          } else {
            result.push(nobj);
          }
        }
      }
    }
  } // filterNodes

  let next = [[root,callback]];
  while(next.length>0) {
    var more = [];
    next.forEach(iobj => {
      if(iobj === undefined)
        return;
      let [O,F] = iobj;
      if(isArray(F)) {
        forEach(F, V => {
          filterNodes(O, V, more);
        });
      } else {
        filterNodes(O, F, more);
      }
    });
    next = more;
  } // while array not empty
}

/**
 * Callback of the walkNodesExFnPath function called for each node it walks
 * @callback walkNodesExFnPathCallback
 * @param {array} path
 * @param {object} node
 * @returns {object} next array of: node to walk and a walkNodesExFnCallback function or an array of such functions
 */

/**
 * Walks nodes using context-dependent callbacks to select which child node to walk further
 * @param {object} root node to start from
 * @param {walkNodesExFnPathCallback} callback obtains the next node to walk and the filter funtions, passing the current node as parameter
 */
function walkNodesExFnPath(root, callback) {

  function filterNodes(path, obj, nextcallback, result) {
    if(!isObject(obj)) {
      nextcallback(path,obj);
      return;
    }
    for(var key in obj) {
      let iobj = obj[key];
      let newPath = path.concat([key]);
      let nobj = nextcallback(newPath,iobj);
      if(nobj) {
        if(isArray(nobj) && !isFunction(nobj[1])) {
          nobj.forEach(NO => {
            if(NO !== undefined) {
              result.push([newPath,NO[0],NO[1]])
            }
          });
        } else {
          result.push([newPath,nobj[0],nobj[1]]);
        }
      }
    }
  } // filterNodes

  let next = [[[],root,callback]];
  while(next.length>0) {
    var more = [];
    next.forEach(iobj => {
      if(iobj === undefined)
        return;
      let [P,O,F] = iobj;
      if(isArray(F)) {
        forEach(F, V => {
          filterNodes(P, O, V, more);
        });
      } else {
        filterNodes(P, O, F, more);
      }
    });
    next = more;
  } // while array not empty
}

/**
 * Callback of the walkNodesEx function to obtain the next node to walk
 * @callback getNextNode
 * @param {object} node
 * @returns {object} next node to walk
 */

/**
 * Callback of the walkNodesExWithPath function called for each node it walks
 * @callback walkNodesExWithPathCallback
 * @param {array} path
 * @param {object} node
 */

/**
 * Walks nodes using a callback to select which child node to walk further
 * @param root node to start from
 * @param {getNextNode} getNextNode callback to obtain the next node to walk, passing the current node as parameter
 * @param {walkNodesExWithPathCallback} callback called on each walked node passing that node: callback(node)
 */
function walkNodesExWithPath(root, getNextNode, callback) {

  function filterNodes(path, obj, result) {
    // extract child objects
    for(var key in obj) {
      let iobj = obj[key];
      if(isObject(iobj)) {
        let nobj = getNextNode(iobj);
        if(nobj) {
          var newPath = path.concat([key]);
          result.push({p:newPath,o:nobj});
          callback(newPath,nobj);
        }
      }
    }
  } // filterNodes

  var next = [{p:[],o:root}];
  while(next.length>0) {
    var more = [];
    next.forEach(function (X) {
      filterNodes(X.p, X.o, more);
    });
    next = more;
  } // while array not empty
}


/**
 * Callback of the walkNodesEx function to obtain the next node to walk
 * @callback getNextElements
 * @param {object} node
 * @returns {object} next node to walk
 */

/**
 * Callback of the walkElementsEx function called for each element it walks
 * @callback walkElementsExCallback
 * @param {object} node
 */

/**
 * Walks elements using a callback to select which child node to walk further
 * @param {object} root node to start from
 * @param {getNextElements} getNextElements callback to obtain the next node to walk, passing the current node as parameter
 * @param {walkElementsExCallback} callback called on each walked node passing that node: callback(node)
 */
function walkElementsEx(root, getNextElements, callback) {

  function filterNodes(obj, result) {
    // extract child objects
    for(var key in obj) {
      let iobj = obj[key];
      let nobj = getNextElements(iobj);
      if(nobj) {
        result.push(nobj);
        callback && callback(nobj)
      }
    }
  } // filterNodes

  let next = [root];
  while(next.length>0) {
    var more = []
    next.forEach(iobj => {
      filterNodes(iobj, more);
    });
    next = more;
  } // while array not empty
}

/**
 * Walks elements using a callback to select which child node to walk further.
 * While walking it builds a resulting structure calling the second callback.
 * @param {object} root node to start from
 * @param {getNextElements} getNextElements callback to obtain the next node to walk, passing the current node as parameter
 * @param {build} callback called on each walked node passing that node and returns the resulting product of the operation on this node
 */
function walkAndBuild(root, getNextElements, build) {

  function filterAndBuild(obj, ret, result) {
    // extract child objects
    for(var key in obj) {
      let iobj = obj[key];
      if(isObject(iobj)) {
        let nobj = getNextElements(iobj);
        if(nobj!==undefined) {
          ret[key]=build(iobj); // build resulting structure
          result.push([nobj,ret[key]]);
        }
      }
    }
  } // filterAndBuild

  let R = build(root); // resulting structure

  let next = [[getNextElements(root),R]];
  while(next.length>0) {
    var more = []
    next.forEach(iobj => {
      filterAndBuild(iobj[0], iobj[1], more);
    });
    next = more;
  } // while array not empty

  return R;
} // walkAndBuild

module.exports = {
  forEach,
  walk,
  walkNodesEx,
  walkNodesExFn,
  walkNodesExFnPath,
  walkWithPath,
  walkNodesExWithPath,
  walkElementsEx,
  walkAndBuild
}
