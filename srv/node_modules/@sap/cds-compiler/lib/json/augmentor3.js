let W = require("./walker");
let nullProtos = require("./nullprotos3.js");

//main entry point
function augment(model) {

  let U = require("./augmentor3utils.js")(model)
  let transformers = require("./augmentor3transormers.js")(model)

  // here starts the augmentation

  nullProtos(model, {setAllMissingProtos:true}); // set the protos of dict nodes to null

  // traverse the whole tree and dependent of the node's proto calls the appropriate function
  W.walkWithPath(model, (isNode,PATH,NODE) => {
    if (NODE === null)
      return;
    if(!isNode)
      return;
    let section = PATH[0];
    if(!["definitions","extensions"].includes(section))
      return;
    if(section === "definitions" && PATH.length === 2) // definition
      transformers.augmentDefinition(PATH[1], NODE, PATH);
    if(section === "extensions" && PATH.length === 2) // extension
      transformers.augmentExtension(PATH[1], NODE, PATH);

    let PROTO = Object.getPrototypeOf(NODE);
    W.forEach(NODE, (key,node) => {
      if(PROTO) {
        let isAnnotation = key.charAt(0)==='@';
        let T = transformers[isAnnotation ? '@' : key];
        if(T) {
          if(!U.isAugmented(NODE[key])) // prevent double augmentation
            T(NODE, key, PATH);
        }
      } else { // dict
        if(getLastElement(PATH) === "elements") {
          transformers.augmentElement(key, node, PATH);
        }
        if(getLastElement(PATH) === "payload") {
          transformers.augmentElement(key, node, PATH);
        }
        if(getLastElement(PATH) === "enum") {
          transformers.augmentEnumItem(key, node, PATH);
        }
        if(getLastElement(PATH) === "params") {
          transformers.augmentParam(key, node, PATH);
        }
        if(getLastElement(PATH) === "actions") {
          transformers.augmentAction(key, node, PATH);
        }
      }
    }) // forEach
  }, (path,obj) => { // check function
    let le = U.getLastElement(path)
    if(le==="$extra") // skip $extra from validator
      return false;
    if(le[0]==="@")
      return false; // do not walk annotations
    if(U.isAugmented(obj)) {
      return false;
    }
    return true;
  }) // walkWithPath

  // remove "augmented" flag
  W.walk(model, (isNode,NODE) => {
    if(isNode && U.isAugmented(NODE)) {
      U.unsetAugmented(NODE)
    }
  })

  if(model.namespace) {
    model.namespace = {
      path: [
        {id:model.namespace, location: U.newLocation(["namespace"])}
      ]
    }
  }

  processLocations(model)

  //returns the last element of an array
  function getLastElement(a) {
    return a[a.length-1];
  }

  //converts $location to xsn-location
  function toXSNLocation(l) {
    let r = {
      filename: l.file,
      start: {line:l.line, column: l.col},
      end: {line:l.line, column: l.col},
      $weak:true
    }
    return r;
  }

  // walks object in depth and replaces location with $location recursively by passing down the $location
  function processLocations(NODE,location,path=[]) {
    if(typeof NODE != "object") return;
    W.forEach(NODE, (name,node) => {
      if(!node) return;
      if(name=="$location") return;
      if(name=="location") return;
      let newLocation = location;
      if(node.$location) {
        newLocation  = toXSNLocation(node.$location)
      }
      processLocations(node,newLocation,path.concat(name))
      if(newLocation && node.location)
        node.location=newLocation;
      if(node.$location)
        delete node.$location;
    })
  }

  return model;

} // function augment

module.exports = {
  augment
};
