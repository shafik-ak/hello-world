// Compiler phase "define": transform dictionary of AST-like CSNs into augmented CSN

// AST-like CSN looks as follows:
//   { kind: 'source', env: <dictionary of artifact defs>, namespace: {}, ... }
//
// The property `artifacts` of a source contains the top-level definitions.
// Definitions inside a context are not listed here (as opposed to
// `definitions`, see below), but inside the property `artifacts` of that context.

// The define phase (function 'initSources' below) enriches a dictionary of
// (file names to) AST-like CSNs and restructure them a little bit, the result
// is called "augmented CSN":
//   { sources: <dictionary of ASTs>, definitions: <dictionary of artifact defs> }
//
// The property `sources` is the input argument (dictionary of source ASTs).
//
// The property `definitions` is set by this compiler phase.  It contains the
// definitions of all main artifacts (i.e. not elements) from all sources, the
// key is the absolute name of that artifact.  These definitions are the same
// objects as the definitions accessible via `sources` and `artifacts` of the
// corresponding source/context.
//
// Because different sources could define artifacts with the same absolute
// name, this compiler phase also put a property `messages` to the resulting
// model, which is a vector of messages for the redefinitions.  (Using the same
// name for different definitions in one source is already recognized during
// parsing.)
//
// You get the compact "official" CSN format by applying the function exported
// by "../json/compactor.js" to the augmented CSN.

// Example 'file.cds':
//   namespace A;
//   context B {
//     type C { elem: String(4); }
//   }
// Check the augmented CSN by compiling it with
//   cdsv --raw-output file.cds
//
// ┌───────────────┐           ┌───────────────────────────────────────────┐
// │    sources    │           │                 definitions               │
// └──┬────────────┘           └──┬────────────────────────────┬───────────┘
//    │                           │                            │
//    │ ['file.cds']              │ ['A.B']                    │ ['A.B.C']
//    ↓                           ↓                            ↓
// ┌───────────────┐  _parent  ┌────────────────┐  _parent  ┌──────────────┐
// │ kind:'source' │←──────────┤ kind:'context' │←──────────┤ kind: 'type' │
// │ artifacts: ───┼──────────→│ artifacts: ────┼──────────→│ ...          │
// └───────────────┘   ['B']   └────────────────┘   ['C']   └──────────────┘
//
// The _parent properties are not shown in the JSON - they are used for name
// resolution, see file './resolver.js'.

// An artifact definition looks as follows (example: context "A.B" above):
//   {
//     kind: 'context',
//     name: { id: 'B', absolute: 'A.B', location: { <for the id "B"> } },
//     artifacts: <for contexts, a dictionary of artifacts defined within>,
//     location: { <of the complete artifact definition> } },
//     _parent: <the parent artifact, here the source 'file.cds'>
//   }
// The properties `name.absolute`, `name.component` and `_parent` are set
// during this compiler phase.

// The definition of an entity or a structured type would contain an `elements`
// property instead of an `artifacts` property.

// An element definition looks as follows (example: "elem" above):
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: { <for the id "elem"> } }
//     type: { path: [ { id: 'String', location: ... } ] },
//     typeArguments: [ { number: '4', location: ... } ]
//     location: { <of the complete element definition> } },
//     _parent: <the parent artifact, here the type "A.B.C">
//   }
// References are resolved in the "resolve" phase of the compiler, see
// './resolver.js'.  We then get the properties `type.absolute` and `length`.

'use strict';

const {
  getMessageFunction, searchName, weakLocation, hasErrors,
} = require('../base/messages');
const {
  queryOps, setProp, forEachGeneric, forEachInOrder, forEachMember,
}
      = require('../base/model');
const {
  addToDict, addToDictWithIndexNo, clearDict, dictLocation, pushToDict,
}
    = require('../base/dictionaries');
const {
  dictKinds,
  kindProperties,
  fns,
  setLink,
  linkToOrigin,
  setMemberParent,
  storeExtension,
  combinedLocation,
} = require('./shared');
const { compareLayer, layer } = require('./moduleLayers');
const initBuiltins = require('./builtins');
const { addBoolAnnotationTo } = require('../model/modelUtils');

// Export function of this file.  Transform argument `sources` = dictionary of
// AST-like CSNs into augmented CSN.  If a vector is provided for argument
// `messages` (usually the combined messages from `parse` for all sources), do
// not throw an exception in case of an error, but push the corresponding error
// object to that vector.  If at least one AST does not exist due to a parse
// error, set property `lintMode` of `options` to `true`.  Then, the resolver
// does not report errors for using directives pointing to non-existing
// artifacts.

function getDefinerFunctions( model ) {
  const { options } = model;
  // Get simplified "resolve" functionality and the message function:
  const message = getMessageFunction( model );
  const {
    resolveUncheckedPath,
    resolvePath,
    defineAnnotations,
    setAutoExposed,
  } = fns( model );
  const extensionsDict = Object.create(null);
  return {
    define,
    initArtifacts,
    lateExtensions,
    createLocalizedDataView,
    hasTruthyProp,
  };

  function define() {
    model.definitions = Object.create(null);
    setProp( model, '_entities', [] ); // for entities with includes
    model.$entity = 0;
    model.$compositionTargets = Object.create(null);
    model.$lateExtensions = Object.create(null); // for generated artifacts

    initBuiltins( model );
    for (const name in model.sources)
      initSource( model.sources[name] );

    applyExtensions();
    Object.keys( model.definitions ).forEach( processArtifact );
    lateExtensions( false );
    // Set _service link (sorted to set it on parent first).  Could be set
    // directly, but beware a namespace becoming a service later.
    Object.keys( model.definitions ).sort().forEach( setAncestorsAndService );
    forEachGeneric( model, 'definitions', postProcessArtifact );
    return model;
  }

  function checkRedefinitions( obj, name, prop, i ) {
    forEachMember( obj, checkRedefinitions, obj.target );
    if (i == null)
      return;
    if (obj.name.location.filename === '<built-in>') {
      // builtin types like namespace 'cds' or namespace 'localized' shouldn't be printed.
      // The error shall only be printed for the user-defined conflicting artifact.
      return;
    }
    message( 'duplicate-definition', obj.name.location, obj,
             { name, '#': (obj.kind === 'namespace') ? 'namespace' : dictKinds[prop] },
             'Error', {
               std: 'Duplicate definition of $(NAME)',
               absolute: 'Duplicate definition of artifact $(NAME)',
               namespace: 'Other definition blocks $(NAME) for namespace name',
               element: 'Duplicate definition of element $(NAME)',
               enum: 'Duplicate definition of enum $(NAME)',
               key: 'Duplicate definition of key $(NAME)',
               action: 'Duplicate definition of action or function $(NAME)',
               param: 'Duplicate definition of parameter $(NAME)',
             });
  }

  function acceptedInLocalized( art ) {
    return art.query ||
           art.kind === 'namespace' || art.kind === 'context'; // not service
  }

  function initSource( src ) {
    // handle sub model from CSN parser
    if (!src.kind)
      src.kind = 'source';
    if (src.definitions) {
      forEachGeneric( src, 'definitions', ( art, name ) => {
        if (name.startsWith( 'localized.')) {
          if (!Array.isArray( art ) && acceptedInLocalized( art )) {
            if (!src.$withLocalized) {
              src.$withLocalized = true;
              message( null, art.name.location, null, {}, 'Info',
                       'Input CSN contains localization view definitions which are re-calculated' );
            }
            art.$inferred = 'LOCALIZED-IGNORED';
            return;             // do not add localization view
          }
        }
        if (!art.kind)            // Wrong CSN input:
          art.kind = 'type';      // ...use default as defined for CSN (TODO: or extra to avoid further errors?)
        const dot = name.lastIndexOf('.');
        if (dot > name.indexOf('::')) // there is a dot (after '::')
          addAsContextArtifact( art, name.substring(dot + 1), name.substring(0, dot), src );
        setProp( art, '_block', src );
        addToDefinitions( art, name );
        initMembers( art, art, src );
      });
      initArtifacts( src, null, src, true, null, 'definitions' );
    }
    // handle sub model from CDL parser, handle `extensions` in sub models
    // (from all parsers) by `initArtifacts) argument collectExts = true
    initUsings( src, src.usings );
    const decl = src.namespace;
    const prefix = (decl && decl.dcPath) ? `${ pathName(decl.dcPath) }::` : '';
    const namespace = decl && decl.path &&
          namespaceContext( decl.path, prefix, undefined, decl.location );
    if (!namespace) {
      // also handles `extensions` property
      initArtifacts( src, namespace, src, true, prefix );
    }
    else {
      setProp( decl, '_artifact', namespace );
      // create using for own namespace:
      const last = decl.path[decl.path.length - 1];
      const builtin = model.$builtins[last.id];
      const { absolute } = namespace.name;
      if (builtin && !builtin.internal && absolute !== 'cds') {
        message( 'ref-shadowed-builtin', namespace.location, null, // no home artifact
                 { id: last.id, art: namespace, code: `using ${ builtin.name.absolute };` },
                 'Warning', '$(ID) now refers to $(ART) - consider $(CODE)' );
      }
      const block = {
        kind: 'source',
        filename: src.filename,
        name: { id: last.id, location: last.location }, // for --raw-output
        artifacts: Object.create(null),
      };
      block.artifacts[last.id] = { // assert( last.id === namespace.name.id )
        kind: 'using',               // TODO: or store namespace directly?
        // implicit: true,
        name: {
          id: last.id, absolute, location: last.location, calculated: true, $inferred: 'as',
        },
        extern: decl,
        location: decl.location,
      };
      setProp( src, '_block', block );
      initArtifacts( src, namespace, src, true );
    }
  }

  function namespaceContext( path, prefix = '', parent, declLocation ) {
    // declLocation also means: check reserved cds on last item
    let absolute;
    if (path.broken)
      return parent;
    const check = declLocation && path[path.length - 1];
    for (const item of path) {
      const { id } = item;
      absolute = (absolute) ? `${ absolute }.${ id }` : prefix + id;
      let context = model.definitions[absolute];
      if (!context || context instanceof Array ||
          !kindProperties[context.kind].artifacts) {
        const location = combinedLocation( path[0], item );
        context = {
          kind: 'namespace',
          name: { id, location, absolute },
          blocks: [],
          artifacts: Object.create(null),
          location: declLocation || location,
        };
        if (parent) {
          if (!parent.artifacts)
            parent.artifacts = Object.create(null);
          addToDict( parent.artifacts, id, context );
        }
        addToDefinitions( context, absolute, undefined, undefined, item !== check || 0);
        setProp( context, '_parent', parent || null );
      }
      setProp( item, '_artifact', context );
      parent = context;
    }
    return parent;
  }

  // Set property `name.absolute` or artifact `art` to `absoluteName`.  Also
  // store `art` in the `definition` property of the model and complain if
  // another artifact has already been defined with the same absolute name.
  function addToDefinitions( art, absolute = art.name.absolute, prefix, parent, noReservedCheck ) {
    let context = reuse();
    // console.log(context?'Reuse':'Def',art.name,prefix ,parent&&parent.name)
    if (context)
      return context;
    if (prefix != null && art.name.path && art.name.path.length > 1) {
      const path = [ ...art.name.path ];
      const id = path.pop();
      art.name.id = id.id;
      context = namespaceContext( path, prefix, parent );
      addToDict( context.artifacts, id.id, art );
      setProp( art, '_parent', context );
    }
    else if (parent && art.name.path) {
      addToDict( parent.artifacts, art.name.path[0].id, art );
      setProp( art, '_parent', parent );
    }
    else if (!('_parent' in art)) {
      setProp( art, '_parent', null );
    }
    if (noReservedCheck || checkReserved())
      addToDict( model.definitions, absolute, art );
    return art;

    function checkReserved() {
      if (absolute === 'cds' ||
          absolute.match(/^cds\./) && !absolute.match(/^cds\.foundation(\.|$)/)) {
        message( null, art.name.location, null,
                 'The namespace "cds" is reserved for CDS builtins' );
        return !model.definitions[absolute];
      }
      else if (noReservedCheck !== 0 &&
               (absolute === 'localized' || absolute.startsWith('localized.'))) {
        message( null, art.name.location, null,
                 'The namespace "localized" is reserved for localization views' );
        return false;
      }
      return true;
    }

    function reuse( ) {
      if (!kindProperties[art.kind].artifacts)  // no context, service or namespace
        return undefined;
      const found = model.definitions[absolute];
      if (!found || found instanceof Array)
        return undefined;
      if (art.kind === 'namespace' && kindProperties[found.kind].artifacts)
        // we are namespace, `found` is context, service or namespace
        return found;
      if (found.kind !== 'namespace')
        return undefined;
      found.kind = art.kind;    // use non-namespace kind
      found.name = art.name;    // use name (its location!) of definition
      return found;
    }
  }

  function addAsContextArtifact( art, name, contextName, src ) {
    let context = src.definitions[contextName];
    if (!context) {
      const { location } = art.name;
      let colons = contextName.indexOf('::');
      colons = (colons < 0) ? 0 : colons + 2;
      const path = contextName.substring(colons).split('.').map( id => ({ id, location }) );
      context = namespaceContext( path, contextName.substring(0, colons) );
    }
    if (context instanceof Array || !context.kind) // no proper construct
      return;
    if (!kindProperties[context.kind].artifacts) // no context or service
      return;
    if (!context.artifacts)
      context.artifacts = Object.create(null);
    addToDict( context.artifacts, name, art );
    setProp( art, '_parent', context );
  }

  // Initialize the USING declarations in source `src`.  Add the corresponding
  // names to the top-level search environment of the source, and set the
  // absolute name referred by the USING declaration.
  function initUsings( src, usings ) {
    if (!usings)
      return;
    if (!src.artifacts)
      src.artifacts = Object.create(null);
    for (const def of usings) {
      if (def.usings) {
        initUsings( src, def.usings );
        continue;
      }
      const ue = def.extern;
      if (!def.name) {
        def.name = Object.assign( { calculated: true, $inferred: 'as' },
                                  ue.path[ue.path.length - 1] );
      }
      if (!(ue.path.broken || ue.dcPath && ue.dcPath.broken)) {
        def.name.absolute = (ue.dcPath)
          ? `${ pathName(ue.dcPath) }::${ pathName(ue.path) }`
          : pathName(ue.path);
      }
      if (ue.path[0] && ue.path[0].id === 'localized') {
        def.$inferred = 'LOCALIZED-IGNORED';
        message( null, ue.location, ue, {}, 'Warning',
                 'Localization views cannot be referred to - ignored USING' );
      }
      else {
        addToDict( src.artifacts, def.name.id, def, ( name, loc, art ) => {
          if (art.kind === 'using') { // repeated defs would be shown repeatedly otherwise
            message( 'duplicate-using', loc, null, { name }, 'Error',
                     'Duplicate definition of top-level name $(NAME)' );
          }
        } );
      }
    }
  }

  // Set property `_parent` for all sub artifact in `parent` to `parent` and do
  // so recursively for all sub artifacts.  Also set the property
  // `name.absolute` of all those artifacts with the help of argument `prefix`
  // (which is basically the absolute name of `parent` plus a dot).  If a sub
  // artifact has elements, call function `initElements`.
  function initArtifacts( construct, parent, block, collectExts,
                          prefix = `${ parent.name.absolute }.`, defProp ) {
    // if (parent && !checkDefinitions( construct, parent, 'artifacts' ))
    //   return;
    // TODO: the checkDefinitions must be propably checked by the parsers
    // let dottedNames = [];
    // let namespaces = Object.create(null);
    for (const name of Object.keys( construct.artifacts || {} )) {
      // no `forEachGeneric` as setName might add artifacts, e.g. "A" for "A.B"
      const def = construct.artifacts[name];
      if (def instanceof Array) {
        for (const art of def)
          setName( art, name );
      }
      else {
        setName( def, name );
      }
    }
    // defineAnnotations() and collectArtifactExtensions() in init() requires
    // names of other artifacts in context
    // var namespaceParent = { artifacts: Object.create(null) };
    forEachGeneric( construct, defProp || 'artifacts', init );
    if (collectExts)
      collectArtifactExtensions( construct, block );
    return;

    function setName( art, localName ) {
      if (art.kind === 'using')
        return;
      setProp( art, '_block', block );
      art.name.absolute = prefix + localName;

      if (block !== model.$internal &&
          (prefix || localName).startsWith('localized.') &&
          acceptedInLocalized( art )) {
        if (block && block.$frontend !== 'json') {
          message( null, art.name.location, art, {}, 'Info',
                   'This definition in the namespace "localized" is ignored' );
        }
        art.$inferred = 'LOCALIZED-IGNORED';
        return;
      }
      const { path } = art.name;
      if (!path || path.length <= 1)
        return;
      const root = path[0];
      const { id } = root;
      const namespace = namespaceContext( [ root ], prefix, parent );
      if (construct.artifacts[id])
        // TODO: complain if USING uses that name
        return;                 // TODO: do we need to set root._artifact?
      const name = { absolute: prefix + id, id, location: root.location };
      setProp( name, '_artifact', namespace );
      construct.artifacts[id] = { kind: 'block', name, pathPrefix: true };
    }

    function init( art ) {
      // real.path as name, or using proxies, or accepted view in "localized":
      if (art.pathPrefix || art.kind === 'using' || art.$inferred === 'LOCALIZED-IGNORED')
        return;
      if (kindProperties[art.kind].artifacts) { // context or service
        if (defProp) {                            // from JSON parser
          defineAnnotations( art, art, block );
          art.blocks = [ null ];  // TODO: assert that there are no blocks before
          if (!art.artifacts)   // if art had been no namespace before
            art.artifacts = Object.create(null); // TODO: test with A.B.C then A.B in definitions
          serviceIncludes( art );
          return;
        }
        const env = art;
        art = addToDefinitions( shallowContext(env), undefined, prefix, parent );
        env.kind = 'block';
        env.name.query = art.blocks.length;
        setProp( env.name, '_artifact', art );
        setProp( env, '_parent', art );
        art.blocks.push( env );
        defineAnnotations( env, art, block ); // requires name.absolute of siblings!
        initArtifacts( env, art, env, collectExts );
        if ( env.includes ) {
          art.includes = env.includes;
          delete env.includes;
        }
        if ( env.abstract ) {
          art.abstract = env.abstract;
          delete env.abstract;
        }
        // initMembers(art, art, block); // if we define "service-bound" actions
        serviceIncludes( art );
      }
      else if (art.query) {     // view or projection
        if (!defProp)
          addToDefinitions( art, undefined, prefix, parent, block === model.$internal );
        defineAnnotations( art, art, block );
        if (art.source)         // from old-style CSN - TODO: error!?
          return;
        initDollarSelf( art ); // to allow extend projection with auto-mixin assoc, see #924
        initParams( art );
        art.$from = [];         // for sequence of resolve steps
        art.$queries = [];
        art.queries = [];       // TODO: remove
        setProp( art, '_leadingQuery', initQueryExpression( art, art.query ) );
        if (art._leadingQuery) // null in case of parser error
          setProp( art._leadingQuery, '_$next', art );
        // resolve parameters and actions:
        initMembers( art, art, block ); // before setting art.elements!
        // TODO: Also allow extension if without union (even then, but later
        // check checks whether union can be used)?
      }
      else {
        if (!defProp)
          addToDefinitions( art, undefined, prefix, parent );
        if (art.dbType && !options.hanaFlavor)
          message( null, art.dbType.location, art, 'TABLE TYPE is not supported yet' );
        defineAnnotations( art, art, block );
        initMembers( art, art, block );
        const { absolute } = art.name;
        if (art.includes && !(absolute in extensionsDict))
          extensionsDict[absolute] = []; // structure with includes must be "extended"
        initDollarSelf( art );
      }
    }

    function initDollarSelf( art ) {
      const selfname = (options.hanaFlavor) ? art.name.id : '$self';
      // TODO: users setMemberParent() ?
      const self = {
        name: { id: selfname, alias: selfname, absolute: art.name.absolute },
        kind: '$tableAlias',
        self: true,
        type: {},
        location: art.location,
      };
      setProp( self, '_parent', art );
      setProp( self, '_main', art ); // used on main artifact
      setProp( self.type, '_artifact', art );
      art.$tableAliases = Object.create(null);
      art.$tableAliases[selfname] = self;
      setProp( art, '_$next', model.$magicVariables );
    }

    function initParams( art ) {
      // TODO: users setMemberParent() ?
      const parameters = {
        name: { id: '$parameters', param: '$parameters', absolute: art.name.absolute },
        kind: '$parameters',
        location: art.location,
      };
      setProp( parameters, '_parent', art );
      setProp( parameters, '_main', art );
      // Search for :const after :param.  If there will be a posibility in the
      // future that we can extend <query>.columns, we must be sure to use
      // _block of that new column after :param (or just allow $parameters there).
      setProp( parameters, '_block', art._block );
      if (art.params) {
        parameters.elements = art.params;
        parameters.$tableAliases = art.params; // TODO: find better name - $lexical?
      }
      art.$tableAliases.$parameters = parameters;
    }
  }

  function initSubQuery( query ) {
    query.queries = [];
    if (query.on)
      initExprForQuery( query.on, query );
    // TODO: MIXIN with name = ...subquery (not yet supported anyway)
    for (const elem of query.columns || []) {
      if (elem && elem.value) {
        setProp( elem, '_block', query._block );
        defineAnnotations( elem, elem, query._block );
        initExprForQuery( elem.value, query ); // adds to query.queries
      }
    }
    if (query.where)
      initExprForQuery( query.where, query );
    if (query.having)
      initExprForQuery( query.having, query );
    initMembers( query, query, query._block );
  }

  function initExprForQuery( expr, query ) {
    if (expr instanceof Array)
      expr.forEach( e => initExprForQuery( e, query ) );
    else if (!expr || !expr.op)
      return;
    else if (expr.op && queryOps[expr.op.val])
      initQueryExpression( query, expr ); // adds to query.queries

    else if (expr.args)
      expr.args.forEach( e => initExprForQuery( e, query ) );
  }

  // for an example, see view V006 in test/fromHanaCDS/positive/Queries_Subquery_ok
  function initQueryExpression( art, query, parents = [] ) {
    while (query instanceof Array) // query / join args in parentheses
      [ query ] = query;
    if (!query)                 // parse error
      return query;

    if (query.path) {           // path in FROM - this query is a table ref
      if (!query.path.length || query.path.broken)
        // parse error (e.g. final ',' in FROM), projection on <eof>
        return query;
      if (!query.name) {
        const last = query.path[query.path.length - 1];
        const dot = last.id.lastIndexOf('.');
        const id = (dot < 0) ? last.id : last.id.substring( dot + 1 );
        // TODO: if we have too much time, we can calculate the real location with '.'
        query.name = {
          calculated: true, $inferred: 'as', id, location: last.location,
        };
      }
      addAlias( { type: query }, query );
      if (art.kind !== 'query')
        art.$from.push( query ); // store tabref if outside "real" subquery
    }
    else if (query.join) {
      if (query.on) {
        addQuery( parents[0].name.query );
        initSubQuery( query );
        parents = [ ...parents, query ];
      }
      for (const tab of query.args)
        initQueryExpression( art, tab, parents );
      if (query.name) {         // with ON (after processing args to get the $tableAliases
        const aliases = Object.keys( query.$tableAliases || {} );
        // Use first tabalias name on the right side of the join to name the
        // (internal) query, should only be relevant for --raw-output, not for
        // user messages or references
        query.name.param = aliases[1] || aliases[0] || '<unknown>';
      }
    }
    else if (query.from) {      // select
      addQuery( (art._main || art).$queries.length );
      // TODO: 1-based if view elems are proxies to leading queries elements
      query._main.$queries.push( query );
      if (parents.length)
        addAlias( {}, query );
      for (const tab of query.from)
        initQueryExpression( art, tab, [ query ] );
      if (query.mixin)
        addMixin();
      if (!query.$tableAliases.$projection) {
        // TODO: use setMemberParent() ?
        query.$tableAliases.$projection = {
          name: { alias: '$projection', query: query.name.query, absolute: art.name.absolute },
          kind: '$tableAlias',
          self: true,
          location: query.location,
        };
        setProp( query.$tableAliases.$projection, '_parent', query );
        setProp( query.$tableAliases.$projection, '_main', query._main );
        setProp( query.$tableAliases.$projection, '_finalType', query );
      }
      if (!query.$tableAliases.$self) { // same as $projection
        query.$tableAliases.$self = {
          name: { alias: '$self', query: query.name.query, absolute: art.name.absolute },
          kind: '$tableAlias',
          self: true,
          location: query.location,
        };
        setProp( query.$tableAliases.$self, '_parent', query );
        setProp( query.$tableAliases.$self, '_main', query._main );
        setProp( query.$tableAliases.$self, '_finalType', query );
      }
      initSubQuery( query );    // after from / mixin
    }
    else if (query.args) {      // UNION, INTERSECT, ..., sub query
      const leading = initQueryExpression( art, query.args[0], [] );
      for (const q of query.args.slice(1))
        initQueryExpression( art, q, [] );
      setProp( query, '_leadingQuery', leading );
      if (leading && query.orderBy) {
        if (leading.$orderBy)
          leading.$orderBy.push( ...query.orderBy );
        else
          leading.$orderBy = [ ...query.orderBy ];
        query.orderBy.forEach( ob => setProp( ob, '_$queryNode', query ) ); // TODO: we can again remove that
      }
      // ORDER BY to be evaluated in leading query (LIMIT is literal)
      if (parents.length)
        addAlias( query, leading );
    }
    // else: with parse error (`select from <EOF>`, `select from E { *, ( select }`)
    return query._leadingQuery || query;

    function signalDuplicate( name, loc ) {
      message( 'duplicate-definition', loc, query, { name, '#': '$tableAlias' },
               'Error',
               { $tableAlias: 'Duplicate definition of table alias or mixin $(NAME)' } );
    }

    function addAlias( alias, subquery ) {
      if (!alias.type)
        setProp( alias, '_finalType', subquery );
      if (!query.name || !query.name.id) {
        message( 'query-req-alias', query.location, query, {}, // TODO: not subquery.location ?
                 'Error', 'Table alias is required for this subquery' );
        return;
      }
      if (alias !== query) {
        alias.name = { id: query.name.id, location: query.name.location };
        alias.location = query.location;
      }
      alias.kind = '$tableAlias';
      const parent = parents[0];
      setMemberParent( alias, alias.name.id, parent );
      if (!parent._firstAliasInFrom)
        setProp( parent, '_firstAliasInFrom', alias );
      setProp( subquery, '_tableAlias', alias );
      for (const p of parents) {
        // console.log('ADD:', query.name.id, parents.length, p)
        addToDict( p.$tableAliases, alias.name.id, alias, p === parent && signalDuplicate );
      }
    }

    function addMixin() {
      // TODO: re-check if mixins have already duplicates
      for (const name in query.mixin) {
        const mixin = query.mixin[name];
        if (!(mixin instanceof Array)) {
          setMemberParent( mixin, name, query );
          // TODO: without old CSN: delete 'alias & $mixin', keep element and set kind='mixin'
          mixin.name.alias = mixin.name.element;
          delete mixin.name.element;
          mixin.name.$mixin = true;
          setProp( mixin, '_block', art._block );
          // TODO: do some initMembers() ?  If people had annotation
          // assignments on the mixin... (also for future mixin definitions
          // with generated values)
          addToDict( query.$tableAliases, name, query.mixin[name], signalDuplicate );
        }
      }
    }

    function addQuery( name ) {
      setProp( query, '_$next', art );
      setProp( query, '_block', art._block );
      query.kind = 'query';
      if (!query.name)
        query.name = { location: query.location };
      setMemberParent( query, name, art );
      art.queries.push( query );
      query.$tableAliases = Object.create( null ); // table aliases and mixin definitions
    }
  }

  function shallowContext( ext ) {
    const art = {
      kind: ext.kind,
      name: Object.assign( {}, ext.name ),
      blocks: [],
      artifacts: Object.create(null),
      location: ext.location,
    };
    setProp( art, '_block', ext._block ); // keep _block for service includes
    // This means that we cannot "merge" two contexts in the future - nobody complained
    return art;
  }

  // Set property `_parent` for all elements in `parent` to `parent` and do so
  // recursively for all subelements.  Also set the property
  // `name.component` of the element with the help of argument `prefix`
  // (which is basically the component name of the `parent` element plus a dot).
  function initMembers( construct, parent, block ) {
    const isQueryExtension = kindProperties[construct.kind].isExtension &&
                           (parent._main || parent).query;
    let obj = construct.returns || construct; // why the extra `returns` for actions?
    if (construct.returns)
      setProp( obj, '_outer', construct ); // TODO: remove this `returns` property

    if (obj.items) {
      obj = obj.items;
      setProp( obj, '_outer', construct );
    }
    else if (obj.target && obj.target.elements) {
      obj = obj.target;
      setProp( obj, '_outer', construct );
    }
    if (obj !== parent && obj.elements && parent.enum) {
      for (const n in obj.elements) {
        const e = obj.elements[n];
        if (e.kind === 'element')
          e.kind = 'enum';
        delete e.indexNo;
      }
      // obj = Object.assign( { enum: obj.elements}, obj );
      // delete obj.elements;      // No extra syntax for EXTEND enum
      forEachGeneric( { enum: obj.elements }, 'enum', init );
    }
    else {
      if (checkDefinitions( construct, parent, 'elements', obj.elements || false ))
        forEachInOrder( obj, 'elements', init );
      if (checkDefinitions( construct, parent, 'enum', obj.enum || false ))
        forEachGeneric( obj, 'enum', init );
    }
    if (obj.foreignKeys)  // cannot be extended or annotated - TODO: check anyway?
      forEachInOrder( obj, 'foreignKeys', init );
    if (checkDefinitions( construct, parent, 'actions' ))
      forEachGeneric( construct, 'actions', init );
    if (checkDefinitions( construct, parent, 'params' ))
      forEachInOrder( construct, 'params', init );
    return;

    function init( elem, name, prop ) {
      if (!elem.kind)           // wrong CSN input
        elem.kind = dictKinds[prop];
      if (!elem.name) {
        const ref = elem.targetElement || elem.kind === 'element' && elem.value;
        if (ref && ref.path) {
          elem.name = Object.assign( { calculated: true, $inferred: 'as' },
                                     ref.path[ref.path.length - 1] );
        }
        else {                  // if JSON parser misses to set name
          elem.name = { id: name, location: elem.location };
        }
      }
      // if (!kindProperties[ elem.kind ]) console.log(elem.kind,elem.name)
      if (kindProperties[elem.kind].isExtension) {
        storeExtension( elem, name, prop, parent, block );
      }
      else if (isQueryExtension && elem.kind === 'element') {
        message( 'extend-query', elem.location, construct, // TODO: searchName ?
                 { art: parent._main || parent },
                 'Error', 'Query entity $(ART) can only be extended with actions' );
      }
      else {
        const bl = elem._block || block;
        setProp( elem, '_block', bl );
        setMemberParent( elem, name, parent, construct !== parent && prop );
        defineAnnotations( elem, elem, bl );
        initMembers( elem, elem, bl );
      }
    }
  }

  function checkDefinitions( construct, parent, prop, dict = construct[prop] ) {
    // To have been checked by parsers:
    // - artifacts (CDL-only anyway) only inside [extend] context|service
    if (!dict)
      return false;
    const names = Object.getOwnPropertyNames( dict );
    if (!names.length)
      return false;
    const feature = kindProperties[parent.kind][prop];
    if (feature &&
        (feature === true || construct.kind !== 'extend' || feature( prop, parent )))
      return true;
    const location = dictLocation( names.map( name => dict[name] ) );
    if (prop === 'actions') {
      message( 'unexpected-actions', location, construct, {}, 'Error',
               'Actions and functions only exist top-level and for entities' );
    }
    else if (parent.kind === 'action' || parent.kind === 'function') {
      message( 'extend-action', construct.location, construct, {}, 'Error',
               'Actions and functions cannot be extended, only annotated' );
    }
    else if (prop === 'params') {
      if (!feature) {
        message( 'unexpected-params', location, construct, {}, 'Error',
                 'Parameters only exist for entities, actions or functions' );
      }
      else {
        message( 'extend-with-params', location, construct, {}, 'Error', // remark: we could allow this
                 'Extending artifacts with parameters is not supported' );
      }
    }
    else if (feature) {         // allowed in principle, but not with extend
      message( 'extend-type', location, construct, {}, 'Error',
               'Only structures or enum types can be extended with elements/enums' );
    }
    else if (prop === 'elements') {
      message( 'unexpected-elements', location, construct, {}, 'Error',
               'Elements only exist in entities, types or typed constructs' );
    }
    else { // if (prop === 'enum') {
      message( 'unexpected-enum', location, construct, {}, 'Error',
               'Enum symbols can only be defined for types or typed constructs' );
    }
    return construct === parent;
  }

  // Set projection ancestors, and _service link for artifact with absolute name 'name':
  //  - not set: internal artifact
  //  - null: not within service
  //  - false: within abstract service
  //  - service: the artifact of the embedding service
  // This function must be called ordered: parent first
  function setAncestorsAndService( name ) {
    const art = model.definitions[name];
    if (!('_parent' in art))
      return;                   // nothing to do for builtins and redefinitions
    if (art.$from && !('_ancestors' in art))
      setProjectionAncestors( art );

    let parent = art._parent;
    if (parent === model.definitions.localized)
      parent = model.definitions[name.substring( 'localized.'.length )];
    const s = (parent && parent.kind !== 'service') ? parent._service : parent;
    const service = s && !s.abstract && s; // TODO: remove abstract service
    setProp( art, '_service', service );
    if (art._localized && typeof art._localized === 'object')
      setProp( art._localized, '_service', service );
    if (!parent || service == null) // do not return on false (= in abstract service)
      return;
    // reconstruct service (in parent) as the value is false for abstract service
    if (art.kind === 'service') {
      while (parent.kind !== 'service')
        parent = parent._parent;
      message( 'service-nested-service', art.name.location, art, { art: parent },
               [ 'Error' ], 'A service cannot be nested within a service $(ART)' );
    }
    else if (art.kind === 'context') {
      while (parent.kind !== 'service')
        parent = parent._parent;
      message( 'service-nested-context', art.name.location, art, { art: parent },
               [ 'Error' ], 'A context cannot be nested within a service $(ART)' );
    }
  }

  function setProjectionAncestors( art ) {
    // Must be run after processLocalizedData() as we could have a projection
    // on a generated entity.
    const chain = [];
    const autoexposed = art['@cds.autoexposed'];
    while (art && !('_ancestors' in art) &&
           art.$from && art.$from.length === 1 &&
           art.query.op && art.query.op.val === 'query') {
      chain.push( art );
      setProp( art, '_ancestors', null ); // avoid infloop with cyclic from
      const name = resolveUncheckedPath( art.$from[0], 'include', art );
      // TODO: do not set _ancestors if params change
      art = name && projectionAncestor( model.definitions[name], art.params );
      if (autoexposed)
        break;                  // only direct projection for auto-exposed
    }
    let ancestors = art && (!autoexposed && art._ancestors || []);
    for (const a of chain.reverse()) {
      ancestors = (ancestors ? [ ...ancestors, art ] : []);
      setProp( a, '_ancestors', ancestors );
      art = a;
    }
  }

  function projectionAncestor( source, params ) {
    if (!source)
      return source;
    if (!params)                // proj has no params => ok if source has no params
      return !source.params && source;
    const sourceParams = source.params || Object.create(null);
    for (const n in sourceParams) {
      if (!(n in params))       // source param is not projection param
        return null;            // -> cannot be used as implicit redirection target
    }
    for (const n in params) {
      const pp = params[n];
      const sp = sourceParams[n];
      if (sp) {
        if (sp.default && !pp.default) // param DEFAULT clause not supported yet
          return null;          // param is not optional anymore
        const pt = pp.type && resolveUncheckedPath( pp.type, 'type', pp );
        const st = sp.type && resolveUncheckedPath( sp.type, 'type', sp );
        if ((pt || null) !== (st || null))
          return null;          // params have different type
      }
      else if (!pp.default) {
        return null;
      }        // non-optional param in projection, but not source
    }
    return source;
  }

  function postProcessArtifact( art ) {
    tagCompositionTargets( art );
    if (!art._ancestors || art.kind === 'type')
      return;
    const service = art._service;
    if (!service)
      return;
    const sname = service.name.absolute;
    art._ancestors.forEach( expose );
    return;

    function expose( ancestor ) {
      if (ancestor._service === service)
        return;
      const desc = ancestor._descendants ||
                 setLink( ancestor, Object.create(null), '_descendants' );
      if (!desc[sname])
        desc[sname] = [ art ];
      else
        desc[sname].push( art );
    }
  }

  function processCompositionOfType( base ) {
    // TODO: we need to forbid COMPOSITION of entity w/o keys and ON anyway
    // TODO: consider entity includes
    // TODO: nested containment
    if (base.kind !== 'entity' || base.query || base.abstract && base.abstract.val)
      return;
    const keys = baseKeys();
    if (keys)
      forEachGeneric( base, 'elements', expand );
    return;

    function baseKeys() {
      const k = Object.create(null);
      for (const name in base.elements) {
        const elem = base.elements[name];
        if (elem instanceof Array)
          return false;           // no composition-of-type unfold with redefined elems
        if (elem.key && elem.key.val)
          k[name] = elem;
      }
      return k;
    }

    function expand( elem ) {
      if (elem.key && elem.key.val)
        return;
      let origin = elem;
      while (origin && !origin.target && origin.origin)
        origin = origin.origin._artifact;
      if (!origin || !origin.target || origin.onCond || origin.foreignKeys || !origin.type)
        return;
      const type = origin.type.path;
      if (!type || !type[0] || type[0].id !== 'cds.Composition')
        return;
      let { target } = origin;
      if (!target.elements) {
        // TODO: what about origin from non-abstract include?
        target = resolvePath( origin.target, 'compositionTarget', origin );
        if (!target || target.kind !== 'type' && !(target.abstract && target.abstract.val))
          return;
      }
      else if (!options.betaMode) {
        message( null, target.location, elem, {}, 'Error',
                 'COMPOSITION OF { … } is not generally available yet' );
      }
      const entityName = `${ base.name.absolute }_${ elem.name.id }`;
      const entity = allowCompositionOfType( target, elem, keys, entityName ) &&
                     createTargetEntity( target, elem, keys, entityName, base );
      if (!elem.target)
        elem.target = { location: elem.location };
      setLink( elem.target, entity );
      if (entity) {
        model.$compositionTargets[entity.name.absolute] = true;
        processCompositionOfType( entity );
        processLocalizedData( entity );
      }
    }
  }

  function allowCompositionOfType( target, elem, keys, entityName ) {
    if (Object.values( target.elements ).some( Array.isArray )) // with redefinitions
      return false;
    const location = elem.target && elem.target.location || elem.location;
    const keyNames = Object.keys( keys );
    if (!keyNames.length) {
      // TODO: for "inner type-compositions", signal already in type
      message( null, location, elem, { target }, 'Error',
               'A type $(TARGET) cannot be used as target in an entity without keys' );
      return false;
    }
    if (keys.parent) {
      // Cannot be in an "inner type-compositions" as it would already be wrong before
      // TODO: if anonymous type, use location of "parent" element
      // FUTURE: add sub info with location of "parent" element
      message( null, location, elem, { target, name: 'parent' }, 'Error',
               'A type $(TARGET) cannot be used as target in an entity with a key named $(NAME)' );
      return false;
    }
    if (target.elements.parent) {
      // TODO: for "inner type-compositions", signal already in type
      // TODO: if anonymous type, use location of "parent" element
      // FUTURE: if named type, add sub info with location of "parent" element
      message( null, location, elem, { target, name: 'parent' }, 'Error',
               'A type $(TARGET) with an element named $(NAME) cannot be used as target' );
      return false;
    }
    if (model.definitions[entityName]) {
      message( null, location, elem, { art: entityName }, 'Error',
               'Target entity $(ART) cannot be created as there is another definition with this name' );
      return false;
    }
    const names = Object.keys( target.elements ).filter( n => keyNames.includes(n) );
    if (names.length) {
      // FUTURE: if named type, add sub info with location of "parent" element
      message( null, location, elem, { art: entityName, names }, 'Error',
               'Key elements $(NAMES) cannot be added to $(TARGET) as these already exist' );
      return false;
    }
    return true;
  }

  function createTargetEntity( target, elem, keys, entityName, base ) {
    const location = elem.target && elem.target.location || elem.location;
    elem.onCond = {
      location,
      op: { val: '=', location },
      args: [
        augmentPath( location, elem.name.id, 'parent' ),
        augmentPath( location, '$self' ),
      ],
      $inferred: 'type-composition',
    };

    const elements = Object.create(null);
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, entityName ), location },
      location,
      elements,
      $inferred: 'type-composition',
    };
    addProxyElements( art, keys, 'type-composition', true, location );
    addToDictWithIndexNo( art, 'elements', 'parent', { // elements.parent = ...
      name: { location, id: 'parent' },
      kind: 'element',
      location,
      $inferred: 'type-composition',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, base.name.absolute ),
      onCond: augmentEqual( location, 'parent', Object.values( keys ) ),
    } );
    addProxyElements( art, target.elements, 'type-composition', false, location );

    const artifacts = Object.create(null);
    artifacts[entityName] = art;
    initArtifacts( { artifacts }, null, model.$internal, false, '' );
    return art;
  }

  function addProxyElements( proxyDict, elements, inferred, ignore, location ) {
    // TODO: also use for includeMembers()?
    for (const name in elements) {
      const origin = elements[name];
      const proxy = linkToOrigin( origin, name, null, null, location || origin.location );
      proxy.$inferred = inferred;
      if (origin.masked)
        proxy.masked = Object.assign( { $inferred: 'include' }, origin.masked );
      if (origin.key)
        proxy.key = Object.assign( { $inferred: 'include' }, origin.key );
      if (ignore)
        addBoolAnnotationTo('@cds.odata.v4.ignore', true, proxy);
      addToDictWithIndexNo( proxyDict, 'elements', name, proxy );
    }
  }

  function tagCompositionTargets( elem ) {
    const type = elem.type && elem.type.path;
    if (elem.target && type && type[0] && type[0].id === 'cds.Composition') {
      // Compostion always via [{id:'cds.Composition'}] in both CSN and CDL
      const target = resolvePath( elem.target, 'target', elem );
      if (target)
        model.$compositionTargets[target.name.absolute] = true;
    }
    forEachGeneric( elem, 'elements', tagCompositionTargets );
  }

  // Collect all artifact extensions
  function collectArtifactExtensions( construct, block ) {
    for (const ext of construct.extensions || []) {
      setProp( ext, '_block', block );
      // complain about non-existent path base, but do not check complete path:
      // normal ref in outer extend, relative ref inside EXTEND CONTEXT
      const name = resolveUncheckedPath( ext.name, ext.kind, ext );
      // TODO: somehow provide expectedKind as filter?
      if (name) {
        pushToDict( extensionsDict, name, ext );
        // an extend with main artifact extension is a block
        collectArtifactExtensions( ext, ext );
      }
    }
  }

  function lateExtensions( veryLate ) {
    for (const name in model.$lateExtensions) {
      let art = model.definitions[name];
      const exts = model.$lateExtensions[name];
      if (art) {                // created texts entity, autoexposed entity
        if (exts) {
          // console.log(message( null, art.location, art, {}, 'Info', 'FT').toString())
          extendArtifact( exts, art, 'gen' );
          if (veryLate)
            veryLate( art );
          model.$lateExtensions[name] = null; // done
        }
      }
      else if (veryLate) {
        // Complain about unused extensions, i.e. those
        // which do not point to a valid artifact
        for (const ext of exts) {
          delete ext.name.path[0]._artifact;      // get message for root
          resolvePath( ext.name, ext.kind, ext ); // should issue error/info
          if (ext.kind === 'annotate')
            delete ext.name._artifact; // make it be considered by extendArtifact()
        }
        // create "super" ANNOTATE containing all non-applied ones
        const first = exts[0];
        const { location } = first.name;
        art = {
          kind: 'annotate',
          name: { path: [ { id: name, location } ], absolute: name, location },
          location: first.location,
        };
        if (model.extensions)
          model.extensions.push(art);
        else
          model.extensions = [ art ];
        extendArtifact( exts, art ); // also sets _artifact link in extensions
      }
    }
  }

  // phase 1: context extends, 2: extends with structure includes, 3: extends
  // without structure includes (in the case of cyclic includes)
  //
  // Before phase 1: all artifact extensions have been collected (even those
  // inside extend context), only "empty" ones from structure includes are still unknown.
  // After phase 1, all main artifacts are known, also "empty" extensions are known.
  function applyExtensions() {
    let phase = 1;
    let extNames = Object.keys( extensionsDict ).sort();
    // Remark: The sort() makes sure that an extend for artifact C.E is applied
    // after the extend for C has been applied (which could have defined C.E).
    // Looping over model.definitions in Phase 1 would miss the `extend
    // context` for a context C.C defined in an `extend context C`.
    while (extNames.length) {
      const { length } = extNames;
      for (const name of extNames) {
        const art = model.definitions[name];
        if (!art) {
          model.$lateExtensions[name] = extensionsDict[name];
          delete extensionsDict[name];
        }
        else if (art instanceof Array) { // cannot extend redefinitions
          delete extensionsDict[name];
        }
        else if (phase === 1
                 ? extendContext( name, art )
                 : extendArtifact( extensionsDict[name], art, phase > 2 )) {
          delete extensionsDict[name];
        }
      }
      extNames = Object.keys( extensionsDict ); // no sort() required anymore
      if (phase === 1)
        phase = 2;
      else if (extNames.length >= length)
        phase = 3;
    }
  }

  function extendContext( name, art ) {
    // (ext.expectedKind == art.kind) already checked by parser (TODO: modulo context/service)
    if (!kindProperties[art.kind].artifacts) // no context or service
      return false;

    for (const ext of extensionsDict[name]) {
      setProp( ext.name, '_artifact', art );
      if (ext.artifacts) {    // extend context with artifacts
        ext.name.query = art.blocks.length;
        art.blocks.push( ext ); // extend context is block of context
      }
      checkDefinitions( ext, art, 'elements'); // error for elements etc
      checkDefinitions( ext, art, 'enum');
      checkDefinitions( ext, art, 'actions');
      checkDefinitions( ext, art, 'params');
      defineAnnotations( ext, art, ext._block, ext.kind );
      initArtifacts( ext, art, ext );
    }
    return true;
  }

  function serviceIncludes( art ) {
    // Actually, the whole code doing extensions needs to be reworked with
    // service includes - having an extra sub phase in applyExtensions()?
    if (art.includes) {         // service includes - just resolve them now
      message( null, dictLocation( art.includes ), art,
               'Service includes are not supported yet' );
      for (const ref of art.includes)
        resolvePath( ref, 'context', art );
    }
    // let absolute = art.name.absolute;
    // if (art.includes && !(absolute in extensionsDict))
    //   extensionsDict[absolute] = []; // structure with includes must be "extended"
  }

  // Extend artifact `art` by `extensions`.  `noIncludes` can have values:
  // - false: includes are applied, extend and annotate is performed
  // - true:  includes are not applied, extend and annotate is performed
  // - 'gen': no includes and no extensions allowed, annotate is performed
  function extendArtifact( extensions, art, noIncludes ) {
    if (!noIncludes && !(canApplyIncludes( art ) && extensions.every( canApplyIncludes )))
      return false;
    if (!art.query) {
      model._entities.push( art ); // add structure with includes in dep order
      art.$entity = ++model.$entity;
    }
    if (!noIncludes && art.includes)
      applyIncludes( art, art );
    extendMembers( extensions, art, noIncludes === 'gen' );
    if (!noIncludes && art.includes && setAutoExposed( art )) { // need to inherit @cds.autoexpose
      for (const ref of art.includes) {
        const template = ref._artifact;
        if (template) {
          setAutoExposed( template );
          if (typeof template.$autoexpose === 'boolean')
            art.$autoexpose = template.$autoexpose;
        }
      }
    }
    // TODO: complain about element extensions inside projection
    return true;
  }

  function canApplyIncludes( art ) {
    if (art.includes) {
      for (const ref of art.includes) {
        const template = resolvePath( ref, 'include', art );
        if (template && template.name.absolute in extensionsDict)
          return false;
      }
    }
    return true;
  }

  function extendMembers( extensions, art, noExtend ) {
    const elemExtensions = [];
    if (!art._deps)
      setProp( art, '_deps', [] );
    extensions.sort( compareLayer );
    for (const ext of extensions) {
      // console.log(message( null, ext.location, ext, { art: ext.name._artifact },
      //                      'Info', 'EXT').toString())
      if (!('_artifact' in ext.name)) { // not already applied
        setProp( ext.name, '_artifact', art );
        if (noExtend && ext.kind === 'extend') {
          message( 'extend-for-generated', ext.name.location, ext, { art },
                   'Error', 'You cannot use EXTEND on the generated $(ART)' );
          continue;
        }
        if (ext.includes) {
          // TODO: currently, re-compiling from gensrc does not give the exact
          // element sequence - we need something like
          //    includes = ['Base1',3,'Base2']
          // where 3 means adding the next 3 elements before applying include 'Base2'
          if (art.includes)
            art.includes.push(...ext.includes);
          else
            art.includes = [ ...ext.includes ];
          applyIncludes( ext, art );
        }
        defineAnnotations( ext, art, ext._block, ext.kind );
        // TODO: do we allow to add elements with array of {...}?  If yes, adapt
        initMembers( ext, art, ext._block ); // might set _extend, _annotate
        art._deps.push( { art: ext } );     // art depends silently on ext (inverse to normal dep!)
      }
      for (const name in ext.elements) {
        const elem = ext.elements[name];
        if (elem.kind === 'element') { // i.e. not extend or annotate
          elemExtensions.push( elem );
          break;
        }
      }

      if (ext.columns)          // extend projection
        extendColumns( ext, art );
    }
    if (elemExtensions.length > 1)
      reportUnstableExtensions( elemExtensions );

    [ 'elements', 'actions' ].forEach( (prop) => {
      const dict = art._extend && art._extend[prop];
      for (const name in dict) {
        const member = (art[prop] || prop === 'elements' && art.enum)[name];
        if (!member)
          extendNothing( dict[name], prop, name, art );
        else if (!(member instanceof Array))
          extendMembers( dict[name], member );
      }
    });
  }

  // Copy columns for EXTEND PROJECTION
  function extendColumns( ext, art ) {
    // TODO: consider reportUnstableExtensions
    const { location } = ext;
    const { query } = art;
    if (!query) {
      if (art.kind !== 'annotate') {
        message( 'extend-columns', location, ext, { art }, 'Error',
                 'Artifact $(ART) cannot be extended with columns, only projections can' );
      }
      return;
    }
    if (!query.from || query.from.length !== 1 || !query.from[0].path) {
      message( 'extend-columns', location, ext, { art }, 'Error',
               'Artifact $(ART) cannot be extended with columns, only projections can' );
    }
    else {
      if (!query.columns)
        query.columns = [ { location, val: '*' } ];

      for (const column of ext.columns) {
        setProp( column, '_block', ext._block );
        query.columns.push(column);
      }
    }
  }

  function reportUnstableExtensions( extensions ) {
    // Report 'Warning: Unstable element order due to repeated extensions'.
    // Similar to chooseAssignment(), TODO there: also extra intralater message
    // as this is a modeling error
    let lastExt = null;
    let open = [];              // the "highest" layers
    for (const ext of extensions) {
      const extLayer = layer( ext ) || { realname: '', _layerExtends: Object.create(null) };
      if (!open.length) {
        lastExt = ext;
        open = [ extLayer.realname ];
      }
      else if (extLayer.realname === open[open.length - 1]) { // in same layer
        if (lastExt) {
          message( 'extend-repeated-intralayer', lastExt.location, lastExt, {}, 'Warning',
                   'Unstable element order due to repeated extensions in same layer' );
          lastExt = null;
        }
        message( 'extend-repeated-intralayer', ext.location, ext, {}, 'Warning',
                 'Unstable element order due to repeated extensions in same layer' );
      }
      else {
        if (lastExt && (open.length > 1 || !extLayer._layerExtends[open[0]])) {
          // report for lastExt if that is unrelated to other open exts or current ext
          message( 'extend-unrelated-layer', lastExt.location, lastExt, {}, 'Warning',
                   'Unstable element order due to other extension in unrelated layer' );
        }
        lastExt = ext;
        open = open.filter( name => !extLayer._layerExtends[name] );
        open.push( extLayer.realname );
      }
    }
  }

  function extendNothing( extensions, prop, name, art ) {
    for (const ext of extensions) {
      message( 'extend-undefined', ext.name.location, ext,
               { art: searchName( art, name, dictKinds[prop] ) },
               'Error', {
                 std: 'Unknown $(ART) - nothing to extend',
                 element: 'Artifact $(ART) has no element or enum $(MEMBER) - nothing to extend',
                 action: 'Artifact $(ART) has no action $(MEMBER) - nothing to extend',
               } );
    }
  }

  function applyIncludes( ext, art ) {
    if (!art._ancestors)
      setProp( art, '_ancestors', [] ); // recursive array of includes
    for (const ref of ext.includes) {
      const template = ref._artifact; // already resolved
      if (template) {
        if (template._ancestors)
          art._ancestors.push( ...template._ancestors );
        art._ancestors.push( template );
      }
    }
    includeMembers( ext, 'elements', forEachInOrder, ext === art && art );
    includeMembers( ext, 'actions', forEachGeneric, ext === art && art );
  }

  function includeMembers( ext, prop, forEach, parent ) {
    // TODO two kind of messages:
    // Error 'More than one include defines element "A"' (at include ref)
    // Warning 'Overwrites definition from include "I" (at elem def)
    const members = ext[prop];
    clearDict( ext, prop );     // TODO: do not set actions property if there are none
    for (const ref of ext.includes) {
      const template = ref._artifact; // already resolved
      if (template) {           // be robust
        forEach( template, prop, ( origin, name ) => {
          if (members && name in members)
            return;               // TODO: warning for overwritten element
          const elem = linkToOrigin( origin, name, parent, prop, weakLocation( ref.location ) );
          if (!parent)          // not yet set for EXTEND foo WITH bar
            addToDictWithIndexNo( ext, prop, name, elem );
          elem.$inferred = 'include';
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'include' }, origin.masked );
          if (origin.key)
            elem.key = Object.assign( { $inferred: 'include' }, origin.key );
          // TODO: also complain if elem is just defined in art
        });
      }
    }
    // TODO: expand elements having direct elements (if needed)
    if (members) {
      forEach( { [prop]: members }, prop, ( elem, name ) => {
        addToDictWithIndexNo( ext, prop, name, elem );
      });
    }
  }

  function processArtifact( name ) {
    const art = model.definitions[name];
    if (art instanceof Array) {
      art.forEach( a => checkRedefinitions( a, name, 'definitions', true ) );
    }
    else {
      checkRedefinitions( art, name, 'definitions' );
      processCompositionOfType( art );
      if (art.kind === 'entity' && !art.query && art.elements && // check potential entity parse error
          (!art.abstract || !art.abstract.val))
        processLocalizedData( art );
    }
  }

  function processLocalizedData( art ) {
    const textsName = `${ art.name.absolute }_texts`;
    const textsEntity = model.definitions[textsName];
    const localized = localizedData( art, textsEntity );
    if (!localized)
      return;
    // Without errors localization views can always be create as ones
    // in the source are ignored
    if (!hasErrors( model.messages || options.messages ))
      createLocalizedDataView( art, `localized.${ art.name.absolute }`, localized );
    if (textsEntity)            // expanded localized data in source
      return;                   // -> make it idempotent
    createTextsEntity( art, textsName, localized );
    addTextsAssociations( art, textsName, localized );
  }

  function localizedData( art, textsEntity ) {
    let keys = 0;
    const textElems = [];
    const protectedElems = [];

    for (const name in art.elements) {
      const elem = art.elements[name];
      if (elem instanceof Array)
        return false;           // no localized-data unfold with redefined elems
      if ([ 'locale', 'texts', 'localized' ].includes( name ))
        protectedElems.push( elem );

      if (elem.key && elem.key.val) { // key with localized is wrong - ignore localized
        keys += 1;
        textElems.push( elem );
      }
      else if (hasTruthyProp( elem, 'localized' )) {
        textElems.push( elem );
      }
    }
    if (textElems.length <= keys)
      return false;

    if (!keys) {
      message( null, art.name.location, art, {}, 'Warning',
               'No texts entity can be created when no key element exists' );
      return false;
    }

    if (textsEntity) {
      if (textsEntity instanceof Array)
        return false;
      if (textsEntity.kind !== 'entity' || textsEntity.query ||
          // already have elements "texts" and "localized"
          protectedElems.length !== 2 || art.elements.locale) {
        // TODO if we have too much time: check all elements of texts entity for safety
        message( null, art.name.location, art, { art: textsEntity }, 'Warning',
                 'Texts entity $(ART) cannot be created as there is another definition with that name' );
        message( null, textsEntity.name.location, textsEntity, { art }, 'Info',
                 'Texts entity for $(ART) cannot be created with this definition' );
      }
      else if (!art._block || art._block.$frontend !== 'json') {
        message( null, art.name.location, art, {}, 'Info',
                 'Localized data expansions has already been done' );
        return textElems;       // make double-compilation even with after toHana
      }
      else if (!art._block.$withLocalized) {
        art._block.$withLocalized = true;
        message( null, art.name.location, null, {}, 'Info',
                 'Input CSN contains expansions for localized data' );
        return textElems;       // make compilation idempotent
      }
      else {
        return textElems;
      }
    }
    for (const elem of protectedElems) {
      message( null, elem.name.location, art, { name: elem.name.id }, 'Warning',
               'No texts entity can be created when element $(NAME) exists' );
    }
    return !textsEntity && !protectedElems.length && textElems;
  }

  // TODO: set _parent also for main artifacts!
  function createTextsEntity( base, absolute, textElems ) {
    const elements = Object.create(null);
    const { location } = base.name;
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, absolute ), location },
      location: base.location,
      elements,
      '@cds.autoexpose': { name: augmentPath( location, '@cds.autoexpose' ), location },
      $inferred: 'localized',
    };

    // Remove in combination with containment OData V4
    if (!options.betaMode)
      addBoolAnnotationTo('@odata.draft.enabled', false, art);

    const locale = {
      name: { location, id: 'locale' },
      kind: 'element',
      key: { val: true, location },
      type: augmentPath( location, 'cds.String' ),
      length: { literal: 'number', val: 5, location },
      location,
    };
    addToDictWithIndexNo( art, 'elements', 'locale', locale );
    const artifacts = Object.create(null);
    artifacts[absolute] = art;
    initArtifacts( { artifacts }, null, model.$internal, false, '' );

    for (const orig of textElems) {
      const elem = linkToOrigin( orig, orig.name.id, art, 'elements' );
      if (orig.key && orig.key.val) {
        elem.key = { val: true, $inferred: 'localized', location };
        addBoolAnnotationTo('@cds.odata.v4.ignore', true, elem);
      }
      else {                    // use location of LOCALIZED keyword
        const localized = orig.localized || orig.type || orig.name;
        elem.localized = { val: false, $inferred: 'localized', location: localized.location };
      }
    }
  }

  function addTextsAssociations( art, textsName, textElems ) {
    // texts : Composition of many Books_texts on texts.ID=ID;
    const keys = textElems.filter( e => e.key && e.key.val );
    const { location } = art.name;
    const texts = {
      name: { location, id: 'texts' },
      kind: 'element',
      location,
      $inferred: 'localized-texts',
      type: augmentPath( location, 'cds.Composition' ),
      cardinality: { targetMax: { literal: 'string', val: '*', location }, location },
      target: augmentPath( location, textsName ),
      onCond: augmentEqual( location, 'texts', keys ),
    };
    setMemberParent( texts, 'texts', art, 'elements' );
    setProp( texts, '_block', model.$internal );
    // localized : Association to Books_texts on
    //             localized.ID=ID and localized.locale = $user.locale;
    keys.push( [ 'localized.locale', '$user.locale' ] );
    const localized = {
      name: { location, id: 'localized' },
      kind: 'element',
      location,
      $inferred: 'localized-texts',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, textsName ),
      onCond: augmentEqual( location, 'localized', keys ),
    };
    setMemberParent( localized, 'localized', art, 'elements' );
    setProp( localized, '_block', model.$internal );
  }

  // Create the localization view named `absolute` for the non-query
  // entity `base` having the localized elements `textElems` (array also
  // includes keys, which should be ignored for this function).
  function createLocalizedDataView( base, absolute, textElems ) {
    const { location } = base.name;
    const columns = [ { location, val: '*' } ];
    const from = augmentPath( location, base.name.absolute );
    from.name = { id: 'L', location };
    const view = {
      kind: 'entity',
      name: { location, path: splitIntoPath( location, absolute ) },
      location: base.location,
      '@odata.draft.enabled': booleanAnnotation( location, 'odata.draft.enabled', false ),
      query: {
        location,
        op: { val: 'query', location },
        from: [ from ],
        columns,
      },
      $inferred: 'LOCALIZED-HORIZONTAL',
    };
    for (const orig of textElems || []) {
      if (!orig.key || !orig.key.val) {
        const loc = orig.name.location;
        const { id } = orig.name;
        const value = {           // TODO: special to allow different code in HANA?
          op: { location: loc, val: 'call' },
          func: augmentPath( loc, 'coalesce' ),
          args: [
            augmentPath( loc, 'L', 'localized', id ),
            augmentPath( loc, 'L', id ),
          ],
          location: loc,
        };
        setProp( value, '_artifact', orig );
        const origin = {};
        setProp( origin, '_artifact', orig );
        // TODO: stay automatically silent if "shadowed" source element appears in expression
        columns.push( {
          name: { id, location },
          location: orig.location,
          value,
          origin,
          $replacement: 'silent',
        } );
      }
    }
    const artifacts = Object.create(null);
    artifacts[absolute] = view;
    // TODO: support for name.space::Base ?
    initArtifacts( { artifacts }, null, model.$internal, false, '' );
    // TODO: add to some cache?
    setLink( base, view, '_localized' );
    setLink( view, true, '_localized' );
    return view;
  }

  function hasTruthyProp( art, prop ) {
    // Returns whether art directly or indirectly has the property 'prop',
    // following the 'origin' and the 'type' (not involving elements).
    //
    // TODO: we should issue a warning if we get localized via TYPE OF
    // TODO XSN: for anno short form, use { val: true, location, <no literal prop> }
    // ...then this function also works with annotations
    const processed = Object.create(null); // avoid infloops with circular refs
    let name = art.name.absolute;        // is ok, since no recursive type possible
    while (art && !processed[name]) {
      if (art[prop])
        return art[prop].val;
      processed[name] = art;
      if (art.origin && art.origin._artifact) {
        art = art.origin._artifact;
        name = art && art.name.absolute;
      }
      else if (art.type && art._block && art.type.scope !== 'typeOf') {
        // TODO: also do something special for TYPE OF inside `art`s own elements
        name = resolveUncheckedPath( art.type, 'type', art );
        art = name && model.definitions[name];
      }
      else {
        return false;
      }
    }
    return false;
  }
}

// Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
// locations):
function pathName(path) {
  return path.map( id => id.id ).join('.');
}

function splitIntoPath( location, name ) {
  // TODO: is currently needed to add the artifact into parent
  // TODO: make it also work with path = [{id:absolute}]
  const colons = name.indexOf('::');
  const items = (colons < 0) ? name.split('.') : name.substring(colons).split('.');
  return items.map( id => ({ id, location }) );
}

function augmentPath( location, ...args ) {
  return { path: args.map( id => ({ id, location }) ), location };
}

function augmentEqual( location, prefix, relations ) {
  const args = relations.map( eq );
  return (args.length === 1)
    ? args[0]
    : { op: { val: 'and', location }, args, location };

  function eq( refs ) {
    if (refs instanceof Array)
      return { op: { val: '=', location }, args: refs.map( ref ), location };

    const { id } = refs.name;
    return {
      op: { val: '=', location },
      args: [
        { path: [ { id: prefix, location }, { id, location } ], location },
        { path: [ { id, location } ], location },
      ],
      location,
    };
  }
  function ref( path ) {
    return { path: path.split('.').map( id => ({ id, location }) ), location };
  }
}

function booleanAnnotation( location, id, val ) {
  return {
    name: { path: [ { id, location } ], location },
    val,
    literal: 'boolean',
    location,
  };
}

module.exports = {
  define: model => getDefinerFunctions( model ).define(),
  getDefinerFunctions,
  augmentPath,
  splitIntoPath,
  booleanAnnotation,
};
