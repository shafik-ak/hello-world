// Implementation of alerts
//
// An alert is a message of a certain severity (Error, Warning, Info). The alerts are implemented
// by tagged template literals, e.g. error`File not found` is an alert of severity 'Error',
// warning`Cannot read ${file}` an alert of severity 'Warning'.
// The severity of every message may be changed in a global JSON document, which has each message as a key
// and defines additional properties (e.g. localized texts for different languages). One such property is
// the severity. If the message is in the document and has a severity, it supersedes the original severity.
// In order to remove a severity (so that further stages processing the alert can completely ignore it)
// severity must be set to null.
// Alerts must be handled by function signal(), which inserts it into 'model.messages' together with a location,
// if provided.
// Hint: To collect tagged template literals that correspond to known alerts in the sources, use scripts/extractAlerts.js

'use strict';

// Get the current language from the process environment in order to get the right translation text.
// Since this is global for the process we do it only once. In a web development environment you will be more
// interested in the browser language so you will have to evaluate something like:
// var userLang = navigator.language || navigator.userLanguage;

var locale = process.env.LANG || '';
var language = locale.match(/[a-z]+/);

// load predefined alerts
var alertMsgs = require('../alerts.json');

// Return an object with functions for alert handling on 'model'
// {
//   info                               // tag function for INFO messages
//   warning                            // tag function for WARN messages
//   error                              // tag function for ERROR messages
//   signal(taggedString, loc)          // signal an info, error, or warning message 'taggedString' at location 'loc'
// }
// For obtaining these functions, 'alerts(model)' should be called once, linking the reporting to 'model.messages'.
// Alerts should be signalled with an invocation like this, to ensure that error texts can be translated:
//   signal(error`Example error ${foo}`, location);
//
function alerts(model, options = model.options || {}) {
  // If 'model' does not have a 'messages' array yet (may happen for plain CSNs), create one
  let collected = options.messages || model.messages ||
                  Object.defineProperty( model, 'messages',
                                         { value: [], configurable: true, writable: true } )
                    .messages;

  signal.error = error;
  signal.warning = warning;
  signal.ino = info;
  return {
    info, warning, error,               // tag functions for the different alerts
    signal                              // add the alert to the message list and react depending on severity
  };

  function info(msgParts, ...values) {
    return createAlert('Info', msgParts, values);
  }

  function warning(msgParts, ...values) {
    return createAlert('Warning', msgParts, values);
  }

  function error(msgParts, ...values) {
    return createAlert('Error', msgParts, values);
  }

  // Mother of all alerts. Check if the message is in the global JSON document, take (translated) text and possibly
  // new severity from there. Substitute parameters by corresponding values. If neither translation is provided
  // nor the alert is known at all, just take the key as the message.
  function createAlert(severity, msgParts, values) {
    // Combine the 'msgParts' to get the key into the global 'alertMsgs'
    let key = '';
    msgParts.forEach((part, i) => {
      key += part;
      if (i < values.length)
        key += `{${i}}`;
    })
    // Get the alert from 'alertMsgs', the translation text corresponding to the language, if provided, and the severity
    let alert = alertMsgs[key] || { severity };
    let translation = alert.translation || {};
    let msg = translation[language] || key;
    // Replace the parameters by the corresponding values
    let result = new String(msg.replace(/{(\d)}/g, (_, index) => values[Number(index)]));
    if (alert.severity === null || typeof alert.severity === 'string')
      // in simple cases (no complex object) just use this severity
      result._severity = alert.severity;
    else if (alert.severity === undefined)
      result._severity = severity;
    else
      // check if a default severity exists, else keep the original
      // FIXME: Remove this as well
      result._severity = alert.severity.default === undefined ? severity : alert.severity.default;
    return result;
  }

  /**
   * Link an alert to a location (if provided). If no explicit severity is given, the severity is taken
   * from the 'msg' itself (if provided). The alert is added to the list of alerts. If the alert is an
   * exception, the corresponding error is thrown.
   * 
   * @param {any} msg Message text
   * @param {any} location Location information
   * @param {any} severity severity: Info, Warning, Error
   * @param {string} [message_id=''] Message ID
   * @param {any} context Further context information
   * @returns {Boolean} true, if no 'Error' alert was handled.
   */
  function signal(msg, location, severity, message_id='', context) {
    var err = messageBuilder(model, msg, location, severity, message_id, context);
    if (err.severity)
      // don't collect stuff that doesn't have a severity
      collected.push(err);
    switch (err.severity) {
      case 'Exception':
        throw err;
      case 'Error':
        return false;
      default:
        return true;
    }
  }
}

const messageBuilder = require('./message-builder');

module.exports = alerts;
