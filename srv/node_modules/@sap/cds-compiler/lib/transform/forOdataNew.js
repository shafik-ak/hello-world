'use strict';

const alerts = require('../base/alerts');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { setProp } = require('../base/model');
const transformUtils = require('./transformUtilsNew');
const { mergeOptions, copyAnnotations, getElementDatabaseNameOf } = require('../model/modelUtils');
const { getUtils, cloneCsn, forEachDefinition, forEachMemberRecursively } = require('../model/csnUtils');
const { isNewCSN } = require('../json/csnVersion');

// Transformation for ODATA. Expects a CSN 'inputModel', processes it for ODATA.
// The twin of forOdata.js
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
//
//   (0) Semantic checks before flattening regarding temporal data
//   (1.1) Flatten structured elements (and foreign keys of managed associations pointing to
//       keys that are themselves managed associations).
//       TODO: probably only for OData V2?
//   (1.2) Expose (named or anonymous) structured types used in structured types
//   (1.3) Unravel derived types for elements, actions, action parameters, types and
//       annotations (propagating annotations)
//   (1.4) Mark fields with @odata.on.insert/update as @Core.Computed
//   (1.5) Rename shorthand annotations according to a builtin list.
//       e.g. @label -> @Common.Label or @important: [true|false] -> @UI.Importance: [#High|#Low]
//   (1.6) Check annotations. If annotation starts with '@sap...' it must have a string or boolean value
//  Transformations (1.1), (1.2), (1.3), (1.4), (1.5) and (1.6) are executed during the first walk through the model
//
//   (2.1) For exposed actions and functions that use non-exposed or anonymous structured types,
//       create artificial exposing types
//  Transformation (2.1) is a second walk through the definitions
//
//   (3.1) Generate foreign key fields for managed associations, depends on (1.1) in V4 or flatten case
//   (3.2) Flatten on-conditions in unmanaged associations
//   (3.3) Check that each service has max one draft root
//  Step (3.1) is in the third walk of the model
//
//   (4.1) Generate artificial draft fields if requested
//   (4.3) Check associations for:
//        - exposed associations do not point to non-exposed targets
//        - structured types must not contain associations for OData V2
//   (4.4) Element must not be an 'array of' for OData V2
//   (4.5) If the association target is annotated with @cds.odata.valuelist, annotate the
//        association with @Common.ValueList.viaAssociation
//   (4.6) Check for @Analytics.Measure and @Aggregation.default
//  Fourth loop: (4.1) to (4.6)
//
//   (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
//   (5.2) Perform checks for exposed non-abstract entities and views - check media type and
//        key-ness (requires that containers have been identified in the fourth pass (4.2))
//  Fifth walk through the model with (5.1) and (5.2)

module.exports = { transform4odataWithCsn, getServiceNames };

function transform4odataWithCsn(inputModel, options) {
  // copy the model as we don't want to change the input model
  // TODO: set protos to null here -> call the function from lib/json/nullprotos3.js
  let csn = cloneCsn(inputModel);

  const { error, warning, info, signal } = alerts(csn);

  // the new transformer works only with new CSN
  if (!isNewCSN(inputModel, options)) {
    signal(error`OData transformer does not support the provided CSN version.`);
    throw new CompilationError(csn.messages, csn);
  }

  options = mergeOptions(inputModel.options, options);
  setProp(csn, 'options', options);

  const {
    flattenForeignKeys, createForeignKeyElement,
    flattenStructuredElement,
    flattenOnCond,
    checkExposedAssoc, toFinalBaseType,
    createAndAddDraftAdminDataProjection, createScalarElement,
    createAssociationElement, createAssociationPathComparison,
    addElement, createAction,
    addAction, copyAndAddElement,
    checkForeignKeys, extractValidFromToKeyElement,
    checkAssignment, checkMultipleAssignments,
    recurseElements,
  } = transformUtils.getTransformers(csn, '_');

  const {
    getArtifactDatabaseNameOf,
    getCsnDef,
    getFinalBaseType,
    getFinalType,
    getFinalTypeDef,
    getNamespaceOfArtifact,
    getServiceName,
    hasBoolAnnotation,
    isAssocOrComposition,
    isAssociation,
    isManagedAssociationElement,
    isStructured,
  } = getUtils(csn);

  // are we working with structured OData or not
  const structuredOData = options.toOdata.odataFormat === 'structured' && options.toOdata.version === 'v4';

  // exposed struct types (see function exposeStructType)
  // They have to be memorized to know if a given type is exposed or if there is a name clash
  let exposedStructTypes = {};

  // collect all declared non-abstract services from the model
  // use the array when there is a need to identify if an artifact is in a service or not
  let services = getServiceNames(csn);

  // (0) Semantic checks before flattening regarding temporal data
  forEachDefinition(csn, (artifact, artifactName, propertyName, path) => {
    // Gather all element names with @cds.valid.from/to/key
    let validFrom = [], validTo = [], validKey = [];
    recurseElements(artifact, ['definitions', artifactName], (member, path) => {
      let [f, t, k] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);
    });
    // Check that @cds.valid.from/to/key is only in valid places
    validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact, artifactName));
    validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
    validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
    checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
    checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName);
    checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    if (validKey.length && !(validFrom.length && validTo.length)) {
      signal(error`@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing`, path);
    }
  });

  // (1.1) Unravel derived type chains to final one for elements, actions, action parameters (propagating annotations)
  forEachDefinition(csn, (def, defName) => {
    forEachMemberRecursively(def, (member) => {
      if (!member.elements && !member.items) // structured does not have final base type and arrays are covered on the next line
        toFinalBaseType(member);
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      toFinalBaseType(member.returns && member.returns.items);
    }, ['definitions', defName]);
  });

  // (1.1) Unravel derived type chains for types and annotations (propagating annotations)
  forEachDefinition(csn, (def) => {
    if (def.kind != 'entity') {
      if (!isStructured(getFinalTypeDef(def)))
        toFinalBaseType(def);
      toFinalBaseType(def.items);
      toFinalBaseType(def.returns);
      toFinalBaseType(def.returns && def.returns.items);
    }
    // If the definition('def' variable) is a type definition and the assigned type of this very same definition('def' variable)
    // is structured type, e.g.:
    //
    // type Struct1 {
    //    a : Integer;
    //    b : Integer;
    //  };
    // type Struct2: Struct1;
    // after compilation the csn looks like this:
    // ...
    // "S.Struct1": {
    //   "kind": "type",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } },
    // "S.Struct2": {
    //   "kind": "type",
    //   "type": "S.Struct1",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } } ...
    //
    // "S.Struct2" should looks just like "S.Struct1" => the "type": "S.Struct1" property has to be removed    
    if (def.kind === 'type' && def.type && isStructured(getFinalBaseType(def)) && !def.type.ref) {
      // elements are already there -> do not show the type
      delete def.type;
    }
  });

  // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
  // (1.3) Resolve annotation shorthands,
  // (1.4) Check @cds... annotations
  // (1.5) Flatten structs
  // (1.6) Expose (named or anonymous) structured types used in structured types
  // TODO: only for V2 or via special option???
  forEachDefinition(csn, (def, defName, propertyName, path) => {

    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);

      // (1.3) Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);

      // (1.4) check annotations
      checkAnnotations(member, path);
    }, ['definitions', defName]);

    // (1.5) Flatten structs - for entities and views only (might result in new elements)
    if (def.kind === 'entity' || def.kind === 'view') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        if (isStructured(elem, csn) || (elem.type && getFinalTypeDef(elem.type, csn).elements)) {
          if (structuredOData) {
            if (!isArtifactInSomeService(defName, services)) return;
            exposeStructTypeOf(elem, getServiceName(defName), `__${defName.replace(/\./g, '_')}_${elemName}`, elemName);
          } else {
            // Remove the structured element, replace it by its flattened form
            delete def.elements[elemName];
            let flatElems = flattenStructuredElement(elem, elemName);
            for (let flatElemName in flatElems) {
              if (def.elements[flatElemName]) {
                signal(error`"${defName}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, path.concat(['elements', flatElemName]));
              }
              def.elements[flatElemName] = flatElems[flatElemName];
            }
          }
        }
        if (getServiceName(defName) && !elem.type && !elem.items && !elem.elements) {
          signal(error`Element "${defName}.${elemName}" does not have a type: Elements of ODATA entities must have a type`, path.concat(['elements', elemName]));
        }
      }
    }
    // (1.6) Expose (named or anonymous) structured types used in structured types
    else if (isArtifactInSomeService(defName, services) && def.kind === 'type') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Expose structured types used in exposed structured types
        exposeStructTypeOf(elem, getServiceOfArtifact(defName, services), `__${defName.replace(/\./g, '_')}_${elemName}`, `${defName}.${elemName}`);
      }
    }

    // (1.5) Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(def);
    // (1.6) check annotations
    checkAnnotations(def, ['definitions', defName]);
  });

  // Second walk: Only through definitions
  // (2.1) For exposed actions and functions that use non-exposed or anonymous structured types, create
  // artificial exposing types
  forEachDefinition(csn, (def, defName) => {
    let service = getServiceOfArtifact(defName, services);
    if (service) {
      if (def.kind == 'action' || def.kind == 'function') {
        exposeStructTypesForAction(def, defName, service);
      }

      for (let actionName in def.actions || {}) {
        exposeStructTypesForAction(def.actions[actionName], `${defName}_${actionName}`, service);
      }
    }
  });

  // Third walk: Process associations
  // (3.1) Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed)
  // (3.2) Flatten on-conditions in unmanaged associations
  // (3.3) Check that each service has max one draft root
  // This must be done before 4.1, since all composition targets are annotated with @odata.draft.enabled in this step
  let flattenedKeyArts = Object.create(null);
  forEachDefinition(csn, (def, defName) => {
    flattenForeignKeysForArt(def, defName, flattenedKeyArts);
    if (isArtifactInSomeService(defName, services) && ['entity', 'view'].includes(def.kind) && def['@odata.draft.enabled']) {
      let serviceName = getServiceOfArtifact(defName, services);
      let service = getCsnDef(serviceName);
      if (service.$draftCount)
        service.$draftCount++;
      else
        setProp(service, '$draftCount', 1);
      if (service.$draftCount > 1)
        signal(info`Service "${serviceName}" should not have more then one draft root artifact`, ['definitions', defName]);
    }
  });

  // Fourth walk through the model: Now all artificially generated things are in place
  // (4.1) Generate artificial draft fields if requested
  // TODO: should be done by the compiler - Check associations for valid foreign keys
  // TODO: checkif needed at all: Remove '$projection' from paths in the element's ON-condition
  // (4.2) Check associations for:
  //        - exposed associations do not point to non-exposed targets
  //        - structured types must not contain associations for OData V2
  // (4.3) Element must not be an 'array of' for OData V2
  // (4.4) If the association target is annotated with @cds.odata.valuelist, annotate the
  //      association with @Common.ValueList.viaAssociation
  // (4.5) Check for @Analytics.Measure and @Aggregation.default
  let visitedArtifacts = {};
  forEachDefinition(csn, (def, defName) => {
    if (def.kind == 'entity' || def.kind == 'view') {
      // (4.1) Generate artificial draft fields if requested
      if (def['@odata.draft.enabled']) {
        // Ignore if not part of a service
        if (!isArtifactInSomeService(defName, services)) {
          signal(warning`Ignoring annotation "@odata.draft.enabled" - artifact "${defName}" is not part of a service`, ['definitions', defName]);
        }
        else {
          generateDraftForOdata(def, defName, def, visitedArtifacts);
        }
      }

      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Check for valid foreign keys
        if (isAssocOrComposition(elem.type)) {
          checkForeignKeys(elem, elemName, defName);
        }

        // // Remove '$projection' from paths in the element's ON-condition
        // // FIXME: Hack - should actually be done by the compiler, and should only
        // // affect the element itself, not the various other places sharing the same
        // // ON-condition object, e.g. the MIXIN and the query (there, the ON-condition
        // // should actually retain its '$projection').
        // foreachPath(elem.onCond || {}, (path, node) => {
        //   if (path[0].id == '$projection') {
        //     node.path = node.path.slice(1.1);
        //   }
        // });
      }
    }
    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      if (isArtifactInSomeService(defName, services)) {
        let service = getServiceOfArtifact(defName, services);
        // (4.2) Check associations
        if (isAssocOrComposition(member.type, csn)) {
          // Check that exposed associations do not point to non-exposed targets
          checkExposedAssoc(defName, member, memberName, service);

          // CDXCORE-457
          if (def.kind === 'type' && options.toOdata.version == 'v2') {
            signal(warning`"${defName}.${memberName}": Structured types must not contain associations for OData V2`);
          }
        }
        // (4.3) CDXCORE-458
        else if (propertyName === 'elements' && member.items && options.toOdata.version == 'v2') {
          signal(error`"${defName}.${memberName}": Element must not be an "array of" for OData V2`, path);
        }


        // (4.4) If the member is an association and the target is annotated with @cds.odata.valuelist,
        // annotate the association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propagation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in edmPreprocessor.initializeAssociation()
        addCommonValueListviaAssociation(member, memberName);

        // (4.5) https://github.wdf.sap.corp/cdx/cds-compiler/issues/837
        // add check here for @Analytics.Measure and @Aggregation.default
        // @Analytics has scope element
        if (member['@Analytics.Measure'] && !member['@Aggregation.default']) {
          signal(
            warning`'@Analytics.Measure' expects '@Aggregation.default' to be assigned as well in element '${defName}.${memberName}'`,
            // ['definitions', defName, 'elements', memberName]
            path
          );
        }
      }
      visitedArtifacts[defName] = true;
    }, ['definitions', defName]);
  });

  // Fifth walk through the model:
  // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
  // (5.2) Perform checks for exposed non-abstract entities and views - check media type and
  //      key-ness (requires that containers have been identified in the fourth pass (4.2))
  let illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(csn, (def, defName) => {
    // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(def.kind)) {
        def['@cds.persistence.name'] = getArtifactDatabaseNameOf(defName, options.toOdata.names, getNamespaceOfArtifact(defName));
      }
      forEachMemberRecursively(def, (member, memberName, prop) => {
        // Only these are actually required and don't annotate virtual elements in entities or types
        // as they have no DB representation (although in views)
        if (typeof member === 'object' && !['action', 'function'].includes(member.kind) && prop !== 'enum' && (!member.virtual || def.query)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          member['@cds.persistence.name'] = getElementDatabaseNameOf(memberName, options.toOdata.names);
        }
      });
    }

    // (5.2) Perform checks for exposed non-abstract entities and views
    if (isArtifactInSomeService(defName, services) && !def.abstract && (def.kind == 'entity' || def.kind == 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      let eltCount = 0;
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version == 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${defName}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, ['definitions', defName, 'elements', elemName]);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        let ignore = elem['@cds.api.ignore'];
        if (!elem._ignore) {
          eltCount++;
          if (elem.key && !ignore) {
            keyCount++;
          }
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      if (eltCount == 0) {
        signal(error`Entity "${defName}" must have at least one element`, ['definitions', defName]);
      }
      // Exposed non-abstract entities must have a key
      if (keyCount == 0) {
        signal(error`Entity "${defName}" does not have a key: ODATA entities must have a key`, ['definitions', defName]);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version == 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e => e[1].key);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${defName}: Key elements [${mtkeys.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, ['definitions', defName]);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${defName}: Elements [${mediaTypes.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, ['definitions', defName]);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1].type)) {
          signal(error`"${defName}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, ['definitions', defName, 'elements', e[0]]);
        }
      });
    }
  });

  /**
 * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
 *
 * @param {any} csn The csn
 * @returns {Array} Reclassified messages-Array
 */
  function reclassifyWarnings(csn) {
    return csn.messages.map(message => {
      switch (message.messageId) {
        case 'empty-entity-or-type':
          message.severity = 'Error';
          break;
      }
      return message;
    });
  }

  // Throw exception in case of errors
  if (hasErrors(csn.messages)) {
    csn.messages = reclassifyWarnings(csn);
    throw new CompilationError(sortMessages(csn.messages), csn);
  }
  return csn;

  // (1.4) Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
  // Implements: CDXCORE-62
  function annotateCoreComputed(node) {
    // If @Core.Computed is explicitly set, don't overwrite it!
    if (node['@Core.Computed']) return;

    // For @odata.on.insert/update, also add @Core.Computed
    if (node['@odata.on.insert'] || node['@odata.on.update'])
      node['@Core.Computed'] = true;
  }

  // (1.5) Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const mappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@description': '@Core.Description',
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    }

    for (let name in node) {
      // Rename according to map above
      if (mappings[name] != undefined)
        renameAnnotation(node, name, mappings[name]);

      // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
      if (name == '@important') {
        renameAnnotation(node, name, '@UI.Importance');
        let annotation = node['@UI.Importance'];
        node['@UI.Importance'] = { '#': annotation ? 'High' : 'Low' }
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if (name == '@readonly') {
        if (node.kind == 'entity' || node.kind == 'view') {
          node['@Capabilities.DeleteRestrictions.Deletable'] = false;
          node['@Capabilities.InsertRestrictions.Insertable'] = false;
          node['@Capabilities.UpdateRestrictions.Updatable'] = false;
        } else {
          renameAnnotation(node, name, '@Core.Computed');
        }
      }
    }
  }

  // (1.6) Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node, defPath) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (typeof node[name] != 'boolean' && typeof node[name] != 'string') {
        signal(warning`Annotation "${name}" must have a string or boolean value`, defPath);
      }
    }
  }

  // (2.1) If 'action' uses structured types as parameters or return values that are not exposed in 'service'
  // (because the types are anonymous or have a definition outside of 'service'), create equivalent types
  // in 'service' and make 'action' use them instead
  function exposeStructTypesForAction(action, actionName, service) {
    exposeStructTypeOf(action.returns, service, `__return_${actionName.replace(/\./g, '_')}`, actionName);
    for (let paramName in action.params || {}) {
      exposeStructTypeOf(action.params[paramName], service, `__param_${actionName.replace(/\./g, '_')}_${paramName}`, actionName);
    }
  }

  // (1.2), (2.1) If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
  // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
  // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
  // Complain if there is an error.
  function exposeStructTypeOf(node, service, artificialName, parentName) {
    if (!node) {
      return;
    }
    if (node.items) {
      exposeStructTypeOf(node.items, service, artificialName, parentName);
    }

    if ((csn.definitions[node.type] || node).elements
      && (!node.type || (!isArtifactInService(node.type, service) && (!node.type.startsWith('cds.') || node.type.startsWith('cds.foundation'))))) {
      let typeDef = node.type ? getCsnDef(node.type) : /* anonymos type */ node;
      if (typeDef && isStructured(typeDef) || (node.type && !node.type.startsWith(service))) {
        let typeId = node.type ? `__${node.type.replace(/\./g, '_')}` : artificialName;
        let type = exposeStructType(typeId, typeDef.elements, service, parentName);
        if (!type) {
          // Error already reported
          return;
        }
        // Recurse into elements of 'type' (if any)
        for (let elemName in type.elements) {
          exposeStructTypeOf(type.elements[elemName], service, `${typeId}_${elemName}`, parentName);
        }
        if (structuredOData) delete node.elements;
        node.type = `${service}.${typeId}`;
      }
    }
  }

  // (1.2), (2.1) Expose an artificial structured type with ID 'typeId' with 'elements' in 'service' (reusing such a type
  // if it already exists).
  // Return the exposed type. Report any errors
  function exposeStructType(typeId, elements, service, parentName) {
    let typeName = `${service}.${typeId}`;
    // If type already exists, reuse it (complain if not created here)
    let type = csn.definitions[typeName];
    if (type) {
      if (!(typeName in exposedStructTypes)) {
        signal(error`Cannot create artificial type "${typeName}" for an action or function "${parentName}" because the name is already used`);
        return null;
      }
      return type;
    }
    // Create type with empty elements
    type = {
      kind: 'type',
      elements: Object.create(null),
    };
    // Duplicate the type's elements
    for (let elemName in elements) {
      copyAndAddElement(elements[elemName], type, elemName);
    }
    csn.definitions[typeName] = type;
    // store typeName in set of exposed struct types
    exposedStructTypes[typeName] = true;
    return type;
  }

  // Third walk: Process associations
  // (3.1) Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed)
  // (3.2) Flatten on-conditions in unmanaged associations
  function flattenForeignKeysForArt(def, defName, flattenedKeyArts) {
    if (defName in flattenedKeyArts)
      return; // already flattened
    flattenedKeyArts[defName] = true;
    forEachMemberRecursively(def, (member, memberName) => {
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member) && !member._ignore) {
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        flattenForeignKeys(member, flattenedKeyArts, flattenForeignKeysForArt);
        // Generate foreign key elements
        for (let key of member.keys) {
          let foreignKeyElement = createForeignKeyElement(member, memberName, key, def, defName);
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
        // If the managed association is NOT NULL, we give it a target min cardinality of 1
        // if it didn't already have an explicitly specified min cardinality.
        // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
        if (member.notNull) {
          if (!member.cardinality) {
            member.cardinality = {};
          }
          if (member.cardinality.min === undefined) {
            member.cardinality.min = 1;
          }
        }
      }

      // (3.2) Flatten on-conditions in unmanaged associations
      if (member.type && isAssocOrComposition(member.type, csn) && member.on) {
        flattenOnCond(member, memberName, def.elements, defName);
      }
    });
  }

  // (4.1) Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact,
  // into its transitively reachable composition targets, and into the model.
  // 'rootArtifact' is the root artifact where composition traversal started.

  // Constraints
  // Draft Root: Exactly one PK of type UUID
  // Draft Node: One PK of type UUID + 0..1 PK of another type
  // Draft Node: Must not be reachable from multiple draft roots
  function generateDraftForOdata(artifact, artifactName, rootArtifact, visitedArtifacts) {
    // Sanity check
    if (!isArtifactInSomeService(artifactName, services)) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }
    // Nothing to do if already draft-enabled (composition traversal may have circles)
    if ((artifact['@Common.DraftRoot.PreparationAction'] || artifact['@Common.DraftNode.PreparationAction'])
      && artifact.actions && artifact.actions.draftPrepare) {
      return;
    }

    let keyNames = Object.keys(artifact.elements).filter(elemName => {
      return artifact.elements[elemName].key && artifact.elements[elemName].key === true;
    });

    if (artifact === rootArtifact) {
      // draft root
      if (keyNames.length != 1) {
        signal(info`"${artifactName}": "@odata.draft.enabled" - Draft root should have exactly one key element`, ['definitions', artifactName]);
      } else {
        let keyElem = artifact.elements[keyNames[0]];
        if (keyElem.type != 'cds.UUID' /* && keyElem._finalType.name.$renamed != 'cds.UUID' */) {
          signal(info`"${artifactName}": "@odata.draft.enabled" - Draft root key element should be of type "cds.UUID"`, ['definitions', artifactName, 'elements', keyNames[0]]);
        }
      }
    } else {
      // draft node
      if (keyNames.length < 1) {
        signal(info`"${artifactName}": "@odata.draft.enabled" - Draft node should have at least one key element`, ['definitions', artifactName]);
      } else if (keyNames.length > 2) {
        signal(info`"${artifactName}": "@odata.draft.enabled" - Draft node mshouldust have not more then two key elements`, ['definitions', artifactName]);
      } else {
        let uuidCount = 0;
        keyNames.forEach(kn => {
          let keyElem = artifact.elements[kn];
          if (keyElem.type == 'cds.UUID'  /* && keyElem._finalType.name.$renamed != 'cds.UUID' */) {
            uuidCount++;
          }
        });
        if (uuidCount != 1) {
          signal(info`"${artifactName}": "@odata.draft.enabled" - Draft node should have one key element of type "cds.UUID"`, ['definitions', artifactName]);
        }
      }
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = `${getServiceOfArtifact(artifactName, services)}.DraftAdministrativeData`;
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(getServiceOfArtifact(artifactName, services));
    }
    // Report an error if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind != 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, ['definitions', draftAdminDataProjectionName]);
    }

    // Generate the annotations describing the draft actions (only draft roots can be activated/edited)
    if (artifact == rootArtifact) {
      artifact['@Common.DraftRoot.ActivationAction'] = 'draftActivate';
      artifact['@Common.DraftRoot.EditAction'] = 'draftEdit';
      artifact['@Common.DraftRoot.PreparationAction'] = 'draftPrepare';
    } else {
      artifact['@Common.DraftNode.PreparationAction'] = 'draftPrepare';
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true);
    isActiveEntity.IsActiveEntity['@UI.Hidden'] = true;
    addElement(isActiveEntity, artifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false);
    hasActiveEntity.HasActiveEntity['@UI.Hidden'] = true;
    addElement(hasActiveEntity, artifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false);
    hasDraftEntity.HasDraftEntity['@UI.Hidden'] = true;
    addElement(hasDraftEntity, artifact);

    // @odata.contained: true
    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjectionName, true);
    draftAdministrativeData.DraftAdministrativeData.cardinality = { max: 1, };
    draftAdministrativeData.DraftAdministrativeData['@odata.contained'] = true;
    draftAdministrativeData.DraftAdministrativeData['@UI.Hidden'] = true;
    addElement(draftAdministrativeData, artifact);

    // Note that we need to do the ODATA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName) by hand, because the corresponding
    // transformation steps have already been done on all artifacts when we come here)
    let uuidDraftKey = draftAdministrativeData.DraftAdministrativeData.keys.filter(key => key.ref && key.ref.length === 1 && key.ref[0] === 'DraftUUID');
    if (uuidDraftKey && uuidDraftKey[0]) {
      uuidDraftKey = uuidDraftKey[0]; // filter returns an array, but it has only one element
      createForeignKeyElement(draftAdministrativeData.DraftAdministrativeData, 'DraftAdministrativeData', uuidDraftKey, artifact, artifactName);
    }
    // SiblingEntity : Association to one <artifact> on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifactName, false);
    siblingEntity.SiblingEntity.cardinality = { max: 1 };
    addElement(siblingEntity, artifact);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.SiblingEntity.on = createAssociationPathComparison('SiblingEntity', 'IsActiveEntity', '!=', 'IsActiveEntity');

    // Iterate elements
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName != 'IsActiveEntity' && elem.key) {
        // Amend the ON-condition above:
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        let cond = createAssociationPathComparison('SiblingEntity', elemName, '=', elemName);
        cond.push('and');
        cond.push(...siblingEntity.SiblingEntity.on);
        siblingEntity.SiblingEntity.on = cond;
      }

      // Make all non-key elements nullable
      if (elem.notNull && elem.key !== true) {
        elem.notNull = false;
      }

      // Draft-enable the targets of composition elements (draft nodes), too
      // TODO rewrite
      if (elem.target && elem.type && getFinalType(elem.type) === 'cds.Composition') {
        let draftNode = csn.definitions[elem.target];

        // Ignore if that is our own draft root
        if (draftNode != rootArtifact) {
          // Barf if the draft node has @odata.draft.enabled itself
          if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', true)) {
            signal(error`"${artifactName}.${elemName}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`, ['definitions', artifactName, 'elements', elemName]);
          }
          // Ignore composition if not part of a service
          else if (!getServiceName(elem.target)) {
            signal(warning`Target "${elem.target}" of composition "${artifactName}.${elemName}" cannot be a draft node because it is not part of a service`, ['definitions', artifactName, 'elements', elemName]);
            continue;
          }
          else if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', false)) {
            continue;
          }
          else {
            // Generate draft stuff into the target
            generateDraftForOdata(draftNode, elem.target, rootArtifact, visitedArtifacts);
          }
        }
      }
    }

    // Generate the actions into the draft-enabled artifact (only draft roots can be activated/edited)

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifactName, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact);

    if (artifact == rootArtifact) {
      // action draftActivate() return <artifact>;
      let draftActivate = createAction('draftActivate', artifactName);
      addAction(draftActivate, artifact);

      // action draftEdit (PreserveChanges: Boolean) return <artifact>;
      let draftEdit = createAction('draftEdit', artifactName, 'PreserveChanges', 'cds.Boolean');
      addAction(draftEdit, artifact);
    }
  }

  // CDXCORE-481
  // (4.5) If the member is an association whose target has @cds.odata.valuelist annotate it
  // with @Common.ValueList.viaAssociation.
  // This must be done before foreign keys are calculated and the annotations are propagated
  // to them. This will make sure that association and all its foreing keys are annotated with
  // Common.ValueList in the final EDM.
  // Do this only if the association is navigable and the enclosing artifact is 
  // a service member (don't pollute the CSN with unnecessary annotations).
  // TODO: test???
  function addCommonValueListviaAssociation(member, memberName) {
    let vlAnno = '@Common.ValueList.viaAssociation';
    if (isAssociation(member.type, csn)) {
      let navigable = member['@odata.navigable'] !== false; // navigable disabled only if explicitly set to false
      let targetDef = getCsnDef(member.target);
      if (navigable && targetDef['@cds.odata.valuelist'] && !member[vlAnno]) {
        member[vlAnno] = { '=': memberName };
      }
    }
  }
}

// Return an array of non-abstract service names contained in compacted 'model'
function getServiceNames(model) {
  let result = [];
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind == 'service' && !artifact.abstract) {
      result.push(artifactName);
    }
  });
  return result;
}

// Rename annotation 'fromName' in 'node' to 'toName' (both names including '@')
function renameAnnotation(node, fromName, toName) {
  let annotation = node && node[fromName];
  // Sanity checks
  if (!fromName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + fromName);
  }
  if (!toName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + toName);
  }
  if (annotation == undefined) {
    throw Error('Annotation ' + fromName + ' not found in ' + JSON.stringify(node));
  }
  delete node[fromName];
  node[toName] = annotation;
}

// some model utilities => TODO: move them to separate file
function isArtifactInSomeService(artName, services) {
  return services.some(serviceName => artName.startsWith(`${serviceName}.`));
}

function getServiceOfArtifact(artName, services) {
  return services.find(serviceName => artName.startsWith(`${serviceName}.`));
}


// Check if an artifact with name 'artName' is part of a 'service'
function isArtifactInService(artName, service) {
  return artName.startsWith(`${service}.`);
}
