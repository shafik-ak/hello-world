'use strict';

const os = require('os');
const path = require('path');
const childProcess = require('child_process');

function getDateTimeIso() {
  var date = new Date();

  var hour = date.getHours();
  hour = (hour < 10 ? "0" : "") + hour;

  var min  = date.getMinutes();
  min = (min < 10 ? "0" : "") + min;

  var sec  = date.getSeconds();
  sec = (sec < 10 ? "0" : "") + sec;

  var year = date.getFullYear();

  var month = date.getMonth() + 1;
  month = (month < 10 ? "0" : "") + month;

  var day  = date.getDate();
  day = (day < 10 ? "0" : "") + day;

  return year + "-" + month + "-" + day + " " + hour + ":" + min + ":" + sec;
}

/**
 * Benchmark suite.
 * @class
 */
function BenchmarkSuite() {
  const suite = {
    benchmarks: []
  };

  /**
   * Register a benchmark. The function will be executed N times depending
   * on the given options.
   * @param {string} identifier Unique identifier (name) of the benchmark
   * @param {string} description
   * @param {Object} options
   * @param {number} options.warmUpExecutions How often the function should be executed to warm up the NodeJs runtime.
   * @param {number} options.executions How often the function should be executed. Time is measured.
   * @param {function} benchmarkFunction Function which is executed N times. Should not have any side effects.
   */
  function registerBenchmark(identifier, description, options, benchmarkFunction) {
    suite.benchmarks.push({
      identifier, description, options, fct: benchmarkFunction
    });
  }

  /**
   * Run all registered benchmarks. Does not print any output.
   * @see print
   */
  function run() {
    for (let benchmark of suite.benchmarks) {
      // warm-up
      for (let i = 0; i < (benchmark.options.warmUpExecutions || 0); i++) {
        BenchmarkSuite.Use(benchmark.fct());
      }

      const timeStart = process.hrtime();
      for (let i = 0; i < benchmark.options.executions; i++) {
        BenchmarkSuite.Use(benchmark.fct());
      }
      benchmark.runtime = process.hrtime(timeStart);
    }
  }

  /**
   * Runs each benchmark *once* to check whether one fails. This way we don't have to wait
   * for all prior benchmarks to finish to know whether the last one works or fails.
   */
  function testEachBenchmark() {
    for (let benchmark of suite.benchmarks) {
      BenchmarkSuite.Use(benchmark.fct());
    }
  }

  /**
   * Print the benchmark results using a given reporter.
   * @param {function} benchmarkReporter Reporter that is given an array of benchmark results.
   * @see TableReporter
   * @see JsonReporter
   */
  function print(benchmarkReporter) {
    benchmarkReporter(suite);
  }

  /**
   * Filter the registered benchmarks and remove those that do *not* match the regex.
   * @param {string} regex
   */
  function filter(regex) {
    let newBenchmarks = [];
    let re = new RegExp(regex);
    for (let benchmark of suite.benchmarks) {
      if (benchmark.identifier.match(re)) {
        newBenchmarks.push(benchmark);
      }
    }
    suite.benchmarks = newBenchmarks;
  }

  /**
   * Lists all registered benchmarks. May print an already filtered list of benchmarks.
   */
  function list() {
    for (let benchmark of suite.benchmarks) {
      console.log(benchmark.identifier + ': ' + benchmark.description); // eslint-disable-line no-console
    }
  }

  /**
   * Gather information about the user's system. This data is also passed to all
   * benchmarkReporters so they can print this information as well.
   */
  function enableSystemInformation() {
    suite.system = {
      dateTimeISO: getDateTimeIso(), // timezone is ignored, though
      nodejs: process.versions,
      hostname: os.hostname(),
      osType: os.type(),
      release: os.release(),
      totalMemory: os.totalmem(),
      cpus: os.cpus(),
      nodePlatform: os.platform(),
      nodeArchitecture: os.arch()
    }
  }

  function enableGitInformation() {
    const basedir = path.resolve(__dirname, '../');
    const execGit = (command) => {
      return childProcess.execSync(`git ${command}`, {cwd: basedir}).toString().trim();
    }
    const branch = execGit(`rev-parse --abbrev-ref HEAD`);
    const revisionLong = execGit('rev-parse HEAD');
    const revisionShort = execGit('rev-parse --short HEAD');
    const dateIso = execGit(`show --no-patch --pretty="%cd" --date=format:'%Y-%m-%d %H:%M:%S'`);
    const tag = execGit(`tag --points-at HEAD`);
    const statusShort = execGit(`status --short`);

    suite.git = {
      branch,
      revisionLong,
      revisionShort,
      dateIso,
      tag,
      isDirty: statusShort != "",
      statusShort
    }
  }

  return {
    print,
    registerBenchmark,
    filter,
    list,
    run,
    testEachBenchmark,
    enableSystemInformation,
    enableGitInformation
  };
}

/**
 * Avoid compiler optimizations where the result is thrown away.
 */
BenchmarkSuite.Use = (data) => {
  if (data && data.doesNotExist) {
    // function with side effects
    console.log(data); // eslint-disable-line no-console
  }
}

/**
 * Wrapper that terminates the benchmarks by throwing an exception
 * and logging the error.
 */
BenchmarkSuite.Fail = (err) => {
  console.error(err); // eslint-disable-line no-console
  throw new Error("Benchmarks failed!");
}

module.exports = { BenchmarkSuite }
