const fs = require('fs-extra');
const os = require('os');
const path = require('path');

const TEMPLATES_ROOT = path.join(__dirname, '..', 'templates');
const TEMPLATE_REGEX = /<%=\s*(\w+)\s*%>/g;

const TEMPLATE_EXTENSION = '.tpl';
const TEMPLATE_EXTENSION_REGEX = new RegExp(`${TEMPLATE_EXTENSION}$`);

const UTF_8 = 'utf-8';

const _touchedFiles = new Set();

class FsHelper {

    getTemplate(templatePath) {
        return path.join(TEMPLATES_ROOT, templatePath);
    }


    _addTouchedFile(filepath) {
        const relativeFilepath = path.relative('', filepath);
        _touchedFiles.add(relativeFilepath);
    }


    async writeFile(filepath, content, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(filepath);
        }
        await fs.outputFile(filepath, content, UTF_8);
    }


    async writeJSON(filepath, object, options = { spaces: 4 }, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(filepath);
        }
        await fs.outputJSON(filepath, object, options);
    }


    async readFile(src) {
        return await fs.readFile(src, UTF_8);
    }


    async readJSON(src) {
        return await fs.readJSON(src);
    }


    async copy(source, destination, options = {}) {

        const filter = options.filter;

        options.filter = async (src, dest) => {
            let result = true;
            if (filter) {
                result = filter(src, dest);
            }

            if (result) {
                const stats = await this.stat(src);
                if (stats.isFile()) {
                    this._addTouchedFile(dest);
                }
            }

            return result;
        };

        await fs.copy(source, destination, options);
    }


    _isTemplateFile(filename) {
        return path.extname(filename) === TEMPLATE_EXTENSION;
    }


    _filterFiles(src, destination, templateFiles) {
        const filename = path.basename(src);

        const isTemplateFile = this._isTemplateFile(filename);

        if (isTemplateFile) {
            templateFiles.push({ src: src, destination: destination });
        }

        return !isTemplateFile;
    }


    async copyTemplate(template, destinationPath, templateValues, overwrite = false) {
        const templatePath = this.getTemplate(template);
        const templateFiles = [];

        const fileFilter = (src, dest) => {
            return this._filterFiles(src, dest, templateFiles);
        }

        await this.copy(templatePath, destinationPath, {
            filter: fileFilter,
            overwrite: overwrite,
            errorOnExists: false
        });

        for (const templateFile of templateFiles) {
            await this._processTemplateFile(templateFile.src, templateFile.destination, templateValues, overwrite);
        }
    }


    async _processTemplateFile(src, destination, templateValues, overwrite = false) {

        const destinationPath = destination.replace(TEMPLATE_EXTENSION_REGEX, '');
        if (overwrite || !(await this.pathExists(destinationPath))) {
            let content = await this.readFile(src);
            content = this._replaceTemplatePlaceholder(content, templateValues);

            await this.writeFile(destinationPath, content);
        }
    }


    _replaceTemplatePlaceholder(content, templateValues) {

        // clone regex since we have to modify internals ...
        const regex = new RegExp(TEMPLATE_REGEX);
        let match = regex.exec(content);

        while (match !== null) {
            const value = templateValues[match[1]] || '';
            content = content.replace(match[0], value);

            // modify search index to start from beginning
            regex.lastIndex = 0;
            match = regex.exec(content);
        }

        return content;
    }


    async createTempFolder(preFix) {
        return await fs.mkdtemp(path.join(os.tmpdir(), preFix));
    }


    // extra method to indicate removeal without etra file handling (native remove)
    async removeTempFolder(tempFolder) {
        if (tempFolder) {
            await fs.remove(tempFolder);
        }
    }


    async remove(src) {
        await fs.remove(src);
    }


    async pathExists(filePath) {
        return await fs.pathExists(filePath);
    }


    async readdir(filePath) {
        return await fs.readdir(filePath);
    }


    getTouchedFiles() {
        return Array.from(_touchedFiles.keys());
    }


    async mkdirp(folderPath) {
        await fs.mkdirp(folderPath);
    }


    async stat(filePath) {
        return await fs.stat(filePath);
    }
}

module.exports = FsHelper;
