const _calculateSpliceArgs = (index, whereCondition) => {
  const AND_OR = ['and', 'or']
  if (AND_OR.includes(whereCondition[index - 1])) {
    return { index: index - 1, count: 4 }
  }
  if (AND_OR.includes(whereCondition[index + 3])) {
    return { index: index, count: 4 }
  }
  if (whereCondition[index - 1] === '(' && whereCondition[index + 3] === ')') {
    if (AND_OR.includes(whereCondition[index - 2])) {
      return { index: index - 2, count: 6 }
    }
    if (AND_OR.includes(whereCondition[index + 4])) {
      return { index: index - 1, count: 6 }
    }

    return { index: index - 1, count: 5 }
  }
  return { index: index, count: 3 }
}

const _isActiveEntity = entry => entry.ref && entry.ref[entry.ref.length - 1] === 'IsActiveEntity'

const _removeIsActiveEntityCondition = where => {
  const newWhere = []
  const length = where.length
  let i = 0

  while (i < length) {
    if (_isActiveEntity(where[i])) {
      i = i + 3
    } else if (where[i] === 'and' && _isActiveEntity(where[i + 1])) {
      i = i + 4
    } else {
      newWhere.push(where[i])
      i++
    }
  }

  if (newWhere[0] === 'and') {
    newWhere.splice(0, 1)
  } else if (newWhere[0] === '(' && newWhere[1] === 'and') {
    newWhere.splice(0, 2)
  }

  return newWhere
}

const _isKeyValue = (i, keys, where) => {
  if (!where[i].ref || !keys.includes(where[i].ref[0])) {
    return false
  }

  return where[i + 1] === '=' && 'val' in where[i + 2]
}

const deleteCondition = (index, whereCondition) => {
  const spliceArgs = _calculateSpliceArgs(index, whereCondition)
  whereCondition.splice(spliceArgs.index, spliceArgs.count)
}

const readAndDeleteKeywords = (keywords, whereCondition, toDelete = true) => {
  const index = whereCondition.findIndex(({ ref }) => {
    if (!ref) {
      return false
    }

    const refLastIndex = ref.length - 1

    if (keywords.length === 1) {
      return ref[refLastIndex] === keywords[0]
    }

    if (keywords.length === 2 && ref.length >= 2) {
      return ref[refLastIndex - 1] === keywords[0] && ref[refLastIndex] === keywords[1]
    }
  })

  if (index === -1) {
    return
  }

  const result = {
    op: whereCondition[index + 1],
    value: whereCondition[index + 2]
  }

  if (toDelete) {
    deleteCondition(index, whereCondition)
  }

  return result
}

const removeIsActiveEntityRecursively = where => {
  for (const entry of where) {
    if (entry.SELECT && entry.SELECT.where && entry.SELECT.from.ref && !entry.SELECT.from.ref[0].endsWith('_drafts')) {
      entry.SELECT.where = _removeIsActiveEntityCondition(entry.SELECT.where)

      if (entry.SELECT.where.length === 0) {
        delete entry.SELECT.where
      }
    }
  }

  return _removeIsActiveEntityCondition(where)
}

const isActiveEntityRequested = where => {
  let i = 0

  while (where[i]) {
    if (where[i].ref && where[i].ref[0] === 'IsActiveEntity' && where[i + 1] === '=' && 'val' in where[i + 2]) {
      return where[i + 2].val === 'true' || where[i + 2].val === true
    }
    i++
  }

  return true
}

const getKeyData = (keys, where) => {
  if (!where) {
    return {}
  }

  const data = {}
  let i = 0

  while (where[i]) {
    if (_isKeyValue(i, keys, where)) {
      data[where[i].ref[0]] = where[i + 2].val
      i = i + 3
    } else {
      i++
    }
  }

  return data
}

// Assumption: Where contains only keys and IsActiveEntity
// whereCondition = [{ref: ['id']}, '=', {val: '123'},
//                    ----multiple-----
//                   , 'and', {ref: ['IsActiveEntity']}, '=', {val: 'true'}]
const extractKeyConditions = whereCondition => {
  const result = {
    keyList: []
  }

  const length = whereCondition.length
  let index = 0
  while (index < length) {
    if (['(', ')'].includes(whereCondition[index])) {
      index++
      continue
    }
    if (whereCondition[index].ref && whereCondition[index].ref[0] === 'IsActiveEntity') {
      result.IsActiveEntity = whereCondition[index + 2].val === 'true'
    } else {
      result.keyList.push(whereCondition[index], whereCondition[index + 1], whereCondition[index + 2])
    }
    index += 4
  }
  return result
}

module.exports = {
  deleteCondition,
  readAndDeleteKeywords,
  removeIsActiveEntityRecursively,
  isActiveEntityRequested,
  getKeyData,
  extractKeyConditions
}
