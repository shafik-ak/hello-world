const { isDraftEnabled } = require('../utils/compositionTree')

const Base = require('./Base')
const cds = require('../../cds')
const { CONTEXT_ERROR, handleErrorLog } = require('../../util/errors')
const sqliteLocales = ['de', 'fr']

/**
 * Class representation of on middleware.
 * @augments Base
 * @alias module:hooks.On
 */
class On extends Base {
  /**
   * Constructs a middleware handler.
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   * @param {string} [messagingService] - Messaging Service
   */
  constructor (reflected, service, messagingService) {
    super(reflected, service)
    this._messagingService = messagingService
  }

  /**
   * Adds a middleware handler to the set.
   * @param event
   * @param entity
   * @param handler
   * @private
   */
  _addHandler (event, entity, handler) {
    if (this._isWithMode) {
      this._withHandlers.push({ event, entity, handler })
    } else {
      // ensure that finalOn handler is last in the row
      this._handlers.splice(this._handlers.length - 1, 0, { event, entity, handler })
    }
  }

  _replaceQueryRef (context, name, localizedEntityName) {
    // if context.query has been called before, target has already been set in query, we need to adept the query itself if from.ref is not replaced by something else
    if (
      context.query.SELECT &&
      context.query.SELECT.from &&
      context.query.SELECT.from.ref &&
      context.query.SELECT.from.ref.length === 1 &&
      context.query.SELECT.from.ref[0] === name
    ) {
      context.query.SELECT.from.ref[0] = localizedEntityName
    }
  }

  /**
   * Check if a handler is registered for event and entity. Execute the handler that is registered,
   * with request and response as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .send(), .error(), ...
   * @param {string} context.target - the unreflected entity
   * @returns {Promise}
   */
  executeHandlerIfListed (event, context) {
    return new Promise((resolve, reject) => {
      this._middleware(event, context, resolve, reject)
    })
  }

  _checkForLocalizedEntity (event, context, handler) {
    if (
      event === 'READ' &&
      context.target &&
      handler.handler.isDefault &&
      !isDraftEnabled(this._model.definitions, context.target.name)
    ) {
      let locale = ''
      if (cds.options && cds.options.kind === 'sqlite') {
        const userLocale = context.user.locale
        if (sqliteLocales.includes(userLocale)) {
          locale = `${userLocale}.`
        }
      }
      const localizedEntity = this._model.definitions[`localized.${locale}${context.target.name}`]
      const name = context.target.name
      context.target = localizedEntity || context.target

      // localized entity exists
      if (localizedEntity && typeof context.query !== 'function') {
        this._replaceQueryRef(context, name, localizedEntity.name)
      }
    }
  }

  _handleInMessaging (event, entity, handler) {
    if (entity) {
      const entitySeparatedByDot = entity.split('.')
      const denormalizedEntity = entitySeparatedByDot[entitySeparatedByDot.length - 1]
      this._messagingService.on(event, denormalizedEntity, handler)
    } else {
      this._messagingService.on(event, handler)
    }
  }

  _checkImplicitNext (newResult, nextCalled, context, nextOnce) {
    return newResult === undefined && !nextCalled && !this._replyRejectCalled(context) ? nextOnce() : newResult
  }

  _propagateResult (result, newResult) {
    return newResult !== undefined ? newResult : result
  }

  _middleware (event, context, resolve, reject) {
    const calledFrom = {}
    const length = this._handlers.length

    let i = 0
    let result

    // Recursive function, which will work with closures i and length
    const next = (err, calledFromHandler) => {
      // Throw error if next is called twice from same handler
      if (calledFrom[calledFromHandler]) {
        const error = new Error('next() has been called before in the same handler.')
        error.code = 500
        throw error
      }

      calledFrom[calledFromHandler] = true

      // Explicit end of chain by handler
      if (err) {
        reject(err)
        return
      }

      // .reply or .reject has been called
      if (this._replyRejectCalled(context)) {
        return
      }

      let handler

      // Check all registered handlers if registered for this event.
      while (i < length) {
        // Copy count and use to identify
        const count = i
        let nextCalled = false

        const nextOnce = err => {
          nextCalled = true
          return next(err, count)
        }

        handler = this._handlers[i]
        i++

        // We have to catch in order to be able to release the DB client.
        if (this._match(event, context, handler)) {
          const oldTarget = context.target

          try {
            this._measureStartTime(context, handler)

            this._checkForLocalizedEntity(event, context, handler)

            let newResult = handler.handler(context, nextOnce)

            // implicitly call next() if nothing was returned and req.reject/req.reply were not called
            // This will break if a user calls next() inside setTimeout without returning a promise (not supported)
            newResult = this._checkImplicitNext(newResult, nextCalled, context, nextOnce)

            // in case no result was returned propagate the result of the next handler
            result = this._propagateResult(result, newResult)

            return this._handleLayerReturn(
              context,
              result,
              resolve,
              reject,
              handler,
              calledFromHandler === -1,
              oldTarget
            )
          } catch (err) {
            // Do not measure performance in case of error
            handleErrorLog(handler, context)
            context.target = oldTarget
            reject(err)
            return
          }
        }
      }
    }

    next(null, -1)
  }

  /**
   * (a)sync code might be in place which can be expressed in various forms.
   * If a return is given, provide convenience.
   * @private
   */
  _handleLayerReturn (context, layerReturn, resolve, reject, handler, isFirstHandler, oldTarget) {
    // Promise or equaly behaving thenables.
    if (layerReturn && layerReturn.then) {
      return this._handleThenables(context, layerReturn, resolve, reject, handler, isFirstHandler, oldTarget)
    }

    // CQN means, we should run it
    if (this._isCQN(layerReturn)) {
      return this._handleThenables(
        context,
        context.run(layerReturn),
        resolve,
        reject,
        handler,
        isFirstHandler,
        oldTarget
      )
    }

    context.target = oldTarget

    // A result is returned, that marks the end of the chain
    if (layerReturn !== undefined && typeof layerReturn !== 'function' && !this._replyRejectCalled(context)) {
      this._measureEndTime(context, handler)

      if (isFirstHandler) {
        resolve(this._handleErrors(context, layerReturn))
      }

      return layerReturn
    }

    if ('rejected' in context) {
      reject(context.rejected)
      return
    }

    if ('results' in context) {
      this._measureEndTime(context, handler)

      if (isFirstHandler) {
        resolve(context.results)
      }
    }
  }

  _replyRejectCalled (context) {
    return 'rejected' in context || 'results' in context
  }

  /**
   * The app dev decided to handle async processes on its own.
   * The result should be the end of the chain.
   * @private
   */
  _handleThenables (context, promise, resolve, reject, handler, isFirstHandler, oldTarget) {
    return promise
      .then(result => {
        context.target = oldTarget

        if ('rejected' in context) {
          throw context.rejected
        }

        this._measureEndTime(context, handler)

        if (isFirstHandler) {
          resolve(this._handleErrors(context, result !== undefined ? result : context.results))
          return
        }

        return result
      })
      .catch(err => {
        handleErrorLog(handler, context, err[Symbol.for(CONTEXT_ERROR)])
        context.target = oldTarget
        reject(err)
      })
  }
}

module.exports = On
