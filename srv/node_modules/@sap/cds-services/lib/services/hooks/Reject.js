const {
  getNotInModelEntityError,
  getNotInModelEventError,
  getNotInModelBoundActionError,
  getNotInModelStringNameEntityError,
  getNotInModelKindEntityError
} = require('../../util/errors')
const { events: EVENTS } = require('../utils/constants')
const { ensureDraftsSuffix } = require('../utils/draftUtils')

/**
 * Reject manages all to be rejected events and event + entity combinations..
 * @alias module:hooks.Reject
 */
class Reject {
  /**
   * Constructs a reject handler.
   * Instantiates a new Set internally in which the individual entries will be referenced.
   *
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    this._rejects = new Set()
    this._model = reflected
    this._service = service
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   */
  use (event, ...entity) {
    if (!event) {
      throw new Error('.reject() called without event argument')
    }

    // Ensure both parameters can be handled as array
    const events = Array.isArray(event) ? event : [event]
    const entities = Array.isArray(entity[0]) ? entity[0] : entity

    this._addEventAndEntityLists(events, entities)
  }

  /**
   * Iterate over events and foreach entry iterate over entities.
   * Add all possible combinations to the reject list.
   * @param {array} events - List of events
   * @param {array} entities - List of entities.
   * @private
   */
  _addEventAndEntityLists (events, entities) {
    let normalizedEvent

    for (const event of events) {
      normalizedEvent = event

      // Check if provided event is
      // (a) default event or
      // (b) unbound custom operation contained in the reflection model
      if (!EVENTS.DEFAULT.includes(event) && entities.length === 0) {
        normalizedEvent = this._addServiceNamePrefix(event)

        if (!this._isUnboundCustomOperation(normalizedEvent)) {
          throw getNotInModelEventError(this._service, event, this._model)
        }
      }

      if (entities.length === 0) {
        this._rejects.add(this._checkRejectEntry(normalizedEvent))
      } else {
        this._addEntitiesForEvent(normalizedEvent, entities)
      }
    }
  }

  _throwErrorForObject (entity, event) {
    if (entity.kind !== 'entity' || typeof entity.name !== 'string') {
      if (entity.kind !== 'entity') {
        throw getNotInModelKindEntityError(this._service, event, entity, this._model)
      } else if (entity.name !== 'string') {
        throw getNotInModelStringNameEntityError(this._service, event, entity, this._model)
      }
    }
  }

  /**
   * Iterate over entities and add reject entries for given event.
   * Add all possible combinations to the reject list.
   * @param {string} event - Event the entities operations should be rejected for.
   * @param {array} entities - List of entities.
   * @private
   */
  _addEntitiesForEvent (event, entities) {
    for (let entity of entities) {
      let entityName = entity

      if (this._entityHasNotValidType(entity)) {
        throw getNotInModelEntityError(this._service, event, entity, this._model)
      }

      if (typeof entity === 'object') {
        this._throwErrorForObject(entity, event)
        entityName = entity.name
      }

      const serviceEntity = this._addServiceNamePrefix(entityName)

      // Check if provided entity is not defined in the reflection model
      if (!this._isModeledEntity(serviceEntity)) {
        throw getNotInModelEntityError(this._service, event, entityName, this._model)
      }

      // Check if provided bound custom operation is defined within the provided entity in the reflection model
      if (
        !EVENTS.DEFAULT.includes(event) &&
        serviceEntity !== undefined &&
        !this._isBoundCustomOperation(serviceEntity, event)
      ) {
        throw getNotInModelBoundActionError(this._service, event, entityName, this._model)
      }

      this._addRejects(event, serviceEntity)
    }
  }

  _addRejects (event, serviceEntity) {
    if (EVENTS.DRAFT.includes(event) && event !== 'EDIT') {
      this._rejects.add(this._checkRejectEntry(event, ensureDraftsSuffix(serviceEntity)))
    } else {
      this._rejects.add(this._checkRejectEntry(event, serviceEntity))
    }
  }

  _entityHasNotValidType (entity) {
    return typeof entity !== 'string' && typeof entity !== 'object'
  }

  _addServiceNamePrefix (definition) {
    return definition.startsWith(this._service) ? definition : `${this._service}.${definition}`
  }

  /**
   * Checks whether or not an entity exists in the reflection model.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isModeledEntity (entity) {
    return this._model.find(d => d.kind === 'entity' && d.name === entity) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as unbound custom operation in the reflection model.
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isUnboundCustomOperation (event) {
    return this._model.find(d => ['action', 'function'].includes(d.kind) && d.name === event) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as bound custom operation in the reflection model.
   * @param {string} entity
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isBoundCustomOperation (entity, event) {
    return (
      this._model.find(d => d.kind === 'entity' && d.name === entity && d.actions && d.actions[event]) !== undefined
    )
  }

  /**
   * Check if the specified event is valid by type.
   * @param event
   * @param entity
   * @returns {Object}
   * @private
   */
  _checkRejectEntry (event, entity) {
    if (typeof entity === 'string') {
      return { event, entity }
    }

    return { event }
  }

  /**
   * Checks if the set has the event or event and entity combination.
   * @param {string} event - Name of the event like READ, UPDATE, DELETE, ...
   * @param {Object} target - Unreflected entity from CSN referenced at context object
   * @returns {boolean}
   */
  has (event, target = {}) {
    for (const entry of this._rejects) {
      if (entry.event === event && (!entry.entity || entry.entity === target.name)) {
        return true
      }
    }

    return false
  }
}

module.exports = Reject
