const Base = require('./Base')
const { all, reject } = require('../../util/thenable')
const { handleErrorLog } = require('../../util/errors')

/**
 * Class representation of before middleware.
 * @augments Base
 * @alias module:hooks.Before
 */
class Before extends Base {
  /**
   * Check if handlers are registered for event and entity. Execute all handlers that are registered,
   * with result being passed in as input parameter to the handler.
   *
   * Execute handlers (handler(request, response)) in given sequence.
   * Note that there are two scenarios: asynchronous handlers and synchronous handlers.
   * If handler has promise as return only the start of handlers will be in sequence. They will run in parallel.
   *
   * The event returns a Promise, that resolves, when the last handler is done.
   *
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .send(), .error(), ...
   * @param {Object} context.target - the unreflected entity
   * @returns {Promise}
   */
  executeHandlerIfListed (event, context) {
    if (this._isTransactionEvent(event)) {
      return this._execute(event, context)
    }

    return this._execute(event, context).then(val => {
      return this._endPhase(context) || this._handleErrors(context)
    })
  }

  _execute (event, context) {
    const thens = []

    for (const entry of this._handlers) {
      const end = this._endPhase(context)

      if (end) {
        return end
      }

      if (this._match(event, context, entry)) {
        try {
          this._measureStartTime(context, entry)
          this._collectAsync(thens, context, entry, entry.handler(context))
        } catch (err) {
          handleErrorLog(entry, context)
          return reject(err)
        }
      }
    }

    return all(thens)
  }

  _collectAsync (thens, context, entry, fnReturn) {
    if (fnReturn && fnReturn.then) {
      thens.push(
        fnReturn.then(() => {
          this._measureEndTime(context, entry)
        })
      )
    } else {
      this._measureEndTime(context, entry)
    }
  }
}

module.exports = Before
