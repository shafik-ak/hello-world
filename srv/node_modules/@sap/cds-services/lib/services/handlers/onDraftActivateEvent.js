const { activeVersionExists, ensureNoDraftsSuffix, proxifyToNoDraftsName } = require('../utils/draftUtils')
const { readAndDeleteKeywords, isActiveEntityRequested } = require('../utils/draftWhereUtils')
const { readDraftCompositionTree } = require('../utils/readDraftCompositionTree')
const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const { isDraftRootEntity } = require('../utils/compositionTree')

const _isLocked = (InProcessByUser, id) => InProcessByUser && InProcessByUser !== id

/**
 * Generic Handler for draftActivate requests.
 * In case of success it triggers an 'UPDATE' or 'CREATE' event.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDraftActivate
 */
const onDraftActivateEvent = service => async context => {
  // TODO: Write admin data to context. Beware: context.draft should not be used
  //       since active date needs to be modified (context.draft will be used as
  //       an indicator that only draft data is modified)
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    context.reject(404)
    return
  }

  if (
    isActiveEntityRequested(context.query.SELECT.where || []) ||
    context._.odataReq.getUriInfo().getPathSegments().length > 2 ||
    !isDraftRootEntity(service.model.definitions, ensureNoDraftsSuffix(context.target.name))
  ) {
    context.reject(400)
    return
  }

  const draftCompositionTree = await readDraftCompositionTree(service, context)

  if (context.rejected) {
    return
  }

  if (!draftCompositionTree || !draftCompositionTree.data) {
    context.reject(404)
    return
  }

  if (_isLocked(draftCompositionTree.administrativeData.InProcessByUser, context.user.id)) {
    context.reject(403)
    return
  }

  context.draftMetadata = draftCompositionTree.administrativeData

  // new object to have 'real' object
  const data = Object.assign({}, draftCompositionTree.data[0][0])
  const newContext = Object.assign({}, context, { target: proxifyToNoDraftsName(context.target) })
  // workaround for getter not being copied
  newContext.query = context.query

  if (await activeVersionExists(context)) {
    readAndDeleteKeywords(['IsActiveEntity'], context.query.SELECT.where)

    return service
      .update(newContext.target)
      .set(data)
      .where(newContext.query.SELECT.where)
      .with(newContext)
  }

  return service
    .create(newContext.target)
    .entries(data)
    .with(newContext)
}

module.exports = onDraftActivateEvent
