const {
  messages: { DB_CONNECTION_MISSING },
  DRAFT_COLUMNS
} = require('../utils/constants')
const {
  getEnrichedCQN,
  removeDraftUUID,
  ensureDraftsSuffix,
  ensureNoDraftsSuffix,
  addColumnAlias
} = require('../utils/draftUtils')
const { deleteCondition, readAndDeleteKeywords, removeIsActiveEntityRecursively } = require('../utils/draftWhereUtils')
const getColumns = require('../utils/columns')

const _isTrue = val => val === true || val === 'true'

const _isFalse = val => val === false || val === 'false'

const _createdByUserWhere = userId => [{ ref: ['filterAdmin', 'CreatedByUser'] }, '=', { val: userId }]

const _getTableName = (
  {
    target: { name },
    query: {
      SELECT: { from }
    }
  },
  isDraft = false
) => {
  const table = isDraft ? ensureDraftsSuffix(name) : ensureNoDraftsSuffix(name)
  const as = from.args ? from.args[0].as : from.as
  if (as) {
    return {
      table: {
        ref: [table],
        as: as
      },
      name: as
    }
  }

  return {
    table: {
      ref: [table]
    },
    name: table
  }
}

const _getTargetKeys = ({ target: { elements } }) => {
  return Object.keys(elements)
    .filter(key => elements[key].key && elements[key].name !== 'IsActiveEntity')
    .map(key => elements[key].name)
}

const DRAFT_COLUMNS_CASTED = [
  {
    ref: ['IsActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasDraftEntity'],
    cast: { type: 'cds.Boolean' }
  }
]

const DRAFT_ADMIN_COLUMNS_CASTED = [
  'DraftUUID',
  'CreationDateTime',
  'CreatedByUser',
  {
    ref: ['DraftIsCreatedByMe'],
    cast: { type: 'cds.Boolean' }
  },
  'LastChangeDateTime',
  'LastChangedByUser',
  'InProcessByUser',
  {
    ref: ['DraftIsProcessedByMe'],
    cast: { type: 'cds.Boolean' }
  }
]

// default draft values for active entities
const _getDefaultDraftProperties = ({ hasDraft, isActive = true, withDraftUUID = true }) => {
  const columns = [
    { val: isActive, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } },
    {
      val: hasDraft === null ? null : Boolean(hasDraft),
      as: 'HasDraftEntity',
      cast: hasDraft === null ? null : { type: 'cds.Boolean' }
    }
  ]

  if (withDraftUUID) {
    columns.push(
      isActive
        ? { val: null, as: 'DraftAdministrativeData_DraftUUID' }
        : { ref: ['DraftAdministrativeData_DraftUUID'], as: 'DraftAdministrativeData_DraftUUID' }
    )
  }

  return columns
}

// draft values for active entities with calculated hasDraft property
const _getDraftPropertiesDetermineDraft = (context, where, tableName, calcDraftUUID = false) => {
  const { table } = _getTableName(context, true)

  tableName = tableName || table

  const hasDraftQuery = context.statements.SELECT.from(tableName, [{ val: 1 }])
  if (where && where.length > 0) {
    hasDraftQuery.where(where)
  }

  let draftUUIDColumn
  if (calcDraftUUID) {
    draftUUIDColumn = context.statements.SELECT.from(tableName, ['DraftAdministrativeData_DraftUUID'])
    if (where && where.length > 0) {
      draftUUIDColumn.where(where)
    }
  } else {
    draftUUIDColumn = { val: null, as: 'DraftAdministrativeData_DraftUUID' }
  }

  const xpr = {
    xpr: ['case', 'when', hasDraftQuery, 'IS NOT NULL', 'then', 'true', 'else', 'false', 'end'],
    as: 'HasDraftEntity',
    cast: { type: 'cds.Boolean' }
  }

  hasDraftQuery.as = 'HasDraftEntity'
  hasDraftQuery.cast = { type: 'cds.Boolean' }

  return [
    { val: true, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } },
    xpr,
    draftUUIDColumn
  ]
}

const _copyCQNPartial = partial => {
  if (partial.SELECT && partial.SELECT.where) {
    const newPartial = Object.assign({}, partial)
    const newSELECT = Object.assign({}, partial.SELECT)
    newSELECT.from = _copyCQNPartial(partial.SELECT.from)
    newPartial.SELECT = newSELECT
    newPartial.SELECT.where = _copyArray(partial.SELECT.where)
    return newPartial
  }

  return partial.ref ? Object.assign({}, partial, { ref: _copyArray(partial.ref) }) : Object.assign({}, partial)
}

const _copyArray = array => {
  return array.map(entry => {
    return typeof entry === 'object' ? _copyCQNPartial(entry) : entry
  })
}

const _whereContainsKeys = (context, whereDraft) => {
  const keys = _getTargetKeys(context)
  if (whereDraft.length < keys.length * 4 - 1) {
    return false
  }

  let i = 0
  let keyCount = 0
  while (i < whereDraft.length) {
    const element = whereDraft[i]
    const op = whereDraft[i + 1]
    if (element.ref && keys.some(x => x === element.ref[element.ref.length - 1]) && op === '=') {
      // op is EQ by keys
      i = i + 4
      keyCount++
      continue
    }

    i++
  }

  return keyCount === keys.length
}

const _isValidActive = (isActiveEntity, context, whereDraft) => {
  return isActiveEntity.op === '=' && _isTrue(isActiveEntity.value.val) && _whereContainsKeys(context, whereDraft)
}

const _isValidDraftOfWhichIAmOwner = isActiveEntity => {
  return isActiveEntity.op === '=' && _isFalse(isActiveEntity.value.val)
}

const _isValidActiveWithoutDraft = (isActiveEntity, hasDraftEntity) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    hasDraftEntity.op === '=' &&
    _isFalse(hasDraftEntity.value.val)
  )
}

const _isValidWithDraftLocked = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '!=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidWithDraftTimeout = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidExcludeActiveDraftExists = (isActiveEntity, siblingIsActive) => {
  return (
    isActiveEntity.op === '=' &&
    _isFalse(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null
  )
}

const _isOnlyCount = columns => columns.length === 1 && columns[0].as === 'counted'

const _getOuterMostColumns = (columnsFromRequest, additionalDraftColumns) =>
  _isOnlyCount(columnsFromRequest) ? columnsFromRequest : [...columnsFromRequest, ...additionalDraftColumns]

const _draftAdminTable = (context, columns, serviceName) => {
  const { table } = _getTableName(context)

  let cqn = context.statements.SELECT.from(table)
  if (context.query.SELECT.columns) {
    cqn = cqn.columns(...context.query.SELECT.columns)
  }

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, context.query.SELECT.where), scenario: 'DRAFT_ADMIN' }
}

const _allInactive = (context, columns, serviceName) => {
  const outerMostColumns = _getOuterMostColumns(
    columns,
    _getDefaultDraftProperties({ hasDraft: false, isActive: false, withDraftUUID: false })
  )
  const cqn = context.statements.SELECT.from(context.query.SELECT.from).columns(...outerMostColumns)
  cqn.where(context.query.SELECT.where)

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, []), scenario: 'ALL_INACTIVE' }
}

const _allActive = (context, columns) => {
  const { table } = _getTableName(context)
  // TODO: calculate hasDraft for each entry
  const outerMostColumns = _getOuterMostColumns(columns, _getDefaultDraftProperties({ hasDraft: null }))
  const cqn = context.statements.SELECT.from(table).columns(...outerMostColumns)

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, context.query.SELECT.where), scenario: 'ALL_ACTIVE' }
}

const _active = (context, draftWhere, columns) => {
  const { table } = _getTableName(context)

  const outerMostColumns = _getOuterMostColumns(columns, _getDraftPropertiesDetermineDraft(context, draftWhere))

  const cqn = context.statements.SELECT.from(table).columns(...outerMostColumns)

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, draftWhere), scenario: 'ACTIVE' }
}

const _activeWithoutDraft = (context, draftWhere, columns) => {
  const { table } = _getTableName(context, true)
  const draftName = table.ref[0]
  const active = _getTableName(context)
  const keys = _getTargetKeys(context)

  let subSelect = context.statements.SELECT.from(draftName).columns(...keys)
  subSelect = keys.reduce(
    (select, key) =>
      subSelect.where({ ref: [active.name, key] }, '=', {
        ref: [draftName, key]
      }),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, _getDefaultDraftProperties({ hasDraft: false }))

  let cqn = context.statements.SELECT.from(active.table)
    .columns(...outerMostColumns)
    .where('not exists', subSelect)

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, draftWhere), scenario: 'ACTIVE_WITHOUT_DRAFT' }
}

const _draftOfWhichIAmOwner = (context, draftWhere, columns) => {
  const { table, name } = _getTableName(context, true)

  const outerMostColumns = _getOuterMostColumns(addColumnAlias(columns, name), DRAFT_COLUMNS_CASTED)

  const cqn = context.statements.SELECT.from(table)
    .columns(...outerMostColumns)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on({ ref: [name, 'DraftAdministrativeData_DraftUUID'] }, '=', {
      ref: ['filterAdmin', 'DraftUUID']
    })
    .where({ ref: ['filterAdmin', 'CreatedByUser'] }, '=', { val: context.user.id })

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, draftWhere), scenario: 'DRAFT_WHICH_OWNER' }
}

const _activeWithDraftInProcess = (context, draftWhere, columns, isLocked) => {
  const draft = _getTableName(context, true)
  const draftName = draft.table.ref[0]
  const active = _getTableName(context)
  const keys = _getTargetKeys(context)
  const draftColumns = _getDefaultDraftProperties({ hasDraft: true })

  let subSelect = context.statements.SELECT.from(draftName)
    .columns(...keys)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on({ ref: [draftName, 'DraftAdministrativeData_DraftUUID'] }, '=', {
      ref: ['filterAdmin', 'DraftUUID']
    })

  if (isLocked) {
    subSelect = subSelect.where(
      { ref: ['filterAdmin', 'InProcessByUser'] },
      '!=',
      { val: context.user.id },
      'and',
      { ref: ['filterAdmin', 'InProcessByUser'] },
      '!=',
      {
        val: null
      }
    )
  } else {
    subSelect = subSelect.where(
      { ref: ['filterAdmin', 'LastChangedByUser'] },
      '!=',
      { val: context.user.id },
      'and',
      { ref: ['filterAdmin', 'InProcessByUser'] },
      '=',
      {
        val: null
      }
    )
  }

  subSelect = keys.reduce(
    (select, key) =>
      subSelect.where({ ref: [active.name, key] }, '=', {
        ref: [draftName, key]
      }),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, draftColumns)

  const cqn = context.statements.SELECT.from(active.table)
    .columns(outerMostColumns)
    .where('exists', subSelect)

  return { cqn: getEnrichedCQN(cqn, context.query.SELECT, draftWhere), scenario: 'DRAFT_IN_PROCESS' }
}

const _alignAliasForUnion = (table, as, select) => {
  if (!as || !select.SELECT.where) {
    return select
  }

  for (const entry of select.SELECT.where) {
    if (entry.ref && entry.ref[0] === table) {
      entry.ref[0] = as
    }
  }

  return select
}

const _isKeyElement = (element, keys) => element.ref && keys.includes(element.ref[element.ref.length - 1])
const _valExists = (i, length, where) => i < length - 2 && where[i + 2].val

const _findKeysInWhereAndAddToResult = (where, keys, result) => {
  for (let i = 0, length = where.length; i < length; i++) {
    const element = where[i]
    if (_isKeyElement(element, keys) && _valExists(i, length, where)) {
      result[element.ref[element.ref.length - 1]] = where[i + 2].val
      i = i + 2
    }
  }
}

const _findKeysInQuery = (query, keys) => {
  const result = {}
  if (query.SELECT && query.SELECT.where) {
    if (query.SELECT.where[0] === 'exists') {
      return _findKeysInQuery(query.SELECT.where[1], keys)
    }

    _findKeysInWhereAndAddToResult(query.SELECT.where, keys, result)
  }
  return result
}

const _siblingEntity = (context, columns) => {
  const keys = _findKeysInQuery(context.query, Object.keys(context.target.keys))
  const isSiblingActive = keys.IsActiveEntity !== 'true'

  const targetTable = isSiblingActive
    ? ensureNoDraftsSuffix(context.target.name)
    : ensureDraftsSuffix(context.target.name)
  const columnCqnPartial = columns.map(col => {
    const colName = col.ref ? col.ref[col.ref.length - 1] : col
    return { ref: ['target', colName], as: colName }
  })
  columnCqnPartial.push({ ref: ['draftAdmin', 'InProcessByUser'], as: 'InProcessByUser' })
  const cqn = context.statements.SELECT.from(`${targetTable} as target`).columns(...columnCqnPartial)

  if (isSiblingActive) {
    cqn
      .join(ensureDraftsSuffix(context.target.name), 'target_draft')
      .on('target.ID', '=', 'target_draft.ID')
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on('target_draft.DraftAdministrativeData_DraftUUID', '=', 'draftAdmin.DraftUUID')
  } else {
    cqn
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on('target.DraftAdministrativeData_DraftUUID', '=', 'draftAdmin.DraftUUID')
  }

  for (const key of Object.keys(keys).filter(key => key !== 'IsActiveEntity')) {
    cqn.where({ ref: ['target', key] }, '=', keys[key])
  }

  return { cqn, scenario: 'SIBLING_ENTITY', isSiblingActive: isSiblingActive }
}

const _getUnionCQN = (context, draftName, columns, subSelect, draftWhere) => {
  draftWhere = removeIsActiveEntityRecursively(draftWhere)

  const refDraft = context.query.SELECT.from.as ? { ref: [draftName], as: context.query.SELECT.from.as } : draftName

  const draftDocs = getEnrichedCQN(
    context.statements.SELECT.from(refDraft)
      .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
      .on({ ref: [context.query.SELECT.from.as || draftName, 'DraftAdministrativeData_DraftUUID'] }, '=', {
        ref: ['filterAdmin', 'DraftUUID']
      })
      .where(..._createdByUserWhere(context.user.id)),
    context.query.SELECT,
    draftWhere,
    false
  )
  const activeDocs = getEnrichedCQN(
    context.statements.SELECT.from(context.target),
    context.query.SELECT,
    draftWhere,
    false
  )
  const union = context.statements.SELECT.from({ SET: { op: 'union', all: true, args: [draftDocs, activeDocs] } })

  if (context.query.SELECT.from.as) {
    draftDocs.SELECT.from.as = context.query.SELECT.from.as
    activeDocs.SELECT.from.as = context.query.SELECT.from.as
  }

  if (_isOnlyCount(columns)) {
    draftDocs.columns(...columns)
    activeDocs
      .columns(...columns)
      .where(
        'not exists',
        _alignAliasForUnion(ensureNoDraftsSuffix(context.target.name), context.query.SELECT.from.as, subSelect)
      )

    return union.columns({ func: 'sum', args: [{ ref: ['counted'] }], as: 'counted' })
  }

  draftDocs.columns(
    ...addColumnAlias(columns, context.query.SELECT.from.as || draftName),
    ...DRAFT_COLUMNS_CASTED,
    'DraftAdministrativeData_DraftUUID'
  )

  const activeName = activeDocs.SELECT.from.as || (activeDocs.SELECT.from.ref && activeDocs.SELECT.from.ref[0])

  const hasDraftWhere = []
  for (const key of _getTargetKeys(context)) {
    hasDraftWhere.push({ ref: [activeName, key] }, '=', { ref: [draftName, key] })
  }

  activeDocs
    .columns(
      ...columns,
      ..._getDraftPropertiesDetermineDraft(context, hasDraftWhere, ensureDraftsSuffix(context.target.name), true)
    )
    .where(
      'not exists',
      _alignAliasForUnion(ensureNoDraftsSuffix(context.target.name), context.query.SELECT.from.as, subSelect)
    )

  // groupBy, orderBy and limit do not support partial CQNs
  if (context.query.SELECT.groupBy) {
    union.SELECT.groupBy = context.query.SELECT.groupBy
  }

  if (context.query.SELECT.orderBy) {
    union.SELECT.orderBy = context.query.SELECT.orderBy
  }

  if (context.query.SELECT.limit) {
    union.SELECT.limit = context.query.SELECT.limit
  }

  return union.columns(...columns).columns(...DRAFT_COLUMNS_CASTED)
}

const _excludeActiveDraftExists = (context, draftWhere, columns) => {
  const { table, name } = _getTableName(context, true)
  const draftName = table.ref[0]

  const subSelect = context.statements.SELECT.from(draftName, [1])
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on({ ref: [draftName, 'DraftAdministrativeData_DraftUUID'] }, '=', {
      ref: ['filterAdmin', 'DraftUUID']
    })
    .where(..._createdByUserWhere(context.user.id))

  for (const key of _getTargetKeys(context)) {
    subSelect.where({ ref: [ensureNoDraftsSuffix(context.target.name), key] }, '=', { ref: [draftName, key] })
  }

  const cqn = _getUnionCQN(context, draftName, columns, subSelect, draftWhere)
  cqn.SELECT.from.as = name

  return { cqn: cqn, scenario: 'UNION' }
}

const _readDraftParameters = where => ({
  isActiveEntity: readAndDeleteKeywords(['IsActiveEntity'], where),
  hasDraftEntity: readAndDeleteKeywords(['HasDraftEntity'], where),
  siblingIsActive: readAndDeleteKeywords(['SiblingEntity', 'IsActiveEntity'], where),
  draftInProcessByUser: readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)
})

const _validatedActiveWithoutDraft = (context, draftWhere, draftParameters, columns) =>
  _isValidActiveWithoutDraft(draftParameters.isActiveEntity, draftParameters.hasDraftEntity)
    ? _activeWithoutDraft(context, draftWhere, columns)
    : undefined

const _validatedActiveWithDraftInProcess = (context, draftWhere, draftParameters, columns) => {
  if (draftParameters.draftInProcessByUser.op === '!=') {
    return _isValidWithDraftLocked(
      draftParameters.isActiveEntity,
      draftParameters.siblingIsActive,
      draftParameters.draftInProcessByUser
    )
      ? _activeWithDraftInProcess(context, draftWhere, columns, context.user.id)
      : undefined
  }

  return _isValidWithDraftTimeout(
    draftParameters.isActiveEntity,
    draftParameters.siblingIsActive,
    draftParameters.draftInProcessByUser
  )
    ? _activeWithDraftInProcess(context, draftWhere, columns, null)
    : undefined
}

const _validatedExcludeActiveDraftExists = (context, draftWhere, draftParameters, columns) =>
  _isValidExcludeActiveDraftExists(draftParameters.isActiveEntity, draftParameters.siblingIsActive)
    ? _excludeActiveDraftExists(context, draftWhere, columns)
    : undefined

const _validatedActive = (context, draftWhere, draftParameters, columns) =>
  _isValidActive(draftParameters.isActiveEntity, context, draftWhere)
    ? _active(context, draftWhere, columns)
    : undefined

const _validatedDraftOfWhichIAmOwner = (context, draftWhere, draftParameters, columns) =>
  _isValidDraftOfWhichIAmOwner(draftParameters.isActiveEntity)
    ? _draftOfWhichIAmOwner(context, draftWhere, columns)
    : undefined

const _draftInSubSelect = where => {
  return where.some(({ SELECT }) => {
    if (SELECT && SELECT.where) {
      const isActiveEntity = readAndDeleteKeywords(['IsActiveEntity'], SELECT.where, false)
      if (isActiveEntity) {
        return _isFalse(isActiveEntity.value.val)
      }

      return _draftInSubSelect(SELECT.where)
    }

    return false
  })
}

const _generateCQN = (context, columns, serviceName) => {
  // TODO: How to get from context? Maybe with new CSN
  if (context._.odataReq.getUrlObject().path.endsWith('SiblingEntity')) {
    return _siblingEntity(context, columns)
  }

  if (context.target.source === 'DRAFT.DraftAdministrativeData') {
    return _draftAdminTable(context, DRAFT_ADMIN_COLUMNS_CASTED, serviceName)
  }

  if (!context.query.SELECT.where || context.query.SELECT.where.length === 0) {
    return _allActive(context, columns)
  }

  const draftParameters = _readDraftParameters(context.query.SELECT.where)

  if (!draftParameters.isActiveEntity) {
    if (_draftInSubSelect(context.query.SELECT.where)) {
      return _allInactive(context, columns, serviceName)
    }
    return _allActive(context, columns)
  }

  if (draftParameters.hasDraftEntity) {
    return _validatedActiveWithoutDraft(context, context.query.SELECT.where, draftParameters, columns)
  }

  if (draftParameters.siblingIsActive) {
    return draftParameters.draftInProcessByUser
      ? _validatedActiveWithDraftInProcess(context, context.query.SELECT.where, draftParameters, columns)
      : _validatedExcludeActiveDraftExists(context, context.query.SELECT.where, draftParameters, columns)
  }

  return _isTrue(draftParameters.isActiveEntity.value.val)
    ? _validatedActive(context, context.query.SELECT.where, draftParameters, columns)
    : _validatedDraftOfWhichIAmOwner(context, context.query.SELECT.where, draftParameters, columns)
}

const _getColumns = ({ query: { SELECT } }, model) => {
  return SELECT.columns
    ? SELECT.columns.filter(
      col =>
        (col.ref && !DRAFT_COLUMNS.includes(col.ref[col.ref.length - 1])) ||
          (!col.ref && !DRAFT_COLUMNS.includes(col))
    )
    : getColumns(model.definitions[ensureNoDraftsSuffix(SELECT.from.ref[0])], true, true)
}

const _isIsActiveEntity = element =>
  element.ref &&
  (element.ref[0] === 'IsActiveEntity' || (element.ref.length > 1 && element.ref[1] === 'IsActiveEntity'))

const replaceRefWithDraft = ref => {
  if (!ref || !ref[0]) {
    return
  }

  ref[0] = `${ref[0]}_drafts`
}

const _adaptSubSelects = ({ SELECT: { from, where } }, scenario) => {
  if (!where) {
    return
  }

  let indexDel = -1

  if (scenario === 'ALL_INACTIVE') {
    replaceRefWithDraft(from.ref)
  }

  for (let i = 0, len = where.length; i < len; i++) {
    const element = where[i]

    if (_isIsActiveEntity(element) && len > i + 2) {
      if (scenario !== 'ALL_INACTIVE' && _isFalse(where[i + 2].val)) {
        replaceRefWithDraft(from.ref)
        // read from draft table because draft has draftUUID
      } else if (scenario === 'DRAFT_ADMIN' && !_isFalse(where[i + 2].val)) {
        replaceRefWithDraft(from.ref)
      }

      indexDel = i
    }

    if (element.SELECT) {
      _adaptSubSelects(element, scenario)
    }
  }

  if (indexDel !== -1) {
    deleteCondition(indexDel, where)
  }
}

const _calculateDraftAdminColumns = (result, user) => {
  if (result.DraftIsCreatedByMe) {
    result.DraftIsCreatedByMe = result.CreatedByUser === user
  }

  if (result.DraftIsProcessedByMe) {
    result.DraftIsProcessedByMe = result.InProcessByUser === user
  }
}

const _adaptDraftColumnsForSiblingEntity = (result, isSiblingActive) => {
  result.IsActiveEntity = isSiblingActive
  result.HasDraftEntity = isSiblingActive
  result.HasActiveEntity = !isSiblingActive
}

/**
 * Generic Handler for READ requests in the context of draft.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onRead
 */
const onReadDraft = service => async context => {
  if (context.query.SELECT.limit && context.query.SELECT.limit.rows.val === 0) {
    return Promise.resolve([])
  }

  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return []
  }

  const contextClone = Object.assign({}, context, { query: {} })

  contextClone.query = _copyCQNPartial(context.query)

  const cqnScenario = _generateCQN(contextClone, _getColumns(contextClone, service.model), service.name)

  if (!cqnScenario) {
    context.reject(400)
    return
  }

  _adaptSubSelects(cqnScenario.cqn, cqnScenario.scenario)

  const result = await context.run(cqnScenario.cqn)
  removeDraftUUID(result)

  if (cqnScenario.scenario === 'DRAFT_ADMIN') {
    if (result.length === 0) return
    _calculateDraftAdminColumns(result[0], context.user.id)
  }

  if (cqnScenario.scenario === 'SIBLING_ENTITY') {
    if (result.length === 0 || result[0].InProcessByUser !== context.user.id) {
      return
    }

    delete result[0].InProcessByUser
    _adaptDraftColumnsForSiblingEntity(result[0], cqnScenario.isSiblingActive)
  }

  return result
}

module.exports = onReadDraft
