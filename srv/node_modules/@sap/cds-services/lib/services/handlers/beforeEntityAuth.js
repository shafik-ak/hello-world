const cds = require('../../cds')

const { getIpFromRequest } = require('../utils/clientFromRequest')
const defaultEvents = ['CREATE', 'READ', 'UPDATE', 'DELETE', 'NEW', 'PATCH', 'EDIT', 'CANCEL']

const _getErrorMessage = event => `${event} is only allowed with static instance-based authorization`

const _evaluate = (ref, context) => {
  return ref.reduce((prev, curr) => {
    return prev ? prev[curr.replace(/^\$/, '')] : prev
  }, context)
}

const _valuesToOrConditions = (columnRef, op, values) => {
  const arr = ['(']

  for (const value of values) {
    if (arr.length !== 1) {
      arr.push('or')
    }

    arr.push(columnRef, op, { val: value })
  }

  arr.push(')')

  return arr
}

const _xprToCondition = (context, columnRef, op, userRef) => {
  let attrValue = userRef.ref.length === 1 ? context.user.id : _evaluate(userRef.ref, context)

  if (attrValue === undefined) {
    // HANA does not support TRUE as expression
    return [{ val: '1' }, '=', { val: '1' }]
  }

  if (Array.isArray(attrValue)) {
    return _valuesToOrConditions(columnRef, op, attrValue)
  }

  return [columnRef, op, { val: attrValue }]
}

const _parseWhereFromXpr = (context, xpr) => {
  const length = xpr ? xpr.length : 0

  const processed = []
  let i = 0

  while (i < length) {
    if (typeof xpr[i] === 'object' && xpr[i].SELECT && xpr[i].SELECT.where) {
      xpr[i].SELECT.where = _parseWhereFromXpr(context, xpr[i].SELECT.where)
    }

    if (xpr[i].ref && typeof xpr[i + 1] === 'string' && xpr[i + 2].ref) {
      if (xpr[i].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i + 2], xpr[i + 1], xpr[i]))
      } else if (xpr[i + 2].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i], xpr[i + 1], xpr[i + 2]))
      } else {
        processed.push(xpr[i], xpr[i + 1], xpr[i + 2])
      }
      i += 3
    } else {
      processed.push(xpr[i])
      i++
    }
  }

  return processed
}

/**
 * Replace $user with context.user.id
 * and $user.bla.bla with context.user.bla.bla.
 * Afterwards split to parts by space.
 *
 * @param annotatedWhere
 * @param context
 *
 * @private
 */
const _parseWhere = (annotatedWhere, context) => {
  const { xpr } = cds.parse.expr(annotatedWhere)

  return _parseWhereFromXpr(context, xpr)
}

const _cqnToData = on => {
  const data = {}
  const length = on.length
  let i = 0

  while (i < length) {
    if (on[i].ref && on[i + 1] === '=' && on[i + 2].val) {
      data[on[i].ref[on[i].ref.length - 1]] = on[i + 2].val
      i += 3
    } else {
      i++
    }
  }

  return data
}

const _changeUpdate = (wheres, context) => {
  const parsed = _cqnToData(_parseWhere(wheres[0], context))

  if (context.data) {
    Object.assign(context.data, parsed)
  }

  Object.assign(context.query.UPDATE.data, parsed)
}

const _getValueFromContext = (reference, context) => {
  // the reference arg in WHERE is $user
  if (reference.length === 1) {
    return context.user.id
  }

  let staticValue = context.user
  // the reference arg in WHERE is $user property
  for (var i = 1; i < reference.length; i++) {
    if (staticValue === undefined) {
      return
    }
    staticValue = staticValue[reference[i]]
  }

  return staticValue
}

const _isValueIncludedOrEqual = (value1, value2) => {
  if (Array.isArray(value1)) {
    return value1.includes(value2)
  } else if (Array.isArray(value2)) {
    return value2.includes(value1)
  } else {
    return value1 === value2
  }
}

const _checkValue = (first, operator, second, context, event) => {
  let value1
  let value2
  if (first && first.ref && first.ref[0] === '$user' && second && second.val) {
    value1 = _getValueFromContext(first.ref, context)
    value2 = second.val
  }
  if (second && second.ref && second.ref[0] === '$user' && first && first.val) {
    value1 = first.val
    value2 = _getValueFromContext(second.ref, context)
  }
  if (value1 === undefined && value2 === undefined) {
    return context.reject(403, _getErrorMessage(event))
  }
  if (value1 === undefined || value2 === undefined) {
    return context.reject(403)
  }
  let isAllowed = false

  switch (operator) {
    case '=':
      isAllowed = _isValueIncludedOrEqual(value1, value2)
      break
    case '>':
      isAllowed = value1 > value2
      break
    case '<':
      isAllowed = value1 < value2
      break
    case '!=':
      isAllowed = value1 !== value2
      break
    case '<=':
      isAllowed = value1 <= value2
      break
    case '>=':
      isAllowed = value1 >= value2
      break
    default:
      return context.reject(400, `${operator} in instance-based authorization is not supported`)
  }

  if (!isAllowed) {
    return context.reject(403)
  }
}

const _validateStaticInstanceBased = (wheres, context, event) => {
  const { xpr } = cds.parse.expr(wheres[0]['='] || wheres[0])
  if (xpr.length > 3) {
    return context.reject(403, _getErrorMessage(event))
  }
  return _checkValue(xpr[0], xpr[1], xpr[2], context, event)
}

const _authStatus = (annotations, context) => {
  const auth = {
    status: 'not granted',
    where: []
  }

  for (const anno of annotations) {
    if (anno.to) {
      if (context.user.has(anno.to)) {
        if (!anno.where) {
          auth.status = 'granted'
          return auth
        }
        auth.status = 'where'
        auth.where.push(anno.where)
      }
    } else {
      auth.status = 'where'
      auth.where.push(anno.where)
    }
  }

  return auth
}

const _hasExpand = columns => {
  for (const col of columns) {
    if (col.expand) {
      return true
    }
  }

  return false
}

// Add alias symbol to refs in case of expand
const _enhanceWhereInCaseExpand = (query, where) => {
  if (query.SELECT && _hasExpand(query.SELECT.columns)) {
    for (const w of where) {
      if (w.ref) {
        w.ref[Symbol.for('sap.cds.FROM_ANNOTATION')] = true
      }
    }
  }
}

/**
 * Get generic authorization handler for CRUD requests on entity level.
 * The handler to be registered as a before handler.
 *
 * @param annotations - prepared authorization (restrict or requires) annotations
 * @param auditLogger - the audit logger object
 */
const getAuthEntityHandler = (annotations, auditLogger) => {
  /**
   * @param context - operation object, that provides error, continuation and other functions as well as information
   * regarding the current operation.
   */
  return context => {
    const { status, where } = _authStatus(annotations, context)

    if (status === 'granted') return

    // TODO: wait for answer: || (context.query.INSERT && status === 'where')
    if (status === 'not granted') {
      auditLogger.logMissingPermissions({
        user: context.user.id,
        ip: getIpFromRequest(context._.req),
        tenant: context.attr.identityZone
      })

      return context.reject(403)
    }

    if (context.query.INSERT) {
      return _validateStaticInstanceBased(where, context, 'CREATE')
    }

    if (!defaultEvents.includes(context.event)) {
      return _validateStaticInstanceBased(where, context, 'Custom operation')
    }

    if (context.query.UPDATE) {
      _changeUpdate(where, context)
    }

    const whereClause = where.reduce((clause, condition, index) => {
      if (index !== 0) {
        clause.push('OR')
      }
      clause.push(..._parseWhere(condition, context))
      return clause
    }, [])

    _enhanceWhereInCaseExpand(context.query, whereClause)
    context.query.where(['(', ...whereClause, ')'])
  }
}

module.exports = getAuthEntityHandler
