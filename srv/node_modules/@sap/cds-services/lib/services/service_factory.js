const cds = require('../cds')

const _addSlashToPath = path => {
  return path.startsWith('/') ? path : `/${path}`
}

const _getUrlPath = (length, atPath, csnPath) => {
  if (length === 1) {
    return _addSlashToPath(atPath || csnPath || '/').replace(/\/{2,}/g, '/')
  }

  return `/${_addSlashToPath(atPath || '/')}${_addSlashToPath(csnPath || '/')}`.replace(/\/{2,}/g, '/')
}

const _lowerFirstLetter = string => {
  return `${string.charAt(0).toLowerCase()}${string.slice(1)}`
}

/**
 * Removes namespace and Service suffix.
 * Changes first name of service to lowercase.
 * @param name
 * @return {string}
 * @private
 */
const _parsePathFromName = (name = '') => {
  let matches = name.match(/([^.]+)Service$/)

  if (!matches) {
    matches = name.match(/([^.]+)/)
  }

  if (matches) {
    return _lowerFirstLetter(matches[1])
  }

  return name
}

const _getServiceCount = model => {
  let count = 0

  model.foreach('service', () => {
    count++
  })

  return count
}

const _getServiceDefinition = (model, serviceName) => {
  if (serviceName) {
    return model.definitions[serviceName]
  }

  return model.find('service') || {}
}

const _options = (options = {}) => {
  options.logger = options.log || options.logger
  options.debug = options.debug || false
  options.crashOnError = options.crashOnError === undefined ? true : Boolean(options.crashOnError)
  options.maxResourcePathLength = options.maxResourcePathLength || options.maxPathLength || 10
  options.maxPageSize = options.maxPageSize === false ? false : options.maxPageSize || 1000
  options.maxExpandSize = options.maxExpandSize || 100

  return options
}

/**
 * Service factory will return the router of the service instance.
 * The this scope within the init function will be of an instance of the class Service.
 * @param {string} csn - the unreflected CSN.
 * @param {Object} [options] - optional object with options, service implementation file.
 * @param {Object} [options.auditlog] - name of audit log service instance.
 * @param {boolean} [options.crashOnError] - Application should crash on error. Defaults to true.
 * @param {Object} [options.logger] - optional logger object to be used in the odata library.
 * @param {string} [options.logLevel] - optional log level to be used according to winston/npm specification.
 * @param {number} [options.maxPageSize] - The page limit value. By default server side paging is enabled and set to 100. To disable it set it to false.
 * @param {number} [options.maxResourcePathLength] - Maximum allowed number of resource path segments.
 * @param {Object} [options.passport] - Passport configuration.
 * @param {string} [options.path] - URL path, at which the service will be placed at.
 * @param {string} [options.service] - Service name as specified in CSN.
 * @param {Object} [options.uaa] - xsenv filter options for UAA service, which is used for JWT validation.
 * @returns {Object} - instance of service
 * @throws Error if no valid csn provided
 * @alias module:server.service
 * @see {@link Service}
 */
function service (csn, options) {
  if (typeof csn !== 'object') {
    const { getModelNotDefinedError } = require('../util/errors')
    throw getModelNotDefinedError('CSN model')
  }

  const serviceOptions = _options(options)
  const reflectedModel = cds.linked(cds.compile.for.odata(csn))
  const serviceDefinition = _getServiceDefinition(reflectedModel, serviceOptions.service)

  if (!serviceOptions.service) {
    serviceOptions.service = serviceDefinition.name
  }

  serviceOptions.path = _getUrlPath(
    _getServiceCount(reflectedModel),
    serviceOptions.path,
    serviceDefinition['@path'] || _parsePathFromName(serviceDefinition.name)
  )

  const Service = require('./Service')
  return new Service({ csn, reflectedModel }, serviceOptions)
}

module.exports = service
