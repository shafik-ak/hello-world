const cds = require('../cds')
const getError = require('../util/getError')
const { all } = require('../util/thenable')

const {
  events: { MOD }
} = require('../services/utils/constants')

// Service hooks and generic handlers
const handlers = require(`./handlers`)
const { After, Before, On, Reject } = require('./hooks')
const Client = require('./client/Client')
const path = require('path')
const os = require('os')

// Service utils
const auditLogger = require('../util/auditlog')
const { isDraftEnabled, isDraftRootEntity, selectDeepUpdateData } = require('./utils/compositionTree')
const { getDefaultHandlers, getScenario } = require('./utils/defaultHandlers')
const getDiff = require('./utils/diff')
const { checkIntegrityWrapper, flattenDeepToOneAssociations, filterReadOnly } = require('./utils/handlerUtils')
const { isPersonalDataRelevant } = require('./utils/personalData')
const isSelectEntity = require('./utils/selectEntityUtils')
const logger = require('./utils/logger')
const compareJson = require('./utils/compareJson')
const {
  events: { CUD_DRAFT },
  DRAFT_COLUMNS
} = require('./utils/constants')
const { fillDataDeep } = require('../util/dataProcessUtils')

// Utils used also at adapters
const getAnnotations = require('../adapter/utils/getAnnotations')

/**
 * Generic Service Event Handler.
 */
class Service extends Client {
  /**
   * Constructs an OData service for the given CDS model.
   * @param {Object} csn - the reflected CSN.
   * @param {Object} options - configuration options
   * @param {function} [impl] - init function to register custom handlers.
   */
  constructor ({ csn, reflectedModel }, options) {
    super()

    this.options = options
    // compat for umbrella
    this._options = options
    this.name = options.service
    this.model = reflectedModel
    this._csn = csn

    this._messagingService = this._getMessagingService(csn)

    this.definition = reflectedModel.definitions[this.name]

    Object.defineProperties(this, {
      operations: {
        get: () =>
          reflectedModel.childrenOf(this.definition, d => d.kind === 'action' || d.kind === 'function', 'operations'),
        configurable: true
      },
      entities: {
        get: () => reflectedModel.childrenOf(this.definition, d => d.kind === 'entity', 'entities'),
        configurable: true
      },
      types: {
        get: () => reflectedModel.childrenOf(this.definition, d => !d.kind || d.kind === 'type', 'types'),
        configurable: true
      }
    })

    this._handlers = {
      initial: new Before(this.model, this.name),
      before: new Before(this.model, this.name),
      on: new On(this.model, this.name, this._messagingService),
      after: new After(this.model, this.name),
      reject: new Reject(this.model, this.name)
    }

    this._addFunctions()
    this._addDefaultHandler()
  }

  _getMessagingOptionsCompat () {
    const providedSrv = cds.env.provides && cds.env.provides[this.name]
    const messaging = cds.env.requires && cds.env.requires.messaging
    if (providedSrv) {
      // for compatibility to existing tests only --> should rather remove it
      const kinds = typeof providedSrv.kind === 'object' ? Object.keys(providedSrv.kind) : [providedSrv.kind]

      let o = Object.assign({}, providedSrv)
      if (providedSrv.credentials) {
        o.credentials = Object.assign({}, providedSrv.credentials)
      }

      if (messaging && kinds.includes('messaging')) {
        o = this._mergeWithMessaging(o, messaging)
      }
      return o
    }
  }

  _getMessagingOptions () {
    const messaging = cds.env.requires && cds.env.requires.messaging
    const o = messaging ? { ...messaging } : {}

    let { kind, credentials } = o
    if (!credentials) credentials = o.credentials = {}

    if (credentials.file === true || credentials.file === 'default') {
      o.credentials.file = path.join(os.tmpdir(), 'cds-message-box')
    }

    if (this.options.credentials) {
      Object.assign(credentials, this.options.credentials.messaging)
    }

    if (!kind || kind === 'local') {
      o.kind = this._getDerivedKind(kind, credentials)
    }

    // This is to report credentials to local bindings in dev scenarios:
    if (!this.options.credentials) this.options.credentials = {}
    if (!this.options.credentials.messaging) this.options.credentials.messaging = {}
    Object.assign(this.options.credentials, credentials)

    return o
  }

  _getDerivedKind (kind, credentials) {
    if (kind === 'local') {
      return credentials.file ? 'file-based-messaging' : 'in-process-messaging'
    }
    if (!kind) {
      return credentials.management && credentials.messaging
        ? 'enterprise-messaging'
        : credentials.file
          ? 'file-based-messaging'
          : 'in-process-messaging'
    }
  }

  _getMessagingService (csn) {
    const o = this._getMessagingOptionsCompat() || this._getMessagingOptions()
    o.model = csn

    return cds.ql.connect(this.name, o)
  }

  _mergeWithMessaging (connectionOptions, messaging) {
    if (typeof connectionOptions.kind === 'object') {
      const mergedOptionsObj = Object.assign({}, messaging, connectionOptions.kind.messaging)
      delete connectionOptions.kind.messaging
      connectionOptions.kind[messaging.kind] = mergedOptionsObj
      delete connectionOptions.kind[messaging.kind].kind
    } else {
      connectionOptions = Object.assign({}, messaging, connectionOptions, { kind: messaging.kind })
    }
    return connectionOptions
  }

  /**
   * Require logger on first usage.
   * Could be provided via options.
   *
   * @returns {Object}
   */
  get logger () {
    const log = logger(this.options)
    Object.defineProperty(this, 'logger', { value: log })
    return log
  }

  /**
   * Require @sap/audit-logging on first usage.
   * @returns {Object}
   * @private
   */
  get _auditLogger () {
    const audit = auditLogger(this.options.auditlog, this.logger)
    Object.defineProperty(this, '_auditLogger', { value: audit })
    return audit
  }

  /**
   * @deprecated since version 1.11.0 - use Service.impl instead
   */
  with (serviceImpl) {
    return this.impl(serviceImpl)
  }

  _finishWithHandlers () {
    this._handlers.before.finishAddingWithHandlers()
    this._handlers.on.finishAddingWithHandlers()
    this._handlers.after.finishAddingWithHandlers()
  }

  /**
   * Registers custom handlers.
   * @param {string|object|function} serviceImpl - init function to register custom handlers.
   */
  impl (serviceImpl) {
    if (typeof serviceImpl === 'string') {
      serviceImpl = require(serviceImpl)
    }

    if (typeof serviceImpl === 'object') {
      serviceImpl = serviceImpl[this.name]
    }

    if (typeof serviceImpl !== 'function') {
      return this
    }

    if (/^class\s/.test(Function.prototype.toString.call(serviceImpl))) {
      const ImplClass = serviceImpl
      serviceImpl = srv => {
        const inst = new ImplClass(srv)
        for (let e of Reflect.ownKeys(ImplClass.prototype)) {
          if (e in { constructor: 1, prototype: 1 }) {
            continue
          }
          const handler = (...args) => inst[e](...args)
          srv.on(e, handler)
        }
      }
    }

    this._handlers.before.startAddingWithHandlers()
    this._handlers.on.startAddingWithHandlers()
    this._handlers.after.startAddingWithHandlers()

    const result = serviceImpl.apply(this, [this])

    if (result && result.then) {
      result.then(() => {
        return this._finishWithHandlers()
      })
    } else {
      this._finishWithHandlers()
    }

    return this
  }

  /**
   * Register default on handlers for all entities of the service.
   * If the entity is marked with @readonly annotation only default handler for read is registered, others are rejected.
   * If the entity is marked with @insertonly annotation only default handler for insert is registered, others are rejected.
   * @private
   */
  _addDefaultHandler () {
    // Final handler, that will throw an error - should be registered first!
    this.on(this._markDefault(handlers.finalOn))

    this._addDefaultBeforeAuthHandler()

    const isDraftEnabledService = Object.values(this.entities).some(entity => entity['@odata.draft.enabled'])

    if (isDraftEnabledService) {
      this.model['IS_SERVICE_DRAFT'] = true
    }

    const serviceEntities = this._getServiceEntities()
    for (const entity of serviceEntities) {
      const { before, on, reject } = getDefaultHandlers(
        isDraftEnabledService,
        isDraftEnabled(this.model.definitions, entity.name),
        isDraftRootEntity(this.model.definitions, entity.name),
        entity.name
      ).get(getScenario(entity, serviceEntities))

      this._addDefaultInitialHandler(before, entity)
      this._addDefaultOnHandler(on, entity)
      this._addDefaultRejectHandler(reject, entity.name)

      // register audit logging handlers only for entities with personal data annotation
      if (isPersonalDataRelevant(entity)) {
        this._addPersonalDataHandler(entity)
      }
    }

    // Generic commit/rollback
    this.on('COMMIT', this._markDefault(handlers.onCommit))
    this.on('ROLLBACK', this._markDefault(handlers.onRollback))
  }

  _addReferenceIntegrityHandler (method, entity) {
    this.before(method, entity, this._markDefault(checkIntegrityWrapper(this.model)))
  }

  _markDefault (handler) {
    handler.isDefault = true
    return handler
  }

  _isReferenceIntegrityCheckNeeded (entity, service) {
    return (
      !this.model['IS_SERVICE_DRAFT'] &&
      !(entity['@cds.integrity.skip'] !== false && (entity['@cds.integrity.skip'] || service['@cds.integrity.skip']))
    )
  }

  _addDefaultInitialHandler (before, entity) {
    for (const [method, handlerName] of before) {
      const handler = handlers[handlerName](this)
      this._initial(method, entity, this._markDefault(handler))
    }

    if (this._isReferenceIntegrityCheckNeeded(entity, this.model.definitions[this.name])) {
      this._addReferenceIntegrityHandler(['CREATE', 'UPDATE', 'DELETE'], entity)
    }
  }

  _addDefaultOnHandler (on, entity) {
    for (const [method, handlerName] of on) {
      const handler = handlers[handlerName](this)
      this.on(method, entity, this._markDefault(handler))
    }
  }

  _addDefaultRejectHandler (reject, entityName) {
    if (reject.length) {
      this.reject(reject, entityName)
    }
  }

  /**
   * Register default before commit and after commit/rollback handler for the entity.
   * @param entity
   * @private
   */
  _addPersonalDataHandler (entity) {
    if (
      entity['@AuditLog.Operation.Insert'] ||
      entity['@AuditLog.Operation.Update'] ||
      entity['@AuditLog.Operation.Delete']
    ) {
      this.before('COMMIT', entity, this._markDefault(handlers.beforeCommitPersonalData(this._auditLogger)))
      this.after('COMMIT', entity, this._markDefault(handlers.afterCommitPersonalData))
      this.before('ROLLBACK', entity, this._markDefault(handlers.beforeRollbackPersonalData(this._auditLogger)))
      this.after('ROLLBACK', entity, this._markDefault(handlers.afterRollbackPersonalData))
    } else if (entity['@AuditLog.Operation.Read']) {
      this.before('COMMIT', entity, this._markDefault(handlers.beforeCommitPersonalData(this._auditLogger)))
    }
  }

  /**
   * Register default before handlers for all authorization annotated entities and operations of the service.
   * @private
   */
  _addDefaultBeforeAuthHandler () {
    for (const entity of this._getServiceEntities()) {
      const annotations = getAnnotations(entity)

      for (const key of Object.keys(annotations)) {
        const handler = handlers.beforeEntityAuth(annotations[key], this._auditLogger)
        this.before(key, entity, this._markDefault(handler))
      }

      if (entity.actions) {
        // bound actions or functions
        this._addBeforeOperationAuthHandler(entity.actions, entity)
      }
    }

    this._addBeforeOperationAuthHandler(this.operations)
  }

  _addBeforeOperationAuthHandler (operations, entity) {
    for (const key of Object.keys(operations)) {
      const annotations = getAnnotations(operations[key])

      if (annotations['operation']) {
        const handler = handlers.beforeEntityAuth(annotations['operation'], this._auditLogger)
        this.before(key, entity, this._markDefault(handler))
      }
    }
  }

  _getServiceEntities () {
    const regex = new RegExp(`^${this.name.replace(/\./g, '\\.')}\\.\\w+$`)
    return this.model.all(definition => {
      return (
        (definition.kind === 'entity' || isSelectEntity(definition, this.model)) && // OLD CSN: isSelectEntity
        definition.name.match(regex)
      )
    })
  }

  /**
   * Add an initial handler for a specific event type and entity. N handlers per type and entity can be registered.
   * This is reserved for generic intial handlers and not part of the registration API for custom handlers.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   * @private
   */
  _initial (event, entity, handler) {
    this._handlers.initial.use(event, entity, handler)

    return this
  }

  /**
   * Add a before handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  before (event, entity, handler) {
    this._handlers.before.use(event, entity, handler)

    return this
  }

  /**
   * Replace an on handler for a specific event type and entity.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  on (event, entity, handler) {
    // Support for DAOs from Cloud SDK
    if (entity && typeof entity === 'function' && '_entityName' in entity) {
      entity = entity._entityName
    }
    // If we are called with a view, fetch an underlying entity which is exposed by this service
    let d = this.model.definitions[entity]
    for (;;) {
      if (!d) break
      if (!d.name || !d.name.startsWith) break
      if (d.name.startsWith(this.name)) {
        entity = d.name
        break
      }
      d = this.model.definitions[d.source]
    }

    this._handlers.on.use(event, entity, handler)

    return this
  }

  /**
   * Add an after handler for a specific event type and entity. N handlers per type and entity can be registered.
   * In case an arrow function with '(each) =>' is used for the event handler an iterator for the result set will be added automatically.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  after (event, entity, handler) {
    this._handlers.after.use(event, entity, handler)

    return this
  }

  emit (...args) {
    this._messagingService.emit(...args)
    return this
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   * @returns {Service}
   */
  reject (...args) {
    this._handlers.reject.use(...args)

    return this
  }

  /**
   * Process an event from any adapter/channel.
   * @param {Object} context
   * @returns {Promise<Array>}
   */
  async processEvent (context) {
    if (this._handlers.reject.has(context.event, context.target)) {
      throw getError(405)
    }

    this._addError(context)
    this._addReject(context)
    this._addReply(context)
    if (MOD.includes(context.event)) {
      filterReadOnly(context)
    }
    this._addRunIfPrimarySessionExists(context)
    this._addDiffIfNeeded(context)
    if (context.run && (context.event === 'UPDATE' || context.event === 'PUT')) {
      try {
        await this._addPartialPersistentState(context)
      } catch (e) {}
    }
    if (context.target && MOD.includes(context.event)) {
      await this._addDefaultValuesAndKeys(context)
    }
    this._addLogger(context)

    // validate associations for deep insert
    flattenDeepToOneAssociations(context, this.model)

    let result

    try {
      result = this._storeDataOperations(
        context.event,
        context,
        await this._actionsFunctionsHandlers(context.event, context)
      )
    } catch (err) {
      await this._commitRollback('ROLLBACK', context, this._storeDataOperations(context.event, context, err))

      throw err
    }

    return this._commitRollback('COMMIT', context, result)
  }

  /**
   * Check for registered handlers.
   * Execute in sequence before, on, after, beforeCommit, commit, onCommit.
   * @param {string} event
   * @param {Object} context
   * @private
   */
  async _actionsFunctionsHandlers (event, context) {
    await this._handlers.initial.executeHandlerIfListed(event, context)
    await this._handlers.before.executeHandlerIfListed(event, context)
    const result =
      'results' in context ? context.results : await this._handlers.on.executeHandlerIfListed(event, context)
    return this._handlers.after.executeHandlerIfListed(event, context, result)
  }

  async _commitRollback (command, context, result) {
    if (context._.shared.doNotFinishTransaction === undefined) {
      await this._executeFinishTransactionHandlers(command, context)
    }

    return result
  }

  async _destroyConnections (context) {
    if (context._.shared.connections && cds.db) {
      // F.U.B.A.R. we need to destroy the client if one is left
      const destroys = []

      for (const [session, transaction] of context._.shared.connections) {
        if (transaction.client) {
          destroys.push(session.destroy(transaction.client))
        }
      }

      if (destroys.length) {
        await Promise.all(destroys)
      }

      delete context._.shared.connections
      delete context.run
    }
  }

  async _executeFinishTransactionHandlers (command, context, dataOperations) {
    dataOperations = dataOperations || context._.shared.dataOperations || []
    delete context._.shared.dataOperations
    delete context.results
    delete context.rejected

    try {
      await this._beforeEndTransactionBlock(command, context._, dataOperations)
      await this._handlers.on.executeHandlerIfListed(command, context)
    } catch (commandErr) {
      if (command === 'ROLLBACK') {
        this._destroyConnections(context)
      } else if (command === 'COMMIT') {
        await this._executeFinishTransactionHandlers('ROLLBACK', context, dataOperations)
      }

      throw commandErr
    }

    await this._afterEndTransactionBlock(command, true, context._, dataOperations)

    // Remove, as the next batch group will have its own context
    delete context._.shared.dataOperations
  }

  _addLogger (context) {
    context.log = this.logger
  }

  _addError (context) {
    /**
     * Errors are not thrown. Instead they are collected in the array context.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-server, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     * @param {String} [target] - Property of entity to which the error relates (e. g. `name` or a navigation path).
     */
    context.error = (code, err, target) => {
      context.errors = context.errors || []

      const error = getError(code, err, target)
      context.errors.push(error)

      return error
    }
  }

  _addReject (context) {
    /**
     * Reject is not thrown. Instead the error is stored at context.rejected.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-server, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     * @param {String} [target] - Property of entity to which the error relates (e. g. `name` or a navigation path).
     */
    context.reject = (code, err, target) => {
      context.rejected = getError(code, err, target)
    }
  }

  _addReply (context) {
    context.reply = results => {
      context.results = results
    }
  }

  _createSelectColumnsForDelete (entity) {
    const columns = []
    for (const element of Object.values(entity.elements)) {
      if (element.type === 'cds.Composition') {
        columns.push({
          ref: [element.name],
          expand: this._createSelectColumnsForDelete(element._target)
        })
      } else if (element.type !== 'cds.Association' && !DRAFT_COLUMNS.includes(element.name)) {
        columns.push({ ref: [element.name] })
      }
    }

    return columns
  }

  _createWhereCondition (entity, data) {
    return Object.keys(entity.keys).reduce((prev, curr) => {
      if (!DRAFT_COLUMNS.includes(curr)) {
        prev[curr] = data[curr]
      }

      return prev
    }, {})
  }

  async _calculateDiff (context) {
    const {
      data,
      event,
      run,
      statements: { SELECT },
      target
    } = context

    if (event === 'CREATE') {
      return compareJson(data, undefined, target)
    }

    if (event === 'DELETE') {
      return run(
        SELECT.from(target)
          .columns(this._createSelectColumnsForDelete(target))
          .where(this._createWhereCondition(target, data))
      ).then(dbState => {
        // event === 'DELETE'
        return compareJson(undefined, dbState, target)
      })
    }

    if (event === 'UPDATE' || event === 'PUT') {
      if (context.run) {
        try {
          await this._addPartialPersistentState(context)
        } catch (e) {}
      }
      return compareJson(data, context._.partialPersistentState, target)
    }
  }

  async _addDefaultValuesAndKeys (context) {
    const diff = await context.diff()
    fillDataDeep(this.model.definitions, context.data, context.target, diff, context.method, context.user)
  }

  async _addPartialPersistentState (context) {
    const deepUpdateData = await selectDeepUpdateData(this.model.definitions, context.query, context.run, context, true)
    context._.partialPersistentState = deepUpdateData
  }

  _addDiffIfNeeded (context) {
    if (MOD.includes(context.event) || context.event === 'DELETE') {
      const that = this
      let diff
      /**
       * Function to retrieve the difference from db state.
       * Works for deep documents using compositions.
       *
       * Caches the difference after the first use.
       *
       * Output format is:
       * {
       *  type: 'update',
       *  entity: 'entityName',
       *  keys: { ID: 1 },
       *  values: {
       *    old: 'A',
       *    new: 'B'
       *   }
       * }
       */
      context.diff = function () {
        // no arrow function used on purpose
        // `this` will point to the new context of local client
        if (diff) {
          return Promise.resolve(diff)
        }

        return that._calculateDiff(this).then(calculatedDiff => {
          diff = calculatedDiff
          return calculatedDiff
        })
      }
    }
  }

  /**
   * Track the general event as commit event.
   * @param event
   * @param context
   * @param result
   * @private
   */
  _storeDataOperations (event, context, result) {
    context._.shared.dataOperations = context._.shared.dataOperations || []

    // Dont add underscore yet
    const dataOperation = {
      get query () {
        return context.query
      },
      target: context.target,
      data: context.data,
      user: context.user,
      attr: context.attr,
      // Event is not required by handler, but is useful for the app developer
      event: event
    }

    if (event === 'READ') {
      dataOperation.result = result
    } else {
      // Might be undefined; TODO: an API to set it.
      dataOperation.oldData = context._oldData

      // Lazy constructing of the diff
      Object.defineProperty(dataOperation, 'diff', {
        configurable: true,
        get: function () {
          const diff = getDiff(event, this.oldData, this.data)
          Object.defineProperty(dataOperation, 'diff', { value: diff })

          return diff
        }
      })
    }

    context._.shared.dataOperations.push(dataOperation)

    return result
  }

  _beforeEndTransactionBlock (command, _, dataOperations) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      handlers.push(this._handlers.before.executeHandlerIfListed(command, Object.assign(dataOperation, { _ })))
    }

    return all(handlers)
  }

  _afterEndTransactionBlock (command, success, _, dataOperations) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      dataOperation.success = success

      handlers.push(this._handlers.after.executeHandlerIfListed(command, Object.assign(dataOperation, { _ })))
    }

    return all(handlers)
  }

  _addRunIfPrimarySessionExists (context) {
    // Add the function so that the connection can be released in case of errors in complex scenarios like OData batch
    if (context._.shared.doNotFinishTransaction && !context._.shared.endTransactionIfConnected) {
      // Wrap to easily maintain the scope of this
      context._.shared.endTransactionIfConnected = (...args) => {
        return this._executeFinishTransactionHandlers(...args)
      }
    }

    // cds.connect() has not been used yet
    if (!cds.db) {
      return
    }

    context.run = (...args) => {
      if (context._ && context._.streaming) {
        return cds.db.stream(args[0], args[1], context)
      }

      if (this._hasNoSideEffect(context)) {
        return cds.db.run(args[0], args[1], context)
      }

      const tx = cds.db.transaction(context)
      return tx.run(...args)
    }
  }

  _hasNoSideEffect (context) {
    // Known list of side effects
    if (CUD_DRAFT.includes(context.event)) {
      return false
    }

    // Shared context or OData atomicity
    if (context._.shared.doNotFinishTransaction) {
      return false
    }

    if (context.event === 'READ') {
      return true
    }

    // Unbound actions/functions
    if (!context.target && this.model.definitions[context.event]) {
      return this.model.definitions[context.event].kind === 'function'
    }

    // Bound actions/functions
    if (
      this.model.definitions[context.target.name] &&
      this.model.definitions[context.target.name].actions &&
      this.model.definitions[context.target.name].actions[context.event]
    ) {
      return this.model.definitions[context.target.name].actions[context.event].kind === 'function'
    }

    return false
  }
}

module.exports = Service
