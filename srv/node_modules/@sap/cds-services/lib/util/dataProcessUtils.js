const { all } = require('../util/thenable')
const generateUUID = require('@sap/cds-foss')('uuid/v4')
const getAnnotatedElements = require('../adapter/utils/getAnnotatedElements')

const { DRAFT_COLUMNS } = require('../services/utils/constants')
const { getDraftCompositionTree } = require('../services/utils/compositionTree')

// Ignores associations/compositions
const unwrapComplexTypes = (target, data) => {
  if (Array.isArray(data)) {
    return data.map(partialData => unwrapComplexTypes(target, partialData))
  }

  const clonedObject = {}
  for (const key in data) {
    const subObj = data[key]
    if (
      typeof subObj === 'object' &&
      !Array.isArray(subObj) &&
      subObj !== null &&
      !Buffer.isBuffer(subObj) &&
      !target.elements[key]
    ) {
      for (const subKey in subObj) {
        clonedObject[`${key}_${subKey}`] = data[key][subKey]
      }
    } else {
      clonedObject[key] = data[key]
    }
  }
  return clonedObject
}

const _diffEntryFitsToEntry = (entity, diffEntry, entry) => {
  for (const elementName in entity.elements) {
    const element = entity.elements[elementName]
    if (
      !element.is2one &&
      !element.is2many &&
      diffEntry[elementName] &&
      entry[elementName] !== diffEntry[elementName]
    ) {
      return false
    }
  }
  return true
}

const processDeep = (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    processDeep(callbackFn, [data], entity, skipRoot, isRoot)
    return
  }

  data.forEach(entry => {
    if (!(skipRoot && isRoot)) {
      callbackFn(entry, entity, isRoot, skipRoot)
    }

    Object.keys(entity.elements || {}).forEach(key => {
      const element = entity.elements[key]

      if (element.type === 'cds.Composition' && entry[element.name]) {
        const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]
        const subEntity = element._target
        processDeep(callbackFn, subData, subEntity, false, false)
      }
    })
  })
}

const _deepProcessWithDiffComposition = ({ entry, element, compositionTree, diffForData, callbackFn }) => {
  const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]
  const subEntity = element._target
  const compositionElement = compositionTree.compositionElements.find(({ name }) => name === element.name)
  // It could make sense to use the `propagateKeys` function from the compositionTree to
  // transfer all foreign keys. However, this currently breaks integrity checks.
  // propagateKeys(subEntity, compositionElement, entry, subData)
  const diffForSubData = diffForData && diffForData[element.name]
  if (diffForSubData) {
    processDeepWithDiff({
      callbackFn,
      data: subData,
      entity: subEntity,
      isRoot: false,
      skipRoot: false,
      diff: diffForSubData,
      compositionTree: compositionElement
    })
  }
}

const processDeepWithDiff = ({ callbackFn, data, entity, skipRoot, isRoot, diff, compositionTree }) => {
  if (!Array.isArray(data)) {
    processDeepWithDiff({ callbackFn, data: [data], entity, skipRoot, isRoot, diff, compositionTree })
    return
  }

  data.forEach(entry => {
    const diffForData =
      diff && Array.isArray(diff) ? diff.find(diffEntry => _diffEntryFitsToEntry(entity, diffEntry, entry)) : diff
    if (!(skipRoot && isRoot)) {
      callbackFn(entry, entity, isRoot, skipRoot, diffForData, compositionTree)
    }

    Object.keys(entity.elements || {}).forEach(key => {
      const element = entity.elements[key]

      if (element.type === 'cds.Composition' && entry[element.name]) {
        _deepProcessWithDiffComposition({ entry, element, compositionTree, diffForData, callbackFn })
      }
    })
  })
}

const _deeperElements = (callbackFn, entry, elements = {}) => {
  return Object.keys(elements).map(async key => {
    const element = elements[key]

    if (element.type === 'cds.Composition' && entry[element.name]) {
      const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]

      return processDeepAsync(callbackFn, subData, element._target, false, false)
    }
  })
}

const processDeepAsync = async (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    return processDeepAsync(callbackFn, [data], entity, skipRoot, isRoot)
  }

  const deep = data.map(async entry => {
    if (!(skipRoot && isRoot)) {
      await callbackFn(entry, entity, isRoot)
    }

    return all(_deeperElements(callbackFn, entry, entity.elements))
  })

  return all(deep)
}

const _fillAnnotatedValues = (annotatedColumns, data) => {
  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }
}

const _generateUUIDsAndAddDefaults = (elements, data, diff, compositionTree) => {
  const customBackLinks = compositionTree && compositionTree.customBackLinks
  const entityKeys = (customBackLinks || []).map(customBackLink => customBackLink.entityKey)
  for (const column of Object.keys(elements)) {
    const col = elements[column]
    if (col.key && col.type === 'cds.UUID' && data[column] === undefined && !entityKeys.includes(column)) {
      data[column] = generateUUID()
      if (diff) {
        diff[column] = data[column]
      }
    } else if (col.default !== undefined && data[col.name] === undefined && !DRAFT_COLUMNS.includes(column)) {
      data[col.name] = 'val' in col.default ? col.default.val : col.default
    }
  }
}

/**
 * This method adds default values and annotated values to data for elements not having default values, also adds UUID keys if not given.
 * @private
 */
const fillData = (data, entity, diff, compositionTree, method, user, date) => {
  if (diff && diff._op === 'update') {
    const annotatedColumns = getAnnotatedElements('update', entity, user, date)
    _fillAnnotatedValues(annotatedColumns, data)
  } else if (!diff || diff._op === 'create') {
    const annotatedColumns = getAnnotatedElements('insert', entity, user, date)
    _fillAnnotatedValues(annotatedColumns, data)
    const elements = entity.elements
    _generateUUIDsAndAddDefaults(elements, data, diff, compositionTree)
  }
}

const ensureNoDraftsSuffix = name => (name.endsWith('_drafts') ? name.slice(0, -7) : name)

const fillDataDeep = (definitions, data, entity, diff, method, user, date = new Date()) => {
  const compositionTree = getDraftCompositionTree(definitions, ensureNoDraftsSuffix(entity.name), false, false)
  processDeepWithDiff({
    callbackFn: (data, entity, _isRoot, _skipRoot, diff, compositionTree) => {
      fillData(data, entity, diff, compositionTree, method, user, date)
    },
    data,
    entity,
    isRoot: false,
    skipRoot: false,
    diff,
    compositionTree
  })
}

module.exports = {
  unwrapComplexTypes,
  processDeep,
  processDeepAsync,
  fillData,
  fillDataDeep
}
