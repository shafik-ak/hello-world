const _isStandardError = err => {
  return (
    err instanceof TypeError ||
    err instanceof ReferenceError ||
    err instanceof SyntaxError ||
    err instanceof RangeError ||
    err instanceof URIError
  )
}

const _isInternalServerError = err => {
  return !err.statusCode || err.statusCode === 500
}

const _beautifyMessage = msg => (msg.endsWith('.') ? msg : `${msg}.`)

const _buildRootCauseMessage = (message, rootCause) => {
  if (rootCause) {
    message = `${_beautifyMessage(message)} ${_beautifyMessage(rootCause.message)}`

    if (typeof rootCause.getRootCause === 'function') {
      message = _buildRootCauseMessage(message, rootCause.getRootCause())
    }
  }

  return message
}

/**
 * Custom error handler.
 * Crashes the node instance, if not deactivated.
 * @param {Boolean} crashOnError
 * @param crashOnError
 * @return {Function}
 */
const getErrorHandler = (crashOnError = true) => {
  return (req, res, next, err) => {
    if (_isStandardError(err) && crashOnError) {
      // Throwing async will circumvent the odata-v4 catch and crash the Node.js instance.
      setImmediate(() => {
        throw err
      })

      return
    }

    if (typeof err.getRootCause !== 'function') {
      if (_isInternalServerError(err)) {
        if (!err.hasOwnProperty('statusCode')) {
          err.statusCode = 500
        }
        err.code = `${err.statusCode}`
        if (process.env.NODE_ENV === 'production') {
          err.message = 'Internal Server Error'
        }
      } else {
        // overwrite error if there is no custom error flag and only if it is not an internal server error
        err.code = `${err.code || err.statusCode}`
      }
    } else {
      err.message = _buildRootCauseMessage(err.message, err.getRootCause())
    }

    next(null, err)
  }
}

module.exports = getErrorHandler
