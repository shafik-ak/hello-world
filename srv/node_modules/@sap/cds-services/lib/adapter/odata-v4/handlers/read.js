const {
  QueryOptions,
  Components: { DATA_READ_HANDLER },
  uri: {
    UriResource: {
      ResourceKind: { BOUND_FUNCTION, COUNT, FUNCTION_IMPORT, NAVIGATION_TO_ONE, VALUE }
    }
  }
} = require('@sap/odata-server')

const DelayedEmitter = require('../../utils/DelayedEmitter')
const getError = require('../../../util/getError')
const OdataContext = require('../utils/OdataContext')
const setSapMessageHeader = require('../utils/sap-message-header')
const { isCustomOperation, maxPageSize, skipToken } = require('../utils/request')
const { toODataResult } = require('../utils/event')
const { validateResourcePath } = require('../utils/request')
const { isStreaming, getContentType } = require('../utils/stream')

/**
 * Checks whether a bound function or function import is invoked.
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a function is invoked, else false.
 * @private
 */
const _isFunction = segments => [BOUND_FUNCTION, FUNCTION_IMPORT].includes(segments[segments.length - 1].getKind())

/**
 * Check which type needs to be returned. If the result is not of this type, convert.
 * @param {Object} lastSegment
 * @param {*} result
 * @returns {string|Object}
 * @private
 */
const _convertResult = (lastSegment, result) => {
  if (!Array.isArray(result) && lastSegment.isCollection()) {
    return toODataResult([result])
  }

  if (Array.isArray(result) && !lastSegment.isCollection()) {
    return toODataResult(result[0])
  }

  return toODataResult(result)
}

/**
 * Invoke a function.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _invokeFunction = (service, context, segments) => {
  const lastSegment = segments[segments.length - 1]
  return service.processEvent(context).then(result => {
    return _convertResult(lastSegment, result)
  })
}

/**
 * Checks whether a count of entities is requested
 * (not count embedded into collection).
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a count of entities is requested, else false.
 * @private
 */
const _isCount = segments => {
  return segments[segments.length - 1].getKind() === COUNT
}

const _getContext = (readContext, shareContext) => {
  if (shareContext) {
    const countContext = Object.assign(Object.create(DelayedEmitter.prototype), readContext)

    const atomicityGroupId = countContext._.odataReq.getAtomicityGroupId()
    if (atomicityGroupId) {
      countContext.setStore(countContext._.shared.eventEmitterOfAtomicityGroup.get(atomicityGroupId))
    }

    return countContext
  }

  return readContext
}

/**
 * Get the count by using the general READ CQN and alter it to a COUNT query.
 * @param {Object} service
 * @param {Object} readContext
 * @param {boolean} shareContext
 * @return {Promise}
 * @private
 */
const _getCount = (service, readContext, shareContext = false) => {
  // Copy CQN including from and where and changing columns
  const select = readContext.statements.SELECT.from(readContext.query.SELECT.from, [{ 'COUNT(1)': 'counted' }])

  if (readContext.query.SELECT.where) {
    select.SELECT.where = readContext.query.SELECT.where
  }

  const context = _getContext(readContext, shareContext)

  // remove as Object.defineProperty would cause a conflict
  delete context.query

  // Define new CQN
  context.query = select

  return (
    service
      .processEvent(context)
      // Transform into scalar result
      .then(result => {
        return result[0] && result[0].counted ? result[0].counted : 0
      })
  )
}

/**
 * Checks whether a collection of entities or a single entity is requested.
 * Returns false in case of a custom operation.
 * @returns {boolean} - True if a collection of entities is requested, else false.
 * @private
 */
const _isCollection = segments => {
  const lastEntitySegment = Array.from(segments)
    .reverse()
    .find(segment => segment.getProperty() === null)
  const kind = lastEntitySegment.getKind()

  return (
    !isCustomOperation(segments) &&
    kind !== NAVIGATION_TO_ONE &&
    kind !== COUNT &&
    kind !== VALUE &&
    lastEntitySegment.getKeyPredicates().length === 0
  )
}

/**
 * Checks whether the count needs to be included in the result set as an annotation.
 * @param {Object} req - The odata-v4 request.
 * @returns {boolean}
 * @private
 */
const _checkIfCountToBeIncluded = req => {
  return req.getUriInfo().getQueryOption(QueryOptions.COUNT)
}

/**
 * Checks whether single entity via navigation-to-one is requested.
 * @returns {boolean}
 * @private
 */
const _isNavigationToOne = segments => {
  return segments[segments.length - 1].getKind() === NAVIGATION_TO_ONE
}

const _hasRedirectProperty = elements => {
  return Object.values(elements).some(val => {
    return val['@Core.IsURL']
  })
}

const _addMediaType = (key, entry, mediaType) => {
  if (mediaType) {
    if (typeof mediaType === 'object') {
      entry[`${key}@odata.mediaContentType`] = entry[Object.values(mediaType)[0]]
    } else {
      entry[`${key}@odata.mediaContentType`] = mediaType
    }
  }
}

const _transformRedirectProperties = (context, result) => {
  if (result.length === 0) {
    return
  }

  // optimization
  if (!_hasRedirectProperty(context.target.elements)) {
    return
  }

  for (const entry of result) {
    for (const key of Object.keys(entry)) {
      if (context.target.elements[key]['@Core.IsURL']) {
        entry[`${key}@odata.mediaReadLink`] = entry[key]
        _addMediaType(key, entry, context.target.elements[key]['@Core.MediaType'])
        delete entry[key]
      }
    }
  }
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readEntityOrProperty = (service, context, segments) => {
  return service.processEvent(context).then(result => {
    if (result.length === 0 && _isNavigationToOne(segments)) {
      return toODataResult(null)
    }

    // Reading one entity or a property of it should yield only a result length of one.
    if (result.length !== 1) {
      throw getError(404)
    }

    const index = segments[segments.length - 1].getKind() === VALUE ? 2 : 1
    const propertyElement = segments[segments.length - index].getProperty()

    if (propertyElement === null) {
      _transformRedirectProperties(context, result)
    }

    return toODataResult(propertyElement === null ? result[0] : result[0][propertyElement.getName()])
  })
}

/**
 * Read an entity collection without including the count of the total amount of entities.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionNoCount = (service, context, req) => {
  return service.processEvent(context).then(result => {
    const modifiedResult = toODataResult(result)
    const pageSize = maxPageSize(req.getUriInfo().getPathSegments())

    if (pageSize && result.length === pageSize) {
      modifiedResult['*@odata.nextLink'] = skipToken(req.getUriInfo()) + pageSize
    }

    _transformRedirectProperties(context, result)

    return modifiedResult
  })
}

/**
 * Read an entity collection and include the count count of the total amount of entities.
 * odata-v4 wants the count to be added as annotation.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionWithCount = (service, context, req) => {
  // When there is a limit, there might be need for getting the actual value
  if (context.query.SELECT.limit) {
    // Share one db client for both service request if not already batched
    let finishTransaction = false

    if (context.run && !context._.shared.doNotFinishTransaction) {
      finishTransaction = true // not in batch
      context._.shared.doNotFinishTransaction = true // still use the same pool connection for all db queries
    }

    // Request the count and collection in parallel
    return Promise.all([_readCollectionNoCount(service, context, req), _getCount(service, context, true)]).then(
      ([result, count]) => {
        result['*@odata.count'] = count

        _transformRedirectProperties(context, result)

        // End transaction block in case of non batch
        if (finishTransaction && context._.shared.endTransactionIfConnected) {
          delete context._.shared.doNotFinishTransaction // not in batch: finish transaction manually as below

          return context._.shared.endTransactionIfConnected('COMMIT', context).then(() => {
            return result
          })
        }

        return result
      }
    )
  }

  // No limit, use the length property
  return _readCollectionNoCount(service, context, req).then(result => {
    result['*@odata.count'] = result.value.length

    return result
  })
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readStream = (service, context, segments) => {
  context._.streaming = true
  return service.processEvent(context).then(result => {
    // Reading one entity or a property of it should yield only a result length of one.
    if (result.length === 0) {
      throw getError(404)
    }

    const streamObj = result[0]
    const stream = streamObj.value

    if (stream) {
      stream.on('error', () => {
        stream.removeAllListeners('error')
        // stream.destroy() does not end stream in node 10 and 12
        stream.push(null)
      })
    }

    return getContentType(segments, service.name, service.model.definitions, context).then(contentType => {
      if (contentType) {
        streamObj['*@odata.mediaContentType'] = contentType
      }

      return streamObj
    })
  })
}

/**
 * Depending on the read request segments, create one ore more reading service request.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readAndTransform = (service, context, req) => {
  const segments = req.getUriInfo().getPathSegments()

  if (_isFunction(segments)) {
    return _invokeFunction(service, context, segments)
  }

  // Scalar count is requested
  if (_isCount(segments)) {
    return _getCount(service, context).then(result => {
      return toODataResult(result)
    })
  }

  if (_isCollection(segments)) {
    if (_checkIfCountToBeIncluded(req)) {
      return _readCollectionWithCount(service, context, req)
    }

    return _readCollectionNoCount(service, context, req)
  }

  if (isStreaming(segments)) {
    return _readStream(service, context, segments)
  }

  return _readEntityOrProperty(service, context, segments)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * If an entity collection is read, it calls next with result as an Array with all entities of the collection.
 * If a count of the entities in the collection is requested, it uses number of the entities as a Number value.
 * If an single entity is read, it uses the entity as an object.
 * If a property of a single entity is requested (e.g. /Books(1)/name), it unwraps the property from the result.
 * If the single entity to be read does not exist, calls next with error to return a 404.
 * In all other failure cases it calls next with error to return a 500.
 *
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const read = (service, options) => {
  return (req, res, next) => {
    // const incomingReq = req.getIncomingRequest()
    // if (incomingReq && incomingReq.performanceMeasurement) {
    //   incomingReq.performanceMeasurement.performance.mark(`${incomingReq.performanceMeasurement.uuid} ODataIn End`)
    //   incomingReq.performanceMeasurement.performance.measure(
    //     `${incomingReq.performanceMeasurement.uuid} 1 ODataIn`,
    //     `${incomingReq.performanceMeasurement.uuid} ODataIn Start`,
    //     `${incomingReq.performanceMeasurement.uuid} ODataIn End`
    //   )
    // }
    // End here if length is greater then allowed
    validateResourcePath(req, options, service.model)

    const context = new OdataContext(DATA_READ_HANDLER, service, req, res, true)

    // Get the service result(s) and hand them over the odata-v4
    _readAndTransform(service, context, req)
      .then(result => {
        if (req.getConcurrentResource() !== null) {
          const element = Object.values(context.target.elements).find(element => {
            return element['@odata.etag']
          })
          if (Array.isArray(result.value)) {
            result.value.forEach(val => {
              const etag = val[element.name]
              if (req.isConditional()) {
                req.validateEtag(etag)
              }
              val['*@odata.etag'] = etag
            })
          } else {
            const etag = result.value[element.name]
            if (req.isConditional()) {
              req.validateEtag(etag)
            }
            result.value['*@odata.etag'] = etag
          }
        }

        setSapMessageHeader(res, context._.infos)
        context.emit('succeeded')
        context.emit('done')
        next(null, result)
      })
      .catch(err => {
        setSapMessageHeader(res, context._.infos)
        context.emit('failed', err)
        context.emit('done')
        next(err)
      })
  }
}

module.exports = read
