const { getFeatureNotSupportedError } = require('../../../util/errors')
const { isStreaming } = require('../utils/stream')

const _removeIds = (obj, keysAndValues) => {
  const res = Object.assign({}, obj)
  for (const key in keysAndValues) {
    delete res[`${key}`]
  }

  return res
}

const _keysAndValues = segment => {
  const keysAndValues = {}
  for (const value of segment.getKeyPredicates()) {
    keysAndValues[value.getEdmRef().getName()] = value.getText()
  }
  return keysAndValues
}

const SUPPORTED_KINDS = ['NAVIGATION.TO.ONE', 'ENTITY']
/**
 * Transform odata UPDATE request into a CQN object.
 *
 * @param context - Contains request information and utility methods like statements.
 * @param req - An odata request.
 * @throws Error - If invalid segment kind provided
 * @private
 */
const updateToCQN = (context, req) => {
  const segments = req.getUriInfo().getPathSegments()
  const segment = segments[segments.length - 1]
  const streaming = isStreaming(segments)

  if (SUPPORTED_KINDS.includes(segment.getKind()) || streaming) {
    const keysAndValues = streaming ? _keysAndValues(segments[segments.length - 2]) : _keysAndValues(segment)

    const cqn = context.statements.UPDATE(context.target).set(_removeIds(context.data, keysAndValues))

    for (const key in keysAndValues) {
      cqn.where(key, keysAndValues[key])
    }

    return cqn
  }

  throw getFeatureNotSupportedError(`UPDATE of kind "${segment.getKind()}"`)
}

module.exports = updateToCQN
