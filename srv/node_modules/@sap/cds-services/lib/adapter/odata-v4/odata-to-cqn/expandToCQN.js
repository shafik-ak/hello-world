const { SELECT } = require('../../../cds').ql
const {
  QueryOptions,
  edm: { EdmTypeKind }
} = require('@sap/odata-server')
const { getFeatureNotSupportedError } = require('../../../util/errors')
const orderByToCQN = require('./orderByToCQN')
const ExpressionToCQN = require('./ExpressionToCQN')

/**
 * Check if $expand=* has been used.
 *
 * @return {boolean}
 * @private
 */
const _isAll = expandItems => {
  return expandItems.some(item => {
    return item.isAll()
  })
}

/**
 * Check which element(s) of the entity has been expanded.
 *
 * @return {*}
 * @private
 */
const _getExpandItem = (isAll, expandItems, name) => {
  if (isAll) {
    return null
  }

  return expandItems.find(item => {
    return (
      item
        .getPathSegments()[0]
        .getNavigationProperty()
        .getName() === name
    )
  })
}

/**
 * Check if not supported function is used and if so, throw an error.
 *
 * @private
 */
const _notSupported = expandItem => {
  if (!expandItem) {
    return
  }

  if (expandItem.getOption(QueryOptions.COUNT)) {
    throw getFeatureNotSupportedError(`Expand with query option "${QueryOptions.COUNT}"`)
  }
  if (expandItem.getOption(QueryOptions.SEARCH)) {
    throw getFeatureNotSupportedError(`Expand with query option "${QueryOptions.SEARCH}"`)
  }
}

/**
 * No lookup at the CSN needed. Get columns from target.
 *
 * @return {Array}
 * @private
 */
const _getColumnsFromTargetType = (targetType, all = false) => {
  if (!targetType || targetType.getKind() !== EdmTypeKind.ENTITY) {
    return []
  }

  if (all) {
    return Array.from(targetType.getProperties()).map(element => ({
      ref: [element[0]]
    }))
  }

  return Array.from(targetType.getKeyPropertyRefs().keys()).map(element => ({
    ref: [element]
  }))
}

const _getInnerSelect = expandItem => {
  if (!expandItem) {
    return []
  }

  return expandItem.getOption(QueryOptions.SELECT) || []
}

/**
 * Get the selected columns and navigation paths.
 * @return {Array}
 * @private
 */
const _getSelectedElements = (expandItem, targetType) => {
  const innerSelectItems = _getInnerSelect(expandItem)

  if (innerSelectItems.length === 0 || innerSelectItems.some(item => item.isAll())) {
    return _getColumnsFromTargetType(targetType, true)
  }

  const selectedPaths = _getColumnsFromTargetType(targetType)

  for (const selectItem of innerSelectItems) {
    for (const segment of selectItem.getPathSegments()) {
      if (
        !selectedPaths.some(({ ref: [ref] }) => {
          return ref === segment.getPathSegmentIdentifier()
        })
      ) {
        selectedPaths.push({ ref: [segment.getPathSegmentIdentifier()] })
      }
    }
  }

  return selectedPaths
}

/**
 * Nested expands are inner expand items.
 *
 * @return {Array}
 * @private
 */
const _getInnerExpandItems = (reflectedEntity, maxExpandSize, expandItem, targetType) => {
  if (!expandItem || !expandItem.getOption(QueryOptions.EXPAND)) {
    return []
  }

  return expandToCQN(reflectedEntity, maxExpandSize, expandItem.getOption(QueryOptions.EXPAND), targetType)
}

const _limit = (item, rows, offset, maxExpandSize) => {
  item.limit = {
    rows: { val: rows },
    offset: { val: offset }
  }

  if (item.limit.rows.val > maxExpandSize) {
    throw getFeatureNotSupportedError(`Query option "${QueryOptions.TOP} > ${maxExpandSize}"`)
  }
}

const _filter = (item, expression) => {
  if (!expression) {
    return
  }

  item.where = SELECT.from('a').where(new ExpressionToCQN().parse(expression, expression.getOperator())).SELECT.where
}

const _getItemCQN = (reflectedEntity, maxExpandSize, name, navigationProperty, expandItem) => {
  _notSupported(expandItem)

  const targetType = navigationProperty.getEntityType()
  const relatedEntity = reflectedEntity.elements[name]._target
  const item = {
    ref: [name],
    expand: _getSelectedElements(expandItem, targetType)
  }

  item.expand.push(..._getInnerExpandItems(relatedEntity, maxExpandSize, expandItem, targetType))

  if (!expandItem) {
    _limit(item, maxExpandSize, 0, maxExpandSize)
    return item
  }

  orderByToCQN(relatedEntity, item, expandItem.getOption(QueryOptions.ORDERBY))
  _limit(
    item,
    expandItem.getOption(QueryOptions.TOP) || maxExpandSize,
    expandItem.getOption(QueryOptions.SKIP) || 0,
    maxExpandSize
  )
  _filter(item, expandItem.getOption(QueryOptions.FILTER))

  return item
}
/**
 * Convert odata-v4 expand to into argument for query API.
 * @param maxExpandSize
 * @param expandItems
 * @param type
 * @return {Array}
 */
const expandToCQN = (reflectedEntity, maxExpandSize, expandItems, type) => {
  const allElements = []
  const isAll = _isAll(expandItems)

  for (const [name, navigationProperty] of type.getNavigationProperties()) {
    const expandItem = _getExpandItem(isAll, expandItems, name)

    if (isAll || expandItem) {
      allElements.push(_getItemCQN(reflectedEntity, maxExpandSize, name, navigationProperty, expandItem))
    }
  }

  return allElements
}

module.exports = expandToCQN
