const odata = require('@sap/odata-server')
const ResourceKind = odata.uri.UriResource.ResourceKind
const TransformationKind = odata.uri.Transformation.TransformationKind
const ExpressionKind = odata.uri.Expression.ExpressionKind
const StandardMethod = odata.uri.AggregateExpression.StandardMethod

const ExpressionToCQN = require('./ExpressionToCQN')
const { getFeatureNotSupportedError } = require('../../../util/errors')

const AGGREGATION_METHODS = new Map([
  [StandardMethod.SUM, 'sum'],
  [StandardMethod.MIN, 'min'],
  [StandardMethod.MAX, 'max'],
  [StandardMethod.AVERAGE, 'avg']
])

const _getColumnName = expression => {
  if (expression.getKind() === ExpressionKind.MEMBER) {
    return expression
      .getPathSegments()[0]
      .getProperty()
      .getName()
  }
  throw getFeatureNotSupportedError(`Expression ${expression.getKind()} with query option $apply`)
}

const checkAggregateExpression = aggregateExpression => {
  if (
    aggregateExpression.getInlineAggregateExpression() ||
    aggregateExpression.getFrom().length ||
    (aggregateExpression.getPathSegments().length &&
      aggregateExpression.getPathSegments()[0].getKind() !== ResourceKind.COUNT)
  ) {
    throw getFeatureNotSupportedError('Only simple aggregate expressions are supported with query option $apply')
  }
}

const _addAggregation = aggregateExpression => {
  const columnName = _getColumnName(aggregateExpression.getExpression())
  const method = AGGREGATION_METHODS.get(aggregateExpression.getStandardMethod())
  const aggregation = `${method}(${columnName})`
  const alias = aggregateExpression.getAlias()
  if (alias) {
    const column = {}
    column[aggregation] = alias
    return column
  } else {
    return aggregation
  }
}

const _addCount = aggregateExpression => {
  const alias = aggregateExpression.getAlias()
  if (alias) {
    return { 'count(1)': alias }
  } else {
    return 'count(1)'
  }
}

const _createColumnsForAggregateExpressions = aggregateExpressions => {
  let columns = []
  for (const aggregateExpression of aggregateExpressions) {
    checkAggregateExpression(aggregateExpression)
    if (aggregateExpression.getExpression() && aggregateExpression.getStandardMethod() !== null) {
      columns.push(_addAggregation(aggregateExpression))
    } else {
      // checked in checkAggregateExpression to be ResourceKind.COUNT
      columns.push(_addCount(aggregateExpression))
    }
  }
  return columns
}

const _createNavGroupBy = pathSegments => {
  let name = pathSegments[0].getNavigationProperty().getName()
  for (let i = 1; i < pathSegments.length; i++) {
    name += pathSegments[i].getProperty()
      ? '.' + pathSegments[i].getProperty().getName()
      : '.' + pathSegments[i].getNavigationProperty().getName()
  }
  return name
}

const _addAggregationToResult = (transformation, result) => {
  const expressions = transformation.getExpressions()

  if (expressions.length) {
    result.aggregations = result.aggregations || []
    result.aggregations.push(..._createColumnsForAggregateExpressions(expressions))
  }
}

/**
 * Add odata apply to a CQN object.
 *
 * @param {string} transformations - odata-v4 transformation object
 * @param {object} entity - csn entity targeted by the request
 * @param {object} model - reflected model
 *
 * @private
 */
const applyToCQN = (transformations, entity, model) => {
  const res = {}
  for (const transformation of transformations) {
    switch (transformation.getKind()) {
      case TransformationKind.GROUP_BY:
        res.groupBy = []
        if (transformation.getTransformations().length) {
          _addAggregationToResult(transformation.getTransformations()[0], res)
        }
        for (const item of transformation.getGroupByItems()) {
          if (item.getPathSegments()[0].getProperty()) {
            const name = item
              .getPathSegments()[0]
              .getProperty()
              .getName()
            res.groupBy.push(name)
          } else if (item.getPathSegments()[0].getNavigationProperty()) {
            res.groupBy.push(_createNavGroupBy(item.getPathSegments()))
          }
        }
        break
      case TransformationKind.AGGREGATE:
        _addAggregationToResult(transformation, res)
        break
      case TransformationKind.FILTER:
        res.filter = new ExpressionToCQN(entity, model).parse(transformation.getFilter())
        break
      default:
        throw getFeatureNotSupportedError(`Transformation "${transformation.getKind()}" with query option $apply`)
    }
  }

  return res
}

module.exports = applyToCQN
