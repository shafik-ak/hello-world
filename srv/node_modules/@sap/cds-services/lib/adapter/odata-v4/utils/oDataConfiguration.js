const DEFAULT_MAX_PAGE_SIZE = 1000
const _getNameSpace = edm => {
  const properties = Object.getOwnPropertyNames(edm)

  let namespace
  properties.forEach(element => {
    if (typeof edm[element] === 'object') {
      namespace = element
    }
  })
  return namespace
}

const _getEntitySets = (edm, namespace) => {
  const entities = []
  const entityContainerName = edm.$EntityContainer
  if (entityContainerName) {
    const entityContainer = edm[namespace][entityContainerName.replace(`${namespace}.`, '')]
    if (entityContainer && entityContainer.$Kind === 'EntityContainer') {
      const containerContent = Object.getOwnPropertyNames(entityContainer)
      containerContent.forEach(element => {
        if (entityContainer[element].$Collection) {
          entities.push(element)
        }
      })
    }
  }
  return entities
}

const _getConcurrent = (namespace, element, csn) => {
  return Object.values(csn.definitions[`${namespace}.${element}`].elements).some(val => {
    return val['@odata.etag']
  })
}

const oDataConfiguration = (edm, csn, options = {}) => {
  const namespace = _getNameSpace(edm)
  const entitySets = _getEntitySets(edm, namespace)

  if (entitySets.length === 0) {
    return
  }

  if (options.maxPageSize === false) {
    return
  }

  const configuration = {}

  entitySets.forEach(element => {
    configuration[element] = {
      maxPageSize: options.maxPageSize || DEFAULT_MAX_PAGE_SIZE,
      isConcurrent: _getConcurrent(namespace, element, csn)
    }
  })

  return {
    [namespace]: configuration
  }
}

module.exports = oDataConfiguration
