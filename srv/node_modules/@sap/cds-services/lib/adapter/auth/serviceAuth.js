const getError = require('../../util/getError')
const { getIpFromRequest, getUserFromRequest } = require('../../services/utils/clientFromRequest')
const getAnnotations = require('../utils/getAnnotations')

const _getScopes = req => {
  if (!req.authInfo) {
    req.authInfo = {
      scopes: ['any']
    }
  }

  if (!req.authInfo.scopes) {
    req.authInfo.scopes = ['any']
  } else if (!req.authInfo.scopes.includes('any')) {
    req.authInfo.scopes.push('any')
  }

  if (req.authInfo.scopes.includes('openid')) {
    if (!req.authInfo.scopes.includes('authenticated-user')) {
      req.authInfo.scopes.push('authenticated-user')
    }

    if (!req.authInfo.scopes.includes('identified-user')) {
      req.authInfo.scopes.push('identified-user')
    }
  }

  if (req.authInfo.grantType === 'client_credentials' || req.authInfo.grantType === 'client_x509') {
    if (!req.authInfo.scopes.includes('system-user')) {
      req.authInfo.scopes.push('system-user')
    }
  }

  return req.authInfo.scopes
}

const _getRequestMethod = req => {
  switch (req.method) {
    case 'GET':
    case 'HEAD':
      return 'READ'
    case 'PUT':
    case 'PATCH':
      return 'UPDATE'
    case 'POST':
      return 'CREATE'
    default:
      return req.method
  }
}

const _auditLog = (auditLogger, req) => {
  const ip = getIpFromRequest(req)
  const user = req.user ? req.user.id : getUserFromRequest(req) || 'anonymous'
  if (req.authInfo && req.authInfo.identityZone) {
    auditLogger.logMissingPermissions({ user, ip, tenant: req.authInfo.identityZone })
  } else {
    auditLogger.logMissingPermissions({ user, ip })
  }
}

const includesRequiredScopes = (requiredScopes, availableScopes, xsappname) => {
  return requiredScopes.some(
    required => availableScopes.includes(required) || availableScopes.includes(`${xsappname}.${required}`)
  )
}

const _getProdError = () => {
  if (process.env.NODE_ENV === 'production') {
    const errorPr = new Error('Internal Server Error')
    errorPr.statusCode = 500
    return errorPr
  }
}

/**
 * Get generic authorization handler on service level.
 * The handler to be registered as an express middleware handler after the proxy API is generated.
 *
 * @param service
 * @param auditLogger - the audit logger object
 * @returns {function(*, *, *)}
 *
 */
const getAuthServiceHandler = (service, auditLogger) => {
  const annotations = getAnnotations(service)

  if (Object.keys(annotations).length) {
    let requiredScopes

    return (req, res, next) => {
      try {
        const relevantAnnotations = annotations[_getRequestMethod(req)]
        if (relevantAnnotations) {
          requiredScopes = relevantAnnotations.reduce((scopes, anno) => {
            scopes.push(...anno.to)

            return scopes
          }, [])
        }

        if (!relevantAnnotations || !includesRequiredScopes(requiredScopes, _getScopes(req), req.authInfo.xsappname)) {
          _auditLog(auditLogger, req)
          next(getError(403))
          return
        }
      } catch (err) {
        console.error(`Internal Server Error in authorization adapter: ${err.message}`)
        next(_getProdError() || err)
        return
      }
      next()
    }
  }

  return (req, res, next) => {
    next()
  }
}

module.exports = getAuthServiceHandler
