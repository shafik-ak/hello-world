const getError = require('../../util/getError')
const hasPackage = require('../utils/hasPackage')
const cds = require('../../cds')

const _getBasicAuthHandler = credentials => {
  return function (user, password, done) {
    if (credentials[user] === password) {
      return done(null, { id: user })
    }

    // use this.fail() instead of done bacause of multiple strategies
    return this.fail(getError(401))
  }
}

const _basic = credentials => {
  const { BasicStrategy } = require('passport-http')
  return new BasicStrategy(_getBasicAuthHandler(credentials))
}

const _hasSecurity = (model, serviceName) => {
  const serviceDef = model.definitions[serviceName]
  if (serviceDef['@requires'] || serviceDef['@restrict']) {
    return true
  }

  const definitions = model.childrenOf(serviceName)
  return Object.values(definitions).some(definition => {
    return definition['@requires'] || definition['@restrict']
  })
}

const _jwt = uaa => {
  const JWTStrategy = require('@sap/xssec').JWTStrategy
  if (uaa && uaa.credentials) {
    return new JWTStrategy(uaa.credentials)
  }

  return new JWTStrategy(require('../../util/xsenv')('xsuaa', uaa))
}

const _mock = users => {
  const Mock = require('./Mock')
  return new Mock(users)
}

const getStrategyByName = (strategy, options, iterator) => {
  switch (strategy) {
    case 'basic':
      return _basic(
        Array.isArray(options.passport.credentials)
          ? options.passport.credentials[iterator.credentials++]
          : options.passport.credentials
      )
    case 'JWT':
      return _jwt(Array.isArray(options.uaa) ? options.uaa[iterator.uaa++] : options.uaa)
    case 'mock':
      return _mock(
        Array.isArray(options.passport.users) ? options.passport.users[iterator.users++] : options.passport.users
      )
    case 'dummy':
      return false
  }

  setImmediate(() => {
    throw new Error(`Invalid authentication strategy provided: ${JSON.stringify(options.passport.strategy)}`)
  })
}

const _getOneStrategyByName = options => {
  switch (options.passport.strategy) {
    case 'basic':
      return Array.isArray(options.passport.credentials)
        ? options.passport.credentials.map(crd => _basic(crd))
        : [_basic(options.passport.credentials)]
    case 'JWT':
      return Array.isArray(options.uaa) ? options.uaa.map(uaa => _jwt(uaa)) : [_jwt(options.uaa)]
    case 'mock':
      return Array.isArray(options.passport.users)
        ? options.passport.users.map(usr => _mock(usr))
        : [_mock(options.passport.users)]
    case 'dummy':
      return false
  }

  setImmediate(() => {
    throw new Error(`Invalid authentication strategy provided: ${JSON.stringify(options.passport.strategy)}`)
  })
}

const _getStrategy = options => {
  if (typeof options.passport.strategy === 'object' && options.passport.strategy.authenticate) {
    return [options.passport.strategy]
  }
  if (Array.isArray(options.passport.strategy)) {
    const iterator = {
      credentials: 0,
      uaa: 0,
      users: 0
    }
    const strategies = []
    for (const stg of options.passport.strategy) {
      if (stg.authenticate) {
        strategies.push(stg)
      } else {
        strategies.push(getStrategyByName(stg, options, iterator))
      }
    }

    return strategies
  }

  return _getOneStrategyByName(options)
}

const _extendOptionsFromCdsEnv = options => {
  if (cds.env && cds.env.auth && cds.env.auth.passport) {
    options.passport = cds.env.auth.passport
  }

  if (!options.uaa && cds.env && cds.env.requires && cds.env.requires.uaa) {
    options.uaa = cds.env.requires.uaa
  }
}

/**
 * In case there are security annotions and xssec is installed, auto configuration.
 * @param {Object} options
 * @param {Object} model
 * @param {String} serviceName
 * @private
 */
const _autoDetectStrategy = (options, model, serviceName) => {
  if (!_hasSecurity(model, serviceName)) {
    return
  }

  if (!hasPackage('passport')) {
    return false
  }

  _extendOptionsFromCdsEnv(options)

  if (!options.passport) {
    if (hasPackage('@sap/xssec')) {
      options.passport = { strategy: 'JWT' }
    } else if (hasPackage('passport-http')) {
      options.passport = { strategy: 'basic', credentials: {} }
    } else if (process.env.NODE_ENV !== 'production') {
      options.passport = { strategy: 'mock' }
    } else {
      options.passport = { strategy: 'dummy' }
    }
  }

  return _getStrategy(options)
}

/**
 *
 * @param {Object} options
 * @param {Object} model
 * @param {String} serviceName
 * @return {Authenticator|Passport}
 */
const _getPassport = (options, model, serviceName) => {
  const strategies = options.passport ? _getStrategy(options) : _autoDetectStrategy(options, model, serviceName)

  if (!strategies) {
    return strategies
  }

  if (strategies.length === 0) {
    return undefined
  }

  const passport = require('passport')
  const names = []
  for (let i = 0; i < strategies.length; i++) {
    const name = `${serviceName}_${i}`
    names.push(name)
    passport.use(name, strategies[i])
  }

  return { passport, names }
}

const _errorHandler = (err, req, res, next) => {
  if (err) {
    // err.status is http error code from passport
    res.status(err.statusCode || err.status || 500)
    res.send({
      error: {
        code: err.code,
        message: err.message
      }
    })

    return
  }

  next()
}

const passport = (service, app, auditLogger, options) => {
  const pass = _getPassport(options, service.model, service.name)

  if (typeof pass === 'object') {
    app.use(service.path, pass.passport.initialize())
    app.use(service.path, require('./passportAuthenticateCallback')(pass.passport, pass.names, auditLogger))
    app.use(service.path, require('./serviceAuth')(service.model.definitions[service.name], auditLogger))
    // Security annotations, but no passport
  } else if (pass === false) {
    app.use(service.path, require('./serviceAuth')(service.model.definitions[service.name], auditLogger))
  }

  app.use(service.path, _errorHandler)
}

module.exports = passport
