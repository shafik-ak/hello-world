const { getKeyValuePair } = require('../utils/key-value-utils')
const getColumns = require('../../../services/utils/columns')

const _removeKey = (obj, key) => {
  const res = Object.assign({}, obj)
  delete res[`${key}`]
  return res
}

const _cqnForCustomOperations = ({ statements: { SELECT }, target }, { customOperation, segments }) => {
  // if custom operation is unbound, query is undefined
  if (customOperation.startsWith('bound')) {
    return SELECT.from(target).where(getKeyValuePair(target, segments[1]))
  }
}

const _createToCQN = (context, parsedUrl) => {
  if (!parsedUrl.customOperation) {
    return context.statements.INSERT.into(context.target).entries(context.data)
  }

  return _cqnForCustomOperations(context, parsedUrl)
}

const _getPaging = ({ options: { maxPageSize } }, { query: { $top, $skip } }) => {
  return [Number($top) || maxPageSize, Number($skip) || 0]
}

const _readToCQN = (service, context, parsedUrl) => {
  if (!parsedUrl.customOperation) {
    const cqn = context.statements.SELECT.from(context.target, getColumns(context.target, true, true))

    if (parsedUrl.isCollection) {
      cqn.limit(..._getPaging(service, context._.req))

      // no query option for ordering supported yet
      if (parsedUrl.segments[0]['@cds.default.order']) {
        for (const defaultOrder of parsedUrl.segments[0]['@cds.default.order']) {
          cqn.orderBy(defaultOrder.by['='], defaultOrder.desc ? 'desc' : 'asc')
        }
      }

      return cqn
    }

    return cqn.where(context.data)
  }

  return _cqnForCustomOperations(context, parsedUrl)
}

const _updateToCQN = (context, parsedUrl) => {
  const key = Object.keys(context.target.keys)[0]

  if (Array.isArray(context.data)) {
    return context.data.map(data => {
      return context.statements
        .UPDATE(context.target)
        .set(_removeKey(data, key))
        .where(key, data[key])
    })
  }

  const value = parsedUrl.segments[parsedUrl.segments.length - 1]

  return context.statements
    .UPDATE(context.target)
    .set(_removeKey(context.data, key))
    .where(key, value)
}

/**
 * @param {Object} service
 * @param {Object} context
 * @param {Object} parsedUrl
 * @returns {Object}
 */
module.exports = (service, context, parsedUrl) => {
  // TODO: replace with generic solution
  switch (parsedUrl.method) {
    case 'CREATE':
      return _createToCQN(context, parsedUrl)
    case 'READ':
      return _readToCQN(service, context, parsedUrl)
    case 'UPDATE':
      return _updateToCQN(context, parsedUrl)
    case 'DELETE':
      return context.statements.DELETE.from(context.target).where(context.data)
    default:
      return {}
  }
}
