"use strict";
/*!
 * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = __importStar(require("http"));
var http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
var https = __importStar(require("https"));
var rambda_1 = require("rambda");
function getAgentConfig(destination) {
    var protocol = getProtocolOrDefault(destination);
    if (destination.proxyConfiguration || protocol === Protocol.HTTP) {
        return httpAgentConfig(destination);
    }
    else if (protocol === Protocol.HTTPS) {
        return httpsAgentConfig(destination);
    }
    else {
        throw new Error("Protocol of the provided destination (" + protocol + ") is not supported! Currently only HTTP and HTTPS are supported.");
    }
}
exports.getAgentConfig = getAgentConfig;
function httpsAgentConfig(destination) {
    return { httpsAgent: createAgent(destination, Protocol.HTTPS) };
}
function httpAgentConfig(destination) {
    return { httpAgent: createAgent(destination, Protocol.HTTP) };
}
function createAgent(destination, protocol) {
    if (!protocol) {
        protocol = getUrlProtocol(destination) || Protocol.HTTPS;
    }
    if (destination.proxyConfiguration) {
        return createProxyAgent(destination);
    }
    else if (protocol === Protocol.HTTP) {
        return createHttpAgent(destination);
    }
    else if (protocol === Protocol.HTTPS) {
        return createHttpsAgent(destination);
    }
    else {
        throw new Error("Protocol of the provided destination (" + protocol + ") is not supported! Currently only HTTP and HTTPS are supported.");
    }
}
exports.createAgent = createAgent;
function createProxyAgent(destination) {
    if (destination.isTrustingAllCertificates) {
        console.warn('The destination is configured to both use a proxy and to trust all certificates. This is currently not supported. The proxy configuration will be applied, but certificates will be validated.');
    }
    return proxyAgent(destination.proxyConfiguration.host, destination.proxyConfiguration.port);
}
function createHttpsAgent(destination) {
    if (destination.isTrustingAllCertificates) {
        console.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
    }
    var options = rambda_1.pipe(trustAllOptions(destination), certificateOptions(destination))({});
    return new https.Agent(options);
}
var trustAllOptions = function (destination) { return function (options) {
    return rambda_1.assoc('rejectUnauthorized', !destination.isTrustingAllCertificates, options);
}; };
var certificateOptions = function (destination) { return function (options) {
    if (destination.keyStoreName && destination.keyStorePassword) {
        var certificate = selectCertificate(destination);
        return __assign(__assign({}, options), { pfx: Buffer.from(certificate.content, 'base64'), passphrase: destination.keyStorePassword });
    }
    return options;
}; };
var supportedCertificateFormats = ['p12', 'pfx'];
function hasSupportedFormat(certificate) {
    return supportedCertificateFormats.includes(rambda_1.last(certificate.name.split('.')));
}
function selectCertificate(destination) {
    var certificate = destination.certificates.find(function (c) { return c.name === destination.keyStoreName; });
    if (!certificate) {
        throw Error("No certificate with name " + destination.keyStoreName + " could be found on the destination!");
    }
    if (!hasSupportedFormat(certificate)) {
        var format = rambda_1.last(certificate.name.split('.'));
        throw Error("The format of the provided certificate " + certificate.name + " is not supported. Supported formats are: " + supportedCertificateFormats.join(', ') + ". " + (['jks', 'keystore'].includes(format)
            ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12"
            : ''));
    }
    return certificate;
}
function createHttpAgent(destination) {
    if (destination.isTrustingAllCertificates) {
        console.warn('"isTrustingAllCertificates" is not available for HTTP.');
    }
    return defaultAgent(Protocol.HTTP);
}
function defaultAgent(protocol) {
    return protocol === Protocol.HTTP ? new http.Agent() : new https.Agent();
}
function proxyAgent(proxyHost, proxyPort) {
    return new http_proxy_agent_1.default("http://" + proxyHost + ":" + proxyPort);
}
exports.proxyAgent = proxyAgent;
function getProtocolOrDefault(destination) {
    var protocol = getUrlProtocol(destination);
    if (!protocol) {
        console.warn("URL of the provided destination (" + destination.url + ") has no protocol specified! Assuming HTTPS.");
        return Protocol.HTTPS;
    }
    return protocol;
}
function getUrlProtocol(destination) {
    if (destination.url) {
        var urlParts = destination.url.toLowerCase().split('://');
        if (urlParts.length > 1) {
            return urlParts[0];
        }
    }
}
exports.getUrlProtocol = getUrlProtocol;
var Protocol;
(function (Protocol) {
    Protocol["HTTP"] = "http";
    Protocol["HTTPS"] = "https";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
//# sourceMappingURL=http-agent.js.map