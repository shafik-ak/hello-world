const BaseBuilder = require('./BaseBuilder')

/**
 * FunctionBuilder is used to take a part of a CQN object as an input and to build an object representing a function
 * with SQL string and values.
 *
 */
class FunctionBuilder extends BaseBuilder {
  get ExpressionBuilder () {
    const ExpressionBuilder = require('./ExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', { value: ExpressionBuilder })
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./ReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', { value: ReferenceBuilder })
    return ReferenceBuilder
  }

  get SelectBuilder () {
    const SelectBuilder = require('./SelectBuilder')
    Object.defineProperty(this, 'SelectBuilder', { value: SelectBuilder })
    return SelectBuilder
  }

  build () {
    this._outputObj = {
      sql: [],
      values: []
    }

    this._handleFunction()

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _functionName (element) {
    return (element.ref && element.ref[0]) || element.func
  }

  _functionArgs (element) {
    return (element.ref && element.ref[1].args) || element.args
  }

  _handleSearchTerm (params) {
    let searchTerm = ''

    for (const param of params) {
      if (param.val) {
        searchTerm = `${searchTerm}${param.val.replace(/(%|\?|\*|_)/g, '\\$1')}`
      } else if (param === 'and') {
        searchTerm = `${searchTerm} `
      } else if (param === 'or') {
        searchTerm = `${searchTerm} OR `
      } else {
        // param === 'not'
        searchTerm = `${searchTerm}-`
      }
    }
    return { val: `${searchTerm}` }
  }

  _handleFunction () {
    const functionName = this._functionName(this._obj)

    let args = this._functionArgs(this._obj)
    if (functionName.toLowerCase().includes('contains')) {
      args = [args[0], this._handleSearchTerm(args.slice(1, args.length - 1)), args[args.length - 1]]
    }
    this._outputObj.sql.push(functionName, '(')
    if (typeof args === 'string') {
      this._outputObj.sql.push(args, ')')
    } else {
      this._addFunctionArgs(args)
      this._outputObj.sql.push(')')
    }
  }

  _addFunctionArgs (args) {
    const res = []
    for (const arg of args) {
      if (arg.ref) {
        const { sql, values } = new this.ReferenceBuilder(arg, this._options, this._csn).build()
        res.push(sql)
        this._outputObj.values.push(...values)
      } else if (arg.func) {
        const { sql, values } = new FunctionBuilder(arg, this._options, this._csn).build()
        res.push(sql)
        this._outputObj.values.push(...values)
      } else if (arg.SELECT) {
        const { sql, values } = new this.SelectBuilder(arg, this._options, this._csn).build(true)
        res.push(sql)
        this._outputObj.values.push(...values)
      } else if (arg.val) {
        this._outputObj.values.push(arg.val)
        res.push(this._options.placeholder)
      } else if (arg.list) {
        const { sql, values } = new this.ExpressionBuilder([arg], this._options, this._csn).build()
        res.push(sql)
        this._outputObj.values.push(...values)
      } else if (typeof arg === 'string') {
        res.push(arg)
      }
    }
    this._outputObj.sql.push(res.join(', '))
  }
}

module.exports = FunctionBuilder
