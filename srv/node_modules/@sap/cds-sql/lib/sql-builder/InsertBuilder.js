const BaseBuilder = require('./BaseBuilder')
const SelectBuilder = require('./SelectBuilder')
const getAnnotatedColumns = require('../utils/annotations')
const generateUUID = require('@sap/cds-foss')('uuid/v4')

/**
 * InsertBuilder is used to take a CQN object as an input and to build an object representing an insert operation
 * with SQL string and values to be inserted with the prepared statement.
 * The SQL object can only be built if one of the properties 'entries', 'values' or 'rows' is available.
 * @example <caption>Example of CQN </caption>
 * {
 *  INSERT = {INSERT:{
 *  into: entity | string,
 *  columns: [ ...string ],
 *  values: [ ...any ],
 *  rows: [ ...[ ...any ] ],
 *  entries: [ ...{ ...column:any } ]
 *  }}
 * }
 */
class InsertBuilder extends BaseBuilder {
  /**
   * Base constructor with additionally provided csn
   *
   * @param {object} obj
   * @param {object} options
   * @param {object} csn
   */
  constructor (obj, options, csn) {
    super(obj, options)
    this._options.typeConversion = this._options.typeConversion || new Map()
    this._csn = csn
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *    sql: 'INSERT INTO "T" ("a", "b", "c") VALUES (?, ?, ?)',
   *    values: [1, 2, '\'asd\'']
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   * Property values can be an Array of Arrays for Batch insert of multiple rows.
   */
  build () {
    this._outputObj = {
      sql: ['INSERT', 'INTO'],
      values: []
    }

    const entityName = this._into()

    // side effect: sets this.uuidKeys if found any
    this._findUuidKeys(entityName)

    this._columnIndexesToDelete = []
    const annotatedColumns = getAnnotatedColumns(entityName, this._csn)

    if (this._obj.INSERT.columns) {
      this._removeAlreadyExistingInsertAnnotatedColumnsFromMap(annotatedColumns)
      this._columns(annotatedColumns)
    }

    if (this._obj.INSERT.values || this._obj.INSERT.rows) {
      if (annotatedColumns && !this._obj.INSERT.columns) {
        // if columns not provided get indexes from csn
        this._getAnnotatedColumnIndexes(annotatedColumns)
      }

      this._values(annotatedColumns)
    } else if (this._obj.INSERT.entries && this._obj.INSERT.entries.length !== 0) {
      this._entries(annotatedColumns)
    }

    if (this._obj.INSERT.as) {
      this._as(this._obj.INSERT.as)
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _removeAlreadyExistingInsertAnnotatedColumnsFromMap (annotatedColumns) {
    if (!annotatedColumns) {
      return
    }

    for (const columnName of annotatedColumns.insertAnnotatedColumns.keys()) {
      if (this._obj.INSERT.columns && this._obj.INSERT.columns.includes(columnName)) {
        annotatedColumns.insertAnnotatedColumns.delete(columnName)
      }
    }
  }

  _into () {
    if (typeof this._obj.INSERT.into === 'string') {
      this._outputObj.sql.push(this._quoteElement(this._obj.INSERT.into))
      return this._obj.INSERT.into
    }

    this._outputObj.sql.push(this._quoteElement(this._obj.INSERT.into.name))
    return this._obj.INSERT.into.name
  }

  _as (element) {
    const { sql } = new SelectBuilder(element, this._options, this._csn).build()
    this._outputObj.sql.push(sql)
  }

  _columnsAnnotatedWithUpdateFilter (annotatedColumns) {
    const annotatedUpdateColumnNames = this._getUpdateAnnotatedColumnNames(annotatedColumns)

    this._obj.INSERT.columns.forEach((col, index) => {
      if (annotatedUpdateColumnNames.includes(col)) {
        this._columnIndexesToDelete.push(index)
      }
    })

    this._spliceArray(this._obj.INSERT.columns) // remove all annotated columns
  }

  _columnAnnotatedAdded (annotatedColumns) {
    const annotatedInsertColumnNames = this._getAnnotatedInsertColumnNames(annotatedColumns)

    if (annotatedInsertColumnNames && annotatedInsertColumnNames.length !== 0) {
      this._outputObj.sql.push(',', annotatedInsertColumnNames.map(col => this._quoteElement(col)).join(', '))
    }
  }

  _findUuidKeys (entityName) {
    const uuidKeys = []
    if (this._csn && this._csn.definitions[entityName] && this._csn.definitions[entityName].keys) {
      for (const key of Object.values(this._csn.definitions[entityName].keys)) {
        if (key.type === 'cds.UUID') {
          uuidKeys.push(key.name)
        }
      }
    }

    if (uuidKeys.length > 0) {
      this.uuidKeys = uuidKeys
    }
  }

  _columns (annotatedColumns) {
    this._outputObj.sql.push('(')

    if (annotatedColumns) {
      // filter out existing annotated update columns
      this._columnsAnnotatedWithUpdateFilter(annotatedColumns)
    }

    const insertColumns = [...this._obj.INSERT.columns.map(col => this._quoteElement(col))]

    if (this.uuidKeys) {
      for (const key of this.uuidKeys) {
        if (!this._obj.INSERT.columns.includes(key)) {
          insertColumns.unshift(this._quoteElement(key))
        }
      }
    }

    this._outputObj.sql.push(insertColumns.join(', '))

    if (annotatedColumns) {
      // add insert annotated columns
      this._columnAnnotatedAdded(annotatedColumns)
    }

    this._outputObj.sql.push(')')
  }

  _valuesAnnotatedValues (annotatedInsertColumnValues, values) {
    this._spliceArray(values) // remove all annotated

    if (annotatedInsertColumnValues.values && annotatedInsertColumnValues.values.length !== 0) {
      values.push(...annotatedInsertColumnValues.values) // add insert annotated
    }
  }

  _values (annotatedColumns) {
    let placeholderNum = 0
    const annotatedInsertColumnValues = annotatedColumns ? this._getAnnotatedInsertColumnValues(annotatedColumns) : []

    if (this._obj.INSERT.values) {
      this._outputObj.values = this._obj.INSERT.values

      placeholderNum = this._outputObj.values.length

      this._valuesAnnotatedValues(annotatedInsertColumnValues, this._outputObj.values)
    } else {
      this._outputObj.values = this._obj.INSERT.rows

      placeholderNum = this._outputObj.values[0].length

      this._outputObj.values.forEach(values => {
        this._valuesAnnotatedValues(annotatedInsertColumnValues, values)
      })
    }

    if (this.uuidKeys && this._obj.INSERT.columns) {
      for (const key of this.uuidKeys) {
        if (!this._obj.INSERT.columns.includes(key)) {
          placeholderNum += 1
          this._obj.INSERT.values
            ? this._outputObj.values.unshift(generateUUID())
            : this._outputObj.values.forEach(arr => arr.unshift(generateUUID()))
        }
      }
    }

    this._outputObj.sql.push(
      ...this._createPlaceholderString(placeholderNum, annotatedInsertColumnValues.valuesAndSQLs)
    )
  }

  _addUuidToColumns (columns, flattenColumnMap) {
    if (this.uuidKeys) {
      for (const key of this.uuidKeys) {
        if (!flattenColumnMap.get(key)) {
          columns.push(...this.uuidKeys.map(key => this._quoteElement(key)))
        }
      }
    }
  }

  /**
   * This method creates insert statement in case of multiple entries.
   * The assumption is that each entry contains exactly the same columns.
   *
   * @example:
   * [{a: {b: 1, c: 2}}, {a: {b: 2, c: 3}}, {a: {b: 3, c: 4}}]
   *
   * @private
   */
  _entries (annotatedColumns) {
    const columns = []
    const valuesArray = []
    const annotatedUpdateColumnNames = this._getUpdateAnnotatedColumnNames(annotatedColumns)
    const flattenColumnMap = this._getFlattenColumnMap(this._obj.INSERT.entries[0], annotatedUpdateColumnNames)
    const annotatedInsertColumnNames = this._getAnnotatedInsertColumnNames(annotatedColumns).filter(
      colName => !flattenColumnMap.has(colName)
    )

    const annotatedInsertColumnValues = this._getAnnotatedInsertColumnValues(
      annotatedColumns,
      annotatedInsertColumnNames
    )

    this._addUuidToColumns(columns, flattenColumnMap)
    columns.push(...flattenColumnMap.keys())

    for (const entry of this._obj.INSERT.entries) {
      const values = []

      for (const column of columns) {
        let val = entry

        if (!flattenColumnMap.get(column) && this.uuidKeys.includes(column)) {
          val = generateUUID()
        } else {
          for (const key of flattenColumnMap.get(column)) {
            val = val[key]
          }
        }

        values.push(val)
      }

      // insert values for insert annotated columns
      values.push(...annotatedInsertColumnValues.values)

      valuesArray.push(values)
    }

    // add insert annotated columns
    const placeholderNum = columns.length
    columns.push(...annotatedInsertColumnNames)

    this._outputObj.sql.push(
      ...this._entriesSqlString(columns, placeholderNum, annotatedInsertColumnValues.valuesAndSQLs)
    )
    this._outputObj.values = valuesArray
  }

  _getFlattenColumnMap (entry, annotatedUpdateColumnNames, prefix) {
    const res = new Map()

    Object.keys(entry).forEach(key => {
      const prefixKey = prefix ? `${prefix}_${key}` : key
      if (
        typeof entry[key] === 'object' &&
        entry[key] !== null &&
        !Buffer.isBuffer(entry[key]) &&
        typeof entry[key].pipe !== 'function'
      ) {
        const resInternal = this._getFlattenColumnMap(entry[key], annotatedUpdateColumnNames, prefixKey)

        Array.from(resInternal.keys()).forEach(keyInternal => {
          const arrInternal = resInternal.get(keyInternal)
          arrInternal.unshift(key)
          res.set(`${key}_${keyInternal}`, arrInternal)
        })
      } else {
        if (!annotatedUpdateColumnNames || !annotatedUpdateColumnNames.includes(prefixKey)) {
          res.set(key, [key])
        }
      }
    })

    return res
  }

  _entriesSqlString (columns, placeholderNum, valuesAndSQLs) {
    return [
      '(',
      columns.map(column => this._quoteElement(column)).join(', '),
      ')',
      ...this._createPlaceholderString(placeholderNum, valuesAndSQLs)
    ]
  }

  _createPlaceholderString (placeholderNum, valuesAndSQLs = []) {
    const placeholders = []

    for (let i = 0, length = placeholderNum - this._columnIndexesToDelete.length; i < length; i++) {
      placeholders.push(this._options.placeholder)
    }

    for (const val of valuesAndSQLs) {
      placeholders.push(val && val.sql ? val.sql : this._options.placeholder)
    }

    return ['VALUES', '(', placeholders.join(', '), ')']
  }

  _getAnnotatedColumnIndexes (annotatedColumns) {
    annotatedColumns.insertAnnotatedColumns.forEach(col => {
      if (col.indexNo) {
        this._columnIndexesToDelete.push(col.indexNo)
      }
    })
    annotatedColumns.updateAnnotatedColumns.forEach(col => {
      if (col.indexNo) {
        this._columnIndexesToDelete.push(col.indexNo)
      }
    })
  }

  _getUpdateAnnotatedColumnNames (annotatedColumns) {
    if (!annotatedColumns) {
      return []
    }

    return [...annotatedColumns.updateAnnotatedColumns.keys()]
  }

  _getAnnotatedInsertColumnNames (annotatedColumns) {
    return annotatedColumns ? [...annotatedColumns.insertAnnotatedColumns.keys()] : []
  }

  _getAnnotatedInsertColumnValues (annotatedColumns, annotatedInsertColumnNames) {
    const res = {}
    res.values = []
    res.valuesAndSQLs = []

    if (!annotatedColumns) {
      return res
    }

    const columnsToBeChecked = annotatedInsertColumnNames || annotatedColumns.insertAnnotatedColumns.keys()

    for (const col of columnsToBeChecked) {
      const annotatedValue = this._options[annotatedColumns.insertAnnotatedColumns.get(col).symbol]

      if (!annotatedValue || !annotatedValue.sql) {
        res.values.push(annotatedValue)
      }

      res.valuesAndSQLs.push(annotatedValue)
    }

    return res
  }

  _spliceArray (values) {
    for (let i = this._columnIndexesToDelete.length - 1; i >= 0; i--) {
      values.splice(this._columnIndexesToDelete[i], 1)
    }
  }
}

module.exports = InsertBuilder
