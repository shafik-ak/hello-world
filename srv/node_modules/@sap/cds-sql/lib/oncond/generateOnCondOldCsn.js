// OLD CSN
const _getElementName = (entity, string) => {
  const parts = string.split('.').reverse()
  const elementName = []

  for (const part of parts) {
    elementName.unshift(part)

    const name = elementName.join('.')

    if (entity.elements[name]) {
      return name
    }
  }
}

const _toRef = (associationName, alias, columnName) => {
  if (columnName.startsWith(`${associationName}.`)) {
    columnName = columnName.replace(new RegExp(`^${associationName}\\.`), '')
  }

  return { ref: alias ? [alias, columnName] : [columnName] }
}

const _selfToOn = (csn, csnElement, op, target, selectAlias, joinAlias) => {
  const targetName =
    csnElement.type === 'cds.Composition'
      ? _getElementName(csn.definitions[csnElement.target], target)
      : target.replace(`${csnElement.name}.`, '')

  return getOnCondOldCsn(
    csn.definitions[csnElement.target].elements[targetName],
    targetName,
    csn,
    selectAlias,
    joinAlias
  )
}

const _aliasStartsWithAssociation = (alias, associationName) => {
  if (alias) {
    return alias.startsWith(`${associationName}.`)
  }

  return false
}

const _refOrNullVal = (alias, secondAlias, associationName, joinAlias, selectAlias) => {
  if (alias) {
    return _toRef(
      associationName,
      _aliasStartsWithAssociation(secondAlias, associationName) ? joinAlias : selectAlias,
      alias
    )
  }

  return { val: null }
}

const _toOn = (arg1, arg2, op, csn, csnElement, associationName, selectAlias, joinAlias) => {
  const one = arg1 ? arg1['='] : null
  const two = arg2 ? arg2['='] : null

  if (one === '$self' || two === '$self') {
    return _selfToOn(csn, csnElement, op, one === '$self' ? two : one, joinAlias, selectAlias)
  }

  if (op === 'isNull' || op === 'isNotNull') {
    return [_toRef(associationName, selectAlias, one), op === 'isNull' ? '=' : '!=', { val: null }]
  }

  return [
    _refOrNullVal(one, two, associationName, joinAlias, selectAlias),
    op,
    _refOrNullVal(two, two, associationName, joinAlias, selectAlias)
  ]
}

const _args = (csn, csnElement, associationName, { args, op }, selectAlias, joinAlias) => {
  const on = []
  const length = args.length

  let i = 0

  while (i < length) {
    if (on.length !== 0) {
      on.push(op)
    }

    if (args[i] && args[i].op) {
      on.push(..._args(csn, csnElement, associationName, args[i], selectAlias, joinAlias))
      i++
    } else {
      on.push(..._toOn(args[i], args[i + 1], op, csn, csnElement, associationName, selectAlias, joinAlias))
      i = i + 2
    }
  }

  return on
}

const _foreignToOn = (csnElement, associationName, selectAlias, joinAlias) => {
  const on = []

  for (const key of Object.keys(csnElement.foreignKeys)) {
    if (on.length !== 0) {
      on.push('and')
    }

    on.push(
      _toRef(associationName, selectAlias, csnElement.foreignKeys[key].path),
      '=',
      _toRef(associationName, joinAlias, `${associationName}_${csnElement.foreignKeys[key].path}`)
    )
  }

  return on
}

/**
 * Get the ON conditions in CQN format based on the CSN.
 * @param {Object} csnElement
 * @param {String} associationName
 * @param {Object} csn
 * @param {string} selectAlias
 * @param {string} joinAlias
 * @returns {Array}
 * @private
 */
const getOnCondOldCsn = (csnElement, associationName, csn, selectAlias, joinAlias) => {
  if (csnElement.foreignKeys) {
    return _foreignToOn(csnElement, associationName, selectAlias, joinAlias)
  }

  return ['(', ..._args(csn, csnElement, associationName, csnElement.onCond, selectAlias, joinAlias), ')']
}

module.exports = {
  getOnCondOldCsn
}
